import{f as q,D as f,l as gt,W as Ft,b as Y,x as A,J as b,T as v,C as D,g as nt,_ as vt,a as J,P as ct,z as E,d as Z,o as O,B,c as Ut,j as ht,e as Tt,k as $t,m as U,S as k,h as lt,K as Xt,i as ft,A as kt,n as tt,p as Yt,R as G,X as qt,Z as $,q as st,r as ot,s as jt,t as Pt,u as Vt,v as Gt,w as Ht,L as Kt,y as It,E as Jt,F as rt,O as it}from"./index-CWasN_Qb.js";var Qt=Object.defineProperty,Zt=(R,t,e)=>t in R?Qt(R,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):R[t]=e,w=(R,t,e)=>(Zt(R,typeof t!="symbol"?t+"":t,e),e);const Nt=class j{constructor(t){w(this,"syncUnitTime",1e3),w(this,"vNodes"),w(this,"drawLayer"),w(this,"fullLayer"),w(this,"workId");const{vNodes:e,fullLayer:o,drawLayer:s}=t;this.vNodes=e,this.fullLayer=o,this.drawLayer=s}setWorkId(t){this.workId=t}getWorkId(){return this.workId}getWorkOptions(){return this.workOptions}setWorkOptions(t){var e,o,s;this.workOptions=t,this.syncUnitTime=t.syncUnitTime||this.syncUnitTime;const r=(e=this.workId)==null?void 0:e.toString(),i=r&&((o=this.vNodes)==null?void 0:o.get(r))||void 0;r&&i&&(i.opt=t,(s=this.vNodes)==null||s.setInfo(r,i))}updataOptService(t){var e,o;let s;const r=(e=this.workId)==null?void 0:e.toString();if(r&&t){const i=this.fullLayer.getElementsByName(r)||this.drawLayer&&this.drawLayer.getElementsByName(r)||[];if(i.length!==1)return;const n=i[0],{pos:a,zIndex:l,scale:c,angle:h,translate:d}=t,p={};q(l)&&(p.zIndex=l),a&&(p.pos=[a[0],a[1]]),c&&(p.scale=c),h&&(p.rotate=h),d&&(p.translate=d),n.attr(p);const y=n==null?void 0:n.getBoundingClientRect();return y&&(s=E(s,{x:Math.floor(y.x-j.SafeBorderPadding),y:Math.floor(y.y-j.SafeBorderPadding),w:Math.floor(y.width+j.SafeBorderPadding*2),h:Math.floor(y.height+j.SafeBorderPadding*2)})),(o=this.vNodes)==null||o.setInfo(r,{rect:s,centerPos:a}),s}}replace(t,e,o){var s;const r=t.getElementsByName(e),i=r.length;if(i){if(i>1)for(let n=1;n<r.length;n++)r[n].remove();t.replaceChild(o,r[0])}else t.append(o);this.fullLayer===t?(s=this.drawLayer)==null||s.getElementsByName(e).forEach(n=>{n.remove()}):this.fullLayer.getElementsByName(e).forEach(n=>{n.remove()})}static updateNodeOpt(t){const{node:e,opt:o,vNodes:s,willSerializeData:r,targetNode:i}=t,{zIndex:n,translate:a,angle:l,box:c,boxScale:h,boxTranslate:d,pointMap:p}=o;let y;const u=i&&Z(i)||s.get(e.name);if(!u)return;q(n)&&(e.setAttribute("zIndex",n),u.opt.zIndex=n);const m=e.parent;if(m){if(c&&d&&h){const{rect:P}=u,L=[];for(let z=0;z<u.op.length;z+=3)L.push(new O(u.op[z],u.op[z+1],u.op[z+2]));const I=B(L),S=[I.w*m.worldScaling[0],I.h*m.worldScaling[0]],T=[P.w-S[0],P.h-S[1]],W=[(P.w*h[0]-T[0])/S[0],(P.h*h[1]-T[1])/S[1]],M=[d[0]/m.worldScaling[0],d[1]/m.worldScaling[1]],g=u.op.map((z,F)=>{const X=F%3;return X===0?z+M[0]:X===1?z+M[1]:z}),x=[u.centerPos[0]+M[0],u.centerPos[1]+M[1]];Ut(g,x,W);const C=[];for(let z=0;z<g.length;z+=3)C.push(new O(g[z],g[z+1],g[z+2]));u.op=g,u.centerPos=x}else if(a)if(e.setAttribute("translate",a),u.opt.translate=a,i){const P=[a[0]*m.worldScaling[0],a[1]*m.worldScaling[1]];y=ht(u.rect,P),u.rect=y}else{const P=j.getRectFromLayer(m,e.name);u.rect=P||u.rect}else if(q(l))if(e.setAttribute("rotate",l),u.opt.rotate=l,i)y=Tt(u.rect,l),u.rect=y;else{const P=j.getRectFromLayer(m,e.name);u.rect=P||u.rect}if(p){const P=p.get(e.name);if(P)for(let L=0,I=0;L<u.op.length;L+=3,I++)u.op[L]=P[I][0],u.op[L+1]=P[I][1]}if(r){if(a){const P=[a[0],a[1]],L=u.op.map((I,S)=>{const T=S%3;return T===0?I+P[0]:T===1?I+P[1]:I});u.op=L,u.centerPos=[u.centerPos[0]+P[0],u.centerPos[1]+P[1]],u!=null&&u.opt&&(u.opt.translate=void 0)}else if(q(l)){const P=u.op;$t(P,u.centerPos,l),u.op=P,u!=null&&u.opt&&(u.opt.rotate=void 0)}}u&&s.setInfo(e.name,u)}}static getCenterPos(t,e){const{worldPosition:o,worldScaling:s}=e;return[(t.x+t.w/2-o[0])/s[0],(t.y+t.h/2-o[1])/s[1]]}static getRectFromLayer(t,e){const o=t.getElementsByName(e)[0];if(o){const s=o.getBoundingClientRect();return{x:Math.floor(s.x-j.SafeBorderPadding),y:Math.floor(s.y-j.SafeBorderPadding),w:Math.floor(s.width+j.SafeBorderPadding*2),h:Math.floor(s.height+j.SafeBorderPadding*2)}}}};w(Nt,"SafeBorderPadding",10);let N=Nt;function at(R,t=!0){const e=R.length;if(e<2)return"";let o=R[0],s=R[1];if(e===2)return`M${rt(o)}L${rt(s)}`;let r="";for(let i=2,n=e-1;i<n;i++)o=R[i],s=R[i+1],r+=it(o,s);return t?`M${it(R[0],R[1])}Q${rt(R[1])}${it(R[1],R[2])}T${r}${it(R[e-1],R[0])}${it(R[0],R[1])}Z`:`M${rt(R[0])}Q${rt(R[1])}${it(R[1],R[2])}${R.length>3?"T":""}${r}L${rt(R[e-1])}`}class Wt extends N{constructor(t){super(t),w(this,"canRotate",!0),w(this,"scaleType",U.all),w(this,"toolsType",v.Pencil),w(this,"syncTimestamp"),w(this,"syncIndex",0),w(this,"tmpPoints",[]),w(this,"MAX_REPEAR",10),w(this,"uniThickness"),w(this,"workOptions"),w(this,"centerPos",[0,0]),this.workOptions=t.toolsOpt,this.uniThickness=this.MAX_REPEAR/this.workOptions.thickness/10,this.syncTimestamp=0}combineConsume(){var t;const e=(t=this.workId)==null?void 0:t.toString(),o=this.transformDataAll(!0),s={name:e};let r;const i=this.drawLayer||this.fullLayer;return o.length&&(r=this.draw({attrs:s,tasks:o,replaceId:e,layer:i})),{rect:r,type:f.DrawWork,dataType:b.Local}}setWorkOptions(t){super.setWorkOptions(t),this.syncTimestamp=Date.now()}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:r,isMainThread:i,drawCount:n,replaceId:a}=t;if(((e=o.op)==null?void 0:e.length)===0)return{type:f.None};const{workId:l}=o,{tasks:c,effects:h,consumeIndex:d}=this.transformData(o,!1);this.syncIndex=Math.min(this.syncIndex,d,Math.max(0,this.tmpPoints.length-2));const p={name:l==null?void 0:l.toString(),id:n==null?void 0:n.toString()};let y,u=!1;const m=this.syncIndex;if(this.syncTimestamp===0&&(this.syncTimestamp=Date.now()),c.length&&(c[0].taskId-this.syncTimestamp>this.syncUnitTime&&(u=!0,this.syncTimestamp=c[0].taskId,this.syncIndex=this.tmpPoints.length),r||i)){const L=s?this.fullLayer:this.drawLayer||this.fullLayer;y=this.draw({attrs:p,tasks:c,effects:h,layer:L,replaceId:a})}if(r)return d>10&&this.tmpPoints.splice(0,d-10),{rect:y,type:f.DrawWork,dataType:b.Local};const P=[];return this.tmpPoints.slice(m).forEach(L=>{P.push(L.x,L.y,this.computRadius(L.z,this.workOptions.thickness))}),{rect:y,type:f.DrawWork,dataType:b.Local,workId:u?l:void 0,op:u?P:void 0,index:u?m*3:void 0}}consumeAll(t){var e,o;if(t.data){const{op:h,workState:d}=t.data;h!=null&&h.length&&d===D.Done&&this.workOptions.strokeType===$.Stroke&&this.updateTempPointsWithPressureWhenDone(h)}const s=(e=this.workId)==null?void 0:e.toString();if(!s)return{type:f.None};const r=this.transformDataAll(!0),i={name:s};let n;const a=this.fullLayer;r.length&&(n=this.draw({attrs:i,tasks:r,replaceId:s,layer:a}));const l=[];this.tmpPoints.map(h=>{l.push(h.x,h.y,this.computRadius(h.z,this.workOptions.thickness))}),this.syncTimestamp=0,delete this.workOptions.syncUnitTime;const c=G(l);return(o=this.vNodes)==null||o.setInfo(s,{rect:n,op:l,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:n&&N.getCenterPos(n,a)}),{rect:n,type:f.FullWork,dataType:b.Local,workId:s,ops:c,updateNodeOpt:{pos:this.centerPos,useAnimation:!0},opt:this.workOptions}}clearTmpPoints(){this.tmpPoints.length=0,this.syncTimestamp=0,this.syncIndex=0}consumeService(t){var e,o;const{op:s,isFullWork:r,replaceId:i}=t;this.tmpPoints.length=0;for(let h=0;h<s.length;h+=3){const d=new O(s[h],s[h+1],s[h+2]);if(this.tmpPoints.length>0){const p=this.tmpPoints[this.tmpPoints.length-1],y=k.Sub(d,p).uni();d.setv(y)}this.tmpPoints.push(d)}const n=this.transformDataAll(!1),a=(e=this.workId)==null?void 0:e.toString(),l={name:a};let c;if(a&&n.length){const h=r?this.fullLayer:this.drawLayer||this.fullLayer;c=this.draw({attrs:l,tasks:n,replaceId:i,layer:h}),(o=this.vNodes)==null||o.setInfo(a,{rect:c,op:s,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:c&&N.getCenterPos(c,h)})}return c}transformDataAll(t=!0){return this.getTaskPoints(this.tmpPoints,t&&this.workOptions.thickness||void 0)}draw(t){const{attrs:e,tasks:o,replaceId:s,effects:r,layer:i}=t,{strokeColor:n,strokeType:a,thickness:l,zIndex:c,scale:h,rotate:d,translate:p}=this.workOptions;r!=null&&r.size&&(r.forEach(I=>{var S;(S=i.getElementById(I+""))==null||S.remove()}),r.clear());let y;const u=[],m=i.worldPosition,P=i.worldScaling;for(let I=0;I<o.length;I++){const{pos:S,points:T}=o[I],{ps:W,rect:M}=this.computDrawPoints(T);let g;const x=T.length===1;a===$.Stroke||x?g=at(W,!0):g=at(W,!1);const C={pos:S,d:g,fillColor:a===$.Stroke||x?n:void 0,lineDash:a===$.Dotted&&!x?[1,l*2]:a===$.LongDotted&&!x?[l,l*2]:void 0,strokeColor:n,lineCap:a===$.Stroke||x?void 0:"round",lineWidth:a===$.Stroke||x?0:l};y=E(y,{x:Math.floor((M.x+S[0])*P[0]+m[0]-N.SafeBorderPadding),y:Math.floor((M.y+S[1])*P[1]+m[1]-N.SafeBorderPadding),w:Math.floor(M.w*P[0]+2*N.SafeBorderPadding),h:Math.floor(M.h*P[1]+2*N.SafeBorderPadding)}),u.push(C)}h&&(e.scale=h),d&&(e.rotate=d),p&&(e.translate=p);const L=new J;if(y){this.centerPos=N.getCenterPos(y,i),L.attr({...e,normalize:!0,anchor:[.5,.5],bgcolor:a===$.Stroke?n:void 0,pos:this.centerPos,size:[(y.w-2*N.SafeBorderPadding)/P[0],(y.h-2*N.SafeBorderPadding)/P[1]],zIndex:c});const I=u.map(S=>(S.pos=[S.pos[0]-this.centerPos[0],S.pos[1]-this.centerPos[1]],new st(S)));L.append(...I),a===$.Stroke&&L.seal(),this.replace(i,s||e.workId,L)}if(h||d||p){const I=L==null?void 0:L.getBoundingClientRect();if(I)return{x:Math.floor(I.x-N.SafeBorderPadding),y:Math.floor(I.y-N.SafeBorderPadding),w:Math.floor(I.width+N.SafeBorderPadding*2),h:Math.floor(I.height+N.SafeBorderPadding*2)}}return y}computDrawPoints(t){return this.workOptions.strokeType===$.Stroke||t.length===1?this.computStroke(t):this.computNomal(t)}computNomal(t){let e=this.workOptions.thickness;const o=t.map(s=>(e=Math.max(e,s.radius),s.point));return{ps:o,rect:B(o,e)}}computStroke(t){return t.length===1?this.computDotStroke(t[0]):this.computLineStroke(t)}computLineStroke(t){const e=[],o=[];for(let a=0;a<t.length;a++){const{point:l,radius:c}=t[a];let h=l.v;a===0&&t.length>1&&(h=t[a+1].point.v);const d=k.Per(h).mul(c);e.push(O.Sub(l,d)),o.push(O.Add(l,d))}const s=t[t.length-1],r=O.GetSemicircleStroke(s.point,e[e.length-1],-1,8),i=O.GetSemicircleStroke(t[0].point,o[0],-1,8),n=e.concat(r,o.reverse(),i);return{ps:n,rect:B(n)}}computDotStroke(t){const{point:e,radius:o}=t,s={x:e.x-o,y:e.y-o,w:o*2,h:o*2};return{ps:O.GetDotStroke(e,o,8),rect:s}}transformData(t,e){const{op:o,workState:s}=t;let r=this.tmpPoints.length-1,i=[];if(o!=null&&o.length&&s){const{strokeType:n,thickness:a}=this.workOptions,l=new Set;r=n===$.Stroke?this.updateTempPointsWithPressure(o,a,l):this.updateTempPoints(o,a,l);const c=e?this.tmpPoints:this.tmpPoints.slice(r);return i=this.getTaskPoints(c,a),{tasks:i,effects:l,consumeIndex:r}}return{tasks:i,consumeIndex:r}}computRadius(t,e){return t*.03*e+e*.5}getMinZ(t,e){return((e||Math.max(1,Math.floor(t*.3)))-t*.5)*100/t/3}getTaskPoints(t,e){var o;const s=[];if(t.length===0)return[];let r=0,i=t[0].x,n=t[0].y,a=[i,n],l=[],c=t[0].t;for(;r<t.length;){const h=t[r],d=h.x-i,p=h.y-n,y=h.z,u=e?this.computRadius(y,e):y;if(l.push({point:new O(d,p,y,t[r].v),radius:u}),r>0&&r<t.length-1){const m=t[r].getAngleByPoints(t[r-1],t[r+1]);if(m<90||m>270){const P=(o=l.pop())==null?void 0:o.point.clone();P&&s.push({taskId:c,pos:a,points:[...l,{point:P,radius:u}]}),i=t[r].x,n=t[r].y,a=[i,n];const L=h.x-i,I=h.y-n;l=[{point:new O(L,I,y),radius:u}],c=Date.now()}}r++}return s.push({taskId:c,pos:a,points:l}),s}updateTempPointsWithPressure(t,e,o){const s=Date.now(),r=this.tmpPoints.length;let i=r;for(let a=0;a<t.length;a+=2){i=Math.min(i,r);const l=this.tmpPoints.length,c=new O(t[a],t[a+1]);if(l===0){this.tmpPoints.push(c);continue}const h=l-1,d=this.tmpPoints[h],p=k.Sub(c,d).uni();if(c.isNear(d,e)){if(d.z<this.MAX_REPEAR){if(d.setz(Math.min(d.z+1,this.MAX_REPEAR)),i=Math.min(i,h),l>1){let m=l-1;for(;m>0;){const P=this.tmpPoints[m].distance(this.tmpPoints[m-1]),L=Math.max(this.tmpPoints[m].z-this.uniThickness*P,0);if(this.tmpPoints[m-1].z>=L)break;this.tmpPoints[m-1].setz(L),i=Math.min(i,m-1),m--}}}else i=1/0;continue}c.setv(p);const y=c.distance(d),u=Math.max(d.z-this.uniThickness*y,0);l>1&&k.Equals(p,d.v,.02)&&(u>0||d.z<=0)&&(o&&d.t&&o.add(d.t),this.tmpPoints.pop(),i=Math.min(h,i)),c.setz(u),this.tmpPoints.push(c)}if(i===1/0)return this.tmpPoints.length;let n=r;if(i===r){n=Math.max(n-1,0);const a=this.tmpPoints[n].t;a&&(o==null||o.add(a))}else{let a=r-1;for(n=i;a>=0;){const l=this.tmpPoints[a].t;if(l&&(o==null||o.add(l),a<=i)){n=a,a=-1;break}a--}}return this.tmpPoints[n].setT(s),n}updateTempPoints(t,e,o){var s;const r=Date.now(),i=this.tmpPoints.length;let n=i;for(let l=0;l<t.length;l+=2){const c=this.tmpPoints.length,h=new O(t[l],t[l+1]);if(c===0){this.tmpPoints.push(h);continue}const d=c-1,p=this.tmpPoints[d],y=k.Sub(h,p).uni();if(h.isNear(p,e/2)){n=Math.min(d,n);continue}k.Equals(y,p.v,.02)&&(o&&p.t&&o.add(p.t),this.tmpPoints.pop(),n=Math.min(d,n)),h.setv(y),this.tmpPoints.push(h)}let a=i;if(n===i){a=Math.max(a-1,0);const l=this.tmpPoints[a].t;l&&(o==null||o.add(l))}else{let l=Math.min(i-1,n);for(a=n;l>=0;){const c=(s=this.tmpPoints[l])==null?void 0:s.t;if(c&&(o==null||o.add(c),l<=n)){a=l,l=-1;break}l--}}return this.tmpPoints[a].setT(r),a}updateTempPointsWithPressureWhenDone(t){const{thickness:e}=this.workOptions,o=t.length,s=this.getMinZ(e);for(let r=0;r<o;r+=2){const i=this.tmpPoints.length,n=new O(t[r],t[r+1]);if(i===0){this.tmpPoints.push(n);continue}const a=i-1,l=this.tmpPoints[a],c=k.Sub(n,l).uni(),h=n.distance(l);if(i>1&&l.z===s)break;if(n.isNear(l,e/2)){if(o<3&&l.z<this.MAX_REPEAR&&(l.setz(Math.min(l.z+1,this.MAX_REPEAR)),i>1)){let p=i-1;for(;p>0;){const y=this.tmpPoints[p].distance(this.tmpPoints[p-1]),u=Math.max(this.tmpPoints[p].z-this.uniThickness*y,-e/4);if(this.tmpPoints[p-1].z>=u)break;this.tmpPoints[p-1].setz(u),p--}}continue}n.setv(c);const d=Math.max(l.z-this.uniThickness*h,s);i>1&&k.Equals(c,l.v,.02)&&l.z<=0&&this.tmpPoints.pop(),n.setz(d),this.tmpPoints.push(n)}}static updateNodeOpt(t){var e;const{node:o,opt:s,vNodes:r}=t,{strokeColor:i}=s,n=r.get(o.name);return i&&(o.tagName==="GROUP"?_t(o)?o.setAttribute("bgcolor",i):o.children.forEach(a=>{a.setAttribute("strokeColor",i),a.getAttribute("fillColor")&&a.setAttribute("fillColor",i)}):(o.setAttribute("strokeColor",i),o.setAttribute("fillColor",i)),(e=n==null?void 0:n.opt)!=null&&e.strokeColor&&(n.opt.strokeColor=i)),n&&r.setInfo(o.name,n),N.updateNodeOpt(t)}}class Lt extends N{constructor(t){super(t),w(this,"toolsType",v.LaserPen),w(this,"canRotate",!1),w(this,"scaleType",U.none),w(this,"syncTimestamp"),w(this,"syncIndex",0),w(this,"tmpPoints",[]),w(this,"workOptions"),w(this,"consumeIndex",0),this.workOptions=t.toolsOpt,this.syncTimestamp=0}combineConsume(){}setWorkOptions(t){super.setWorkOptions(t),this.syncTimestamp=Date.now()}consume(t){const{data:e,isSubWorker:o}=t,{workId:s,op:r}=e;if((r==null?void 0:r.length)===0)return{type:f.None};if(this.updateTempPoints(r||[]),this.consumeIndex>this.tmpPoints.length-4)return{type:f.None};const{strokeColor:i,thickness:n,strokeType:a}=this.workOptions,l=B(this.tmpPoints,n);let c=!1;const h=this.syncIndex,d=this.tmpPoints.slice(this.consumeIndex);this.consumeIndex=this.tmpPoints.length-1,this.syncTimestamp===0&&(this.syncTimestamp=Date.now());const p={name:s==null?void 0:s.toString(),opacity:1,lineDash:a===$.Dotted?[1,n*2]:a===$.LongDotted?[n,n*2]:void 0,strokeColor:i,lineCap:"round",lineWidth:n,anchor:[.5,.5]},y=this.getTaskPoints(d);if(y.length){const m=Date.now();m-this.syncTimestamp>this.syncUnitTime&&(c=!0,this.syncTimestamp=m,this.syncIndex=this.tmpPoints.length),o&&this.draw({attrs:p,tasks:y,isDot:!1,layer:this.drawLayer||this.fullLayer})}const u=[];return this.tmpPoints.slice(h).forEach(m=>{u.push(m.x,m.y)}),{rect:{x:l.x*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],y:l.y*this.fullLayer.worldScaling[1]+this.fullLayer.worldPosition[1],w:l.w*this.fullLayer.worldScaling[0],h:l.h*this.fullLayer.worldScaling[1]},type:f.DrawWork,dataType:b.Local,workId:c?s:void 0,op:c?u:void 0,index:c?h*2:void 0}}consumeAll(){var t;const e=(t=this.workId)==null?void 0:t.toString();let o;if(this.tmpPoints.length-1>this.consumeIndex){let i=this.tmpPoints.slice(this.consumeIndex);const n=i.length===1,{strokeColor:a,thickness:l,strokeType:c}=this.workOptions;if(n){const p=this.computDotStroke({point:i[0],radius:l/2});i=p.ps,o=p.rect}else o=B(this.tmpPoints,l);const h={name:e==null?void 0:e.toString(),fillColor:n?a:void 0,opacity:1,lineDash:c===$.Dotted&&!n?[1,l*2]:c===$.LongDotted&&!n?[l,l*2]:void 0,strokeColor:a,lineCap:n?void 0:"round",lineWidth:n?0:l,anchor:[.5,.5]},d=this.getTaskPoints(i);d.length&&this.draw({attrs:h,tasks:d,isDot:n,layer:this.drawLayer||this.fullLayer})}const s=[];this.tmpPoints.forEach(i=>{s.push(i.x,i.y)});const r=G(s);return{rect:o&&{x:o.x*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],y:o.y*this.fullLayer.worldScaling[1]+this.fullLayer.worldPosition[1],w:o.w*this.fullLayer.worldScaling[0],h:o.h*this.fullLayer.worldScaling[1]},type:f.FullWork,dataType:b.Local,workId:e,ops:r,index:this.syncIndex*2}}clearTmpPoints(){this.tmpPoints.length=0,this.syncTimestamp=0,this.syncIndex=0}consumeService(t){var e;const{op:o,replaceId:s,isFullWork:r}=t,{strokeColor:i,thickness:n,strokeType:a}=this.workOptions;if(!o.length){const u=B(this.tmpPoints,n);return{x:u.x*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],y:u.y*this.fullLayer.worldScaling[1]+this.fullLayer.worldPosition[1],w:u.w*this.fullLayer.worldScaling[0],h:u.h*this.fullLayer.worldScaling[1]}}const l=Math.max(0,this.tmpPoints.length-1);this.updateTempPoints(o||[]);let c,h=this.tmpPoints.slice(l);const d=h.length===1;if(d){const u=this.computDotStroke({point:h[0],radius:n/2});h=u.ps,c=u.rect}else c=B(this.tmpPoints,n);const p={name:(e=this.workId)==null?void 0:e.toString(),fillColor:d?i:void 0,opacity:1,lineDash:a===$.Dotted&&!d?[1,n*2]:a===$.LongDotted&&!d?[n,n*2]:void 0,strokeColor:i,lineCap:d?void 0:"round",lineWidth:d?0:n,anchor:[.5,.5]},y=this.getTaskPoints(h);if(y.length){const u=r?this.fullLayer:this.drawLayer||this.fullLayer;this.draw({attrs:p,tasks:y,isDot:d,replaceId:s,layer:u})}return{x:c.x*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],y:c.y*this.fullLayer.worldScaling[1]+this.fullLayer.worldPosition[1],w:c.w*this.fullLayer.worldScaling[0],h:c.h*this.fullLayer.worldScaling[1]}}computDotStroke(t){const{point:e,radius:o}=t,s={x:e.x-o,y:e.y-o,w:o*2,h:o*2};return{ps:O.GetDotStroke(e,o,8),rect:s}}updateTempPoints(t){const e=this.tmpPoints.length;for(let o=0;o<t.length;o+=2){if(e){const s=this.tmpPoints.slice(-1)[0];s&&s.x===t[o]&&s.y===t[o+1]&&this.tmpPoints.pop()}this.tmpPoints.push(new O(t[o],t[o+1]))}}async draw(t){const{attrs:e,tasks:o,isDot:s,layer:r}=t,{duration:i}=this.workOptions;for(const n of o){const a=new st,{pos:l,points:c}=n;let h;s?h=at(c,!0):h=at(c,!1),a.attr({...e,pos:l,d:h});const{vertex:d,fragment:p}=this.workOptions;if(d&&p){const y=r.renderer.createProgram({vertex:d,fragment:p}),{width:u,height:m}=r.getResolution();a.setUniforms({u_time:0,u_resolution:[u,m]}),a.setProgram(y)}r.appendChild(a),a.transition(i).attr({scale:s?[.1,.1]:[1,1],lineWidth:s?0:1}).then(()=>{a.remove()})}}getTaskPoints(t){var e;const o=[];if(t.length===0)return[];let s=0,r=t[0].x,i=t[0].y,n=[r,i],a=[];for(;s<t.length;){const l=t[s],c=l.x-r,h=l.y-i;if(a.push(new O(c,h)),s>0&&s<t.length-1){const d=t[s].getAngleByPoints(t[s-1],t[s+1]);if(d<90||d>270){const p=(e=a.pop())==null?void 0:e.clone();p&&o.push({pos:n,points:[...a,p]}),r=t[s].x,i=t[s].y,n=[r,i];const y=l.x-r,u=l.y-i;a=[new O(y,u)]}}s++}return o.push({pos:n,points:a}),o}removeLocal(){}removeService(t){let e;const o=[];return this.fullLayer.getElementsByName(t).forEach(s=>{if(s.name===t){const r=s.getBoundingClientRect();e=E(e,{x:r.x,y:r.y,w:r.width,h:r.height}),o.push(s)}}),o.length&&o.forEach(s=>s.remove()),e}}const xt=class dt extends N{constructor(t,e){super(t),w(this,"canRotate",!1),w(this,"scaleType",U.none),w(this,"toolsType",v.Eraser),w(this,"serviceWork"),w(this,"tmpPoints",[]),w(this,"workOptions"),w(this,"worldPosition"),w(this,"worldScaling"),w(this,"eraserRect"),w(this,"eraserPolyline"),this.serviceWork=e,this.workOptions=t.toolsOpt,this.worldPosition=this.fullLayer.worldPosition,this.worldScaling=this.fullLayer.worldScaling}combineConsume(){}consumeService(){}setWorkOptions(t){super.setWorkOptions(t)}createEraserRect(t){const e=t[0]*this.worldScaling[0]+this.worldPosition[0],o=t[1]*this.worldScaling[1]+this.worldPosition[1],{width:s,height:r}=dt.eraserSizes[this.workOptions.thickness];this.eraserRect={x:e-s*.5,y:o-r*.5,w:s,h:r},this.eraserPolyline=[this.eraserRect.x,this.eraserRect.y,this.eraserRect.x+this.eraserRect.w,this.eraserRect.y+this.eraserRect.h]}computRectCenterPoints(){const t=this.tmpPoints.slice(-2);if(this.tmpPoints.length===4){const e=new k(this.tmpPoints[0],this.tmpPoints[1]),o=new k(this.tmpPoints[2],this.tmpPoints[3]),s=k.Sub(o,e).uni(),r=k.Dist(e,o),{width:i,height:n}=dt.eraserSizes[this.workOptions.thickness],a=Math.min(i,n),l=Math.round(r/a);if(l>1){const c=[];for(let h=0;h<l;h++){const d=k.Mul(s,h*a);c.push(this.tmpPoints[0]+d.x,this.tmpPoints[1]+d.y)}return c.concat(t)}}return t}isNear(t,e){const o=new k(t[0],t[1]),s=new k(e[0],e[1]),{width:r,height:i}=dt.eraserSizes[this.workOptions.thickness];return k.Dist(o,s)<Math.hypot(r,i)*.5}cutPolyline(t,e){let o=[e],s=0;for(;s<t.length;){const n=t[s];if(n.length<2)break;o=r(o,n),s++}return o;function r(n,a){const l=n;for(let c=0;c<n.length;c++){const h=n[c],d=h.findIndex((p,y)=>y<h.length-1?i([p,h[y+1]],[a[0],a[1]]):!1);if(d!==-1&&d>-1){const p=[],y=h.slice(0,d+1);if(k.Equals(h[d],a[0])||y.push(a[0].clone().setz(h[d].z)),y.length>1&&p.push(y),d+a.length-1<h.length-1){const u=d+a.length-1,m=h.slice(u),P=a[a.length-1];k.Equals(h[u],P)||m.unshift(P.clone().setz(h[u].z)),m.length>1&&p.push(m)}return l.splice(c,1,...p),l}}return l}function i(n,a){const l=k.Sub(n[1],n[0]),c=k.Sub(a[1],a[0]),h=k.Sub(a[0],n[0]);return Math.abs(k.Cpr(l,c))<.1&&Math.abs(k.Cpr(l,h))<.1}}isSamePoint(t,e){return t[0]===e[0]&&t[1]===e[1]}translateIntersect(t){const e=[];for(let o=0;o<t.length;o++){const s=t[o].filter((n,a,l)=>!(a>0&&this.isSamePoint(n,l[a-1]))),r=[];let i=0;for(;i<s.length;){const n=s[i],a=new k(n[0],n[1]);r.push(a),i++}e.push(r)}return e}isLineEraser(t,e){return!(t===v.Pencil&&!e)}remove(t){const{curNodeMap:e,removeIds:o,newWorkDatas:s}=t,{isLine:r}=this.workOptions;let i;for(const[n,a]of e.entries())if(a.rect&&this.eraserRect&&this.eraserPolyline&&lt(this.eraserRect,a.rect)){const{op:l,toolsType:c}=a,h=this.isLineEraser(c,r),d=[],p=[];for(let u=0;u<l.length;u+=3){const m=new k(l[u]*this.worldScaling[0]+this.worldPosition[0],l[u+1]*this.worldScaling[1]+this.worldPosition[1],l[u+2]);p.push(m),d.push(new O(m.x,m.y))}const y=d.length&&B(d)||a.rect;if(lt(y,this.eraserRect)){if(p.length>1){const u=Xt.polyline(p.map(m=>m.XY),this.eraserPolyline);if(u.length&&(o.add(a.name),!h)){const m=this.translateIntersect(u),P=this.cutPolyline(m,p);for(let L=0;L<P.length;L++){const I=`${n}_s_${L}`,S=[];P[L].forEach(T=>{S.push((T.x-this.worldPosition[0])/this.worldScaling[0],(T.y-this.worldPosition[1])/this.worldScaling[1],T.z)}),a.opt&&a.toolsType&&this.vNodes&&(this.vNodes.setInfo(I,{rect:y,op:S,opt:a.opt,canRotate:a.canRotate,scaleType:a.scaleType,toolsType:a.toolsType}),s.set(I,{workId:I,op:S,opt:a.opt,toolsType:a.toolsType}))}}}else o.add(a.name);i=E(i,y)}}return o.forEach(n=>{var a;return(a=this.vNodes)==null?void 0:a.delete(n)}),i&&(i.x-=N.SafeBorderPadding,i.y-=N.SafeBorderPadding,i.w+=N.SafeBorderPadding*2,i.h+=N.SafeBorderPadding*2),i}consume(t){const{op:e}=t.data;if(!e||e.length===0)return{type:f.None};const o=this.tmpPoints.length;if(o>1&&this.isNear([e[0],e[1]],[this.tmpPoints[o-2],this.tmpPoints[o-1]]))return{type:f.None};o===4&&(this.tmpPoints.shift(),this.tmpPoints.shift()),this.tmpPoints.push(e[0],e[1]);const s=this.computRectCenterPoints();let r;const i=new Set,n=new Map;if(!this.vNodes)return{type:f.None};this.vNodes.setTarget();const a=this.getUnLockNodeMap(this.vNodes.getLastTarget());for(let l=0;l<s.length-1;l+=2){this.createEraserRect(s.slice(l,l+2));const c=this.remove({curNodeMap:a,removeIds:i,newWorkDatas:n});r=E(r,c)}if(this.vNodes.deleteLastTarget(),r&&i.size){for(const l of n.keys())i.has(l)&&n.delete(l);return{type:f.RemoveNode,dataType:b.Local,rect:r,removeIds:[...i],newWorkDatas:n}}return{type:f.None}}consumeAll(t){return this.consume(t)}clearTmpPoints(){this.tmpPoints.length=0}getUnLockNodeMap(t){var e;if(this.serviceWork){const o=Z(t),s=this.serviceWork.selectorWorkShapes,r=this.serviceWork.workShapes;for(const i of s.values())if((e=i.selectIds)!=null&&e.length)for(const n of i.selectIds)o.delete(n);for(const i of r.keys())o.delete(i);return o}return t}};w(xt,"eraserSizes",Object.freeze([Object.freeze({width:18,height:26}),Object.freeze({width:26,height:34}),Object.freeze({width:34,height:50})]));let bt=xt;const mt=class et extends N{constructor(t){super(t),w(this,"toolsType",v.Selector),w(this,"tmpPoints",[]),w(this,"workOptions"),w(this,"vNodes"),w(this,"selectIds"),w(this,"selectorColor"),w(this,"strokeColor"),w(this,"fillColor"),w(this,"oldSelectRect"),w(this,"canRotate",!1),w(this,"canTextEdit",!1),w(this,"canLock",!1),w(this,"scaleType",U.all),w(this,"toolsTypes"),w(this,"shapeOpt"),w(this,"textOpt"),w(this,"isLocked"),this.workOptions=t.toolsOpt,this.vNodes=t.vNodes}computSelector(t=!0){const e=B(this.tmpPoints);if(e.w===0||e.h===0)return{selectIds:[],intersectRect:void 0,subNodeMap:new Map};const{rectRange:o,nodeRange:s}=this.vNodes.getRectIntersectRange(e,t);return{selectIds:[...s.keys()],intersectRect:o,subNodeMap:s}}updateTempPoints(t){const e=this.tmpPoints.length,o=t.length;if(o>1){const s=new O(t[o-2]*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],t[o-1]*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[1]);e===2?this.tmpPoints.splice(1,1,s):this.tmpPoints.push(s)}}drawSelector(t){const{drawRect:e,subNodeMap:o,selectorId:s,layer:r,isService:i}=t,n=new J({pos:[e.x,e.y],anchor:[0,0],size:[e.w,e.h],id:s,name:s,zIndex:1e3}),a=[];if(i){const l=new ft({normalize:!0,pos:[e.w/2,e.h/2],lineWidth:1,strokeColor:this.selectorColor||this.workOptions.strokeColor,width:e.w,height:e.h,name:et.selectorBorderId});a.push(l)}o.forEach((l,c)=>{const h=[l.rect.x+l.rect.w/2-e.x,l.rect.y+l.rect.h/2-e.y],d=new ft({normalize:!0,pos:h,lineWidth:1,strokeColor:o.size>1?this.selectorColor||this.workOptions.strokeColor:void 0,width:l.rect.w,height:l.rect.h,id:`selector-${c}`,name:`selector-${c}`});a.push(d)}),a&&n.append(...a),(r==null?void 0:r.parent).appendChild(n)}draw(t,e,o,s=!1){var r,i;const{intersectRect:n,subNodeMap:a}=o;(i=(r=e.parent)==null?void 0:r.getElementById(t))==null||i.remove(),n&&this.drawSelector({drawRect:n,subNodeMap:a,selectorId:t,layer:e,isService:s})}getSelecteorInfo(t){this.scaleType=U.all,this.canRotate=!1,this.textOpt=void 0,this.strokeColor=void 0,this.fillColor=void 0,this.canTextEdit=!1,this.canLock=!1,this.isLocked=!1,this.toolsTypes=void 0,this.shapeOpt=void 0;const e=new Set;let o;for(const s of t.values()){const{opt:r,canRotate:i,scaleType:n,toolsType:a}=s;this.selectorColor=this.workOptions.strokeColor,r.strokeColor&&(this.strokeColor=r.strokeColor),r.fillColor&&(this.fillColor=r.fillColor),r.textOpt&&(this.textOpt=r.textOpt),a===v.SpeechBalloon&&(e.add(a),this.shapeOpt||(this.shapeOpt={}),this.shapeOpt.placement=r.placement),a===v.Polygon&&(e.add(a),this.shapeOpt||(this.shapeOpt={}),this.shapeOpt.vertices=r.vertices),a===v.Star&&(e.add(a),this.shapeOpt||(this.shapeOpt={}),this.shapeOpt.vertices=r.vertices,this.shapeOpt.innerRatio=r.innerRatio,this.shapeOpt.innerVerticeStep=r.innerVerticeStep),a===v.Text&&(this.textOpt=r),t.size===1&&(this.textOpt&&(this.canTextEdit=!0),this.canRotate=i,this.scaleType=n),n===U.none&&(this.scaleType=n),a===v.Image&&(o=s)}e.size&&(this.toolsTypes=[...e]),o&&(t.size===1?(this.canLock=!0,o.opt.locked&&(this.isLocked=!0,this.scaleType=U.none,this.canRotate=!1,this.textOpt=void 0,this.fillColor=void 0,this.selectorColor="rgb(177,177,177)",this.strokeColor=void 0,this.canTextEdit=!1)):t.size>1&&!o.opt.locked&&(this.canLock=!1,this.canRotate=!1))}getChildrenPoints(){var t,e;if(this.scaleType===U.both&&((t=this.selectIds)==null?void 0:t.length)===1){const o=this.selectIds[0],s=(e=this.vNodes.get(o))==null?void 0:e.op;if(s){const r=[];for(let i=0;i<s.length;i+=3)r.push([s[i],s[i+1]]);return r}}}consume(t){const{op:e,workState:o}=t.data;let s=this.oldSelectRect;if(o===D.Start&&(s=this.unSelectedAllIds()),!(e!=null&&e.length)||!this.vNodes.curNodeMap.size)return{type:f.None};this.updateTempPoints(e);const r=this.computSelector();if(this.selectIds&&nt(this.selectIds,r.selectIds))return{type:f.None};this.selectIds=r.selectIds;const i=r.intersectRect;this.getSelecteorInfo(r.subNodeMap),this.draw(et.selectorId,this.fullLayer,r),this.oldSelectRect=i;const n=this.getChildrenPoints();return{type:f.Select,dataType:b.Local,rect:E(i,s),selectIds:r.selectIds,opt:this.workOptions,selectRect:i,selectorColor:this.selectorColor,strokeColor:this.strokeColor,fillColor:this.fillColor,textOpt:this.textOpt,canTextEdit:this.canTextEdit,canRotate:this.canRotate,canLock:this.canLock,scaleType:this.scaleType,willSyncService:!0,points:n,isLocked:this.isLocked,toolsTypes:this.toolsTypes,shapeOpt:this.shapeOpt}}consumeAll(){var t,e;let o=this.oldSelectRect;if(!((t=this.selectIds)!=null&&t.length)&&this.tmpPoints[0]&&this.selectSingleTool(this.tmpPoints[0].XY,et.selectorId,!1),(e=this.selectIds)!=null&&e.length&&(o=this.selectedByIds(this.selectIds)),o){const s=this.getChildrenPoints();return{type:f.Select,dataType:b.Local,rect:this.oldSelectRect,selectIds:this.selectIds,opt:this.workOptions,selectorColor:this.selectorColor,selectRect:this.oldSelectRect,strokeColor:this.strokeColor,fillColor:this.fillColor,textOpt:this.textOpt,canTextEdit:this.canTextEdit,canRotate:this.canRotate,canLock:this.canLock,scaleType:this.scaleType,willSyncService:!0,points:s,isLocked:this.isLocked,toolsTypes:this.toolsTypes,shapeOpt:this.shapeOpt}}return{type:f.None}}consumeService(){}clearTmpPoints(){this.tmpPoints.length=0}clearSelectData(){this.selectIds=void 0,this.oldSelectRect=void 0}selectSingleTool(t,e=et.selectorId,o=!1){if(t.length===2){const s=t[0],r=t[1];let i;const{nodeRange:n}=this.vNodes.getRectIntersectRange({x:s,y:r,w:0,h:0},!1),a=[...n.values()].sort((l,c)=>(c.opt.zIndex||0)-(l.opt.zIndex||0));for(const l of a){const c=this.fullLayer.getElementsByName(l.name);if(Bt(c).find(h=>h.isPointCollision(s,r))){i=l;break}}if(i){const l=i.name;if(!nt(this.oldSelectRect,i.rect)){const c=new Map([[l,i]]);this.getSelecteorInfo(c),this.draw(e,this.fullLayer,{intersectRect:i.rect,subNodeMap:c,selectIds:this.selectIds||[]},o)}this.selectIds=[l],this.oldSelectRect=i.rect}}}unSelectedAllIds(){let t;for(const[e,o]of this.vNodes.curNodeMap.entries())o.isSelected&&(t=E(t,o.rect),this.vNodes.unSelected(e));return t}unSelectedByIds(t){let e;for(const o of t){const s=this.vNodes.get(o);s&&s.isSelected&&(e=E(e,s.rect),this.vNodes.unSelected(o))}return e}selectedByIds(t){let e;for(const o of t){const s=this.vNodes.get(o);s&&(e=E(e,s.rect),this.vNodes.selected(o))}return e}getSelectorRect(t,e){var o;let s;const r=(o=t.parent)==null?void 0:o.getElementById(e),i=r==null?void 0:r.getBoundingClientRect();return i&&(s=E(s,{x:Math.floor(i.x),y:Math.floor(i.y),w:Math.floor(i.width+1),h:Math.floor(i.height+1)})),s}isCanFillColor(t){return t===v.Ellipse||t===v.Triangle||t===v.Rectangle||t===v.Polygon||t===v.Star||t===v.SpeechBalloon}async updateSelector(t){const{updateSelectorOpt:e,selectIds:o,vNodes:s,willSerializeData:r,worker:i,offset:n,scene:a,isMainThread:l}=t,c=this.fullLayer;if(!c)return;let h;const d=new Map,{box:p,workState:y,angle:u,translate:m}=e;let P=[0,0],L=[1,1],I=[0,0],S,T;if(p||m||q(u)){if(y===D.Start)return s.setTarget(),{type:f.Select,dataType:b.Local,selectRect:this.oldSelectRect,rect:this.oldSelectRect};if(S=s.getLastTarget(),S&&p){let g;o==null||o.forEach(x=>{const C=S==null?void 0:S.get(x);g=E(g,C==null?void 0:C.rect)}),g&&(L=[p.w/g.w,p.h/g.h],P=[p.x+p.w/2-(g.x+g.w/2),p.y+p.h/2-(g.y+g.h/2)],I=[g.x+g.w/2,g.y+g.h/2]),T=g}}if(o)for(const g of o){const x=s.get(g);if(x){const{toolsType:C}=x;let z=(c==null?void 0:c.getElementsByName(g))[0];if(z){const F={...e};let X;if(C){if(X=S==null?void 0:S.get(g),X&&p){F.boxScale=L;const Q=[X.rect.x+X.rect.w/2,X.rect.y+X.rect.h/2],_=[Q[0]-I[0],Q[1]-I[1]];F.boxTranslate=[_[0]*(L[0]-1)+P[0]+(n&&n[0]||0),_[1]*(L[1]-1)+P[1]+(n&&n[1]||0)]}const St=zt(C);if(St==null||St.updateNodeOpt({node:z,opt:F,vNodes:s,willSerializeData:r,targetNode:X}),x&&i&&(r&&(F.angle||F.translate)||F.box&&F.workState!==D.Start||F.pointMap&&F.pointMap.has(g)||C===v.Text&&(F.fontSize||F.translate||F.textInfos&&F.textInfos.get(g))||C===v.Image&&(F.angle||F.translate||F.boxScale)||C===F.toolsType&&F.willRefresh)){const Q=i.createWorkShapeNode({toolsType:C,toolsOpt:x.opt});Q==null||Q.setWorkId(g);let _;C===v.Image&&a?_=await Q.consumeServiceAsync({isFullWork:!0,replaceId:g,scene:a,isMainThread:l}):C===v.Text?_=await Q.consumeServiceAsync({isFullWork:!0,replaceId:g}):_=Q==null?void 0:Q.consumeService({op:x.op,isFullWork:!0,replaceId:g}),_&&(x.rect=_),z=(c==null?void 0:c.getElementsByName(g))[0]}x&&(d.set(g,x),h=E(h,x.rect))}}}}S&&y===D.Done&&(s.deleteLastTarget(),S=void 0);const W=h;if(T&&e.dir&&W&&!n){const g=[0,0];switch(e.dir){case"top":{const x=[T.x,T.y+T.h];e.reverseY?g[1]=x[1]-W.y:g[1]=x[1]-(W.y+W.h);break}case"topLeft":{const x=[T.x+T.w,T.y+T.h];e.reverseY?g[1]=x[1]-W.y:g[1]=x[1]-(W.y+W.h),e.reverseX?g[0]=x[0]-W.x:g[0]=x[0]-(W.x+W.w);break}case"topRight":{const x=[T.x,T.y+T.h];e.reverseY?g[1]=x[1]-W.y:g[1]=x[1]-(W.y+W.h),e.reverseX?g[0]=x[0]-(W.x+W.w):g[0]=x[0]-W.x;break}case"bottom":{const x=[T.x,T.y];e.reverseY?g[1]=x[1]-(W.y+W.h):g[1]=x[1]-W.y;break}case"bottomLeft":{const x=[T.x+T.w,T.y];e.reverseY?g[1]=x[1]-(W.y+W.h):g[1]=x[1]-W.y,e.reverseX?g[0]=x[0]-W.x:g[0]=x[0]-(W.x+W.w);break}case"bottomRight":{const x=[T.x,T.y];e.reverseY?g[1]=x[1]-(W.y+W.h):g[1]=x[1]-W.y,e.reverseX?g[0]=x[0]-(W.x+W.w):g[0]=x[0]-W.x;break}case"right":{const x=[T.x,T.y];e.reverseX?g[0]=x[0]-(W.x+W.w):g[0]=x[0]-W.x;break}}if(g[0]||g[1])return W.x=W.x+g[0],W.y=W.y+g[1],await this.updateSelector({...t,offset:g})}this.getSelecteorInfo(d),this.draw(et.selectorId,c,{selectIds:o||[],subNodeMap:d,intersectRect:W});const M=E(this.oldSelectRect,W);return this.oldSelectRect=W,{type:f.Select,dataType:b.Local,selectRect:W,renderRect:h,rect:E(M,W)}}blurSelector(){const t=this.unSelectedAllIds();return{type:f.Select,dataType:b.Local,rect:t,selectIds:[],willSyncService:!0}}getRightServiceId(t){return t.replace(kt,"-")}selectServiceNode(t,e,o){const{selectIds:s}=e,r=this.getRightServiceId(t),i=this.getSelectorRect(this.fullLayer,r);let n;const a=new Map;return s==null||s.forEach(l=>{const c=this.vNodes.get(l);c&&(n=E(n,c.rect),a.set(l,c))}),this.getSelecteorInfo(a),this.draw(r,this.fullLayer,{intersectRect:n,selectIds:s||[],subNodeMap:a},o),E(n,i)}reRenderSelector(){var t;let e;const o=new Map;return(t=this.selectIds)==null||t.forEach(s=>{const r=this.vNodes.get(s);r&&(e=E(e,r.rect),o.set(s,r))},this),this.getSelecteorInfo(o),this.draw(et.selectorId,this.fullLayer,{intersectRect:e,subNodeMap:o,selectIds:this.selectIds||[]}),this.oldSelectRect=e,e}updateSelectIds(t){var e;let o;const s=(e=this.selectIds)==null?void 0:e.filter(i=>!t.includes(i));if(s!=null&&s.length&&(o=this.unSelectedByIds(s)),t.length){const i=this.selectedByIds(t);o=E(o,i)}this.selectIds=t;const r=this.reRenderSelector();return{bgRect:o,selectRect:r}}cursorHover(t){var e,o;const s=this.oldSelectRect;this.selectIds=[];const r=(e=this.workId)==null?void 0:e.toString(),i=[t[0]*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],t[1]*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[1]];if(this.selectSingleTool(i,r,!0),this.oldSelectRect&&!nt(s,this.oldSelectRect))return{type:f.CursorHover,dataType:b.Local,rect:E(s,this.oldSelectRect),selectorColor:this.selectorColor,willSyncService:!1};if((o=this.selectIds)!=null&&o.length||(this.oldSelectRect=void 0),s&&!this.oldSelectRect)return this.cursorBlur(),{type:f.CursorHover,dataType:b.Local,rect:s,selectorColor:this.selectorColor,willSyncService:!1}}cursorBlur(){var t,e;this.selectIds=[];const o=(t=this.workId)==null?void 0:t.toString();((e=this.fullLayer)==null?void 0:e.parent).children.forEach(s=>{s.name===o&&s.remove()})}};w(mt,"selectorId",Y),w(mt,"selectorBorderId","selector-border");let H=mt;class Rt extends N{constructor(t){super(t),w(this,"canRotate",!1),w(this,"scaleType",U.both),w(this,"toolsType",v.Arrow),w(this,"tmpPoints",[]),w(this,"workOptions"),w(this,"oldRect"),w(this,"arrowTipWidth"),w(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.arrowTipWidth=this.workOptions.thickness*4,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:r,isMainThread:i}=t,n=(e=o==null?void 0:o.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a,workState:l}=o,c=a==null?void 0:a.length;if(!c||c<2)return{type:f.None};let h;if(l===D.Start?(this.tmpPoints=[new O(a[0],a[1])],h=!1):h=this.updateTempPoints(a),!h)return{type:f.None};let d;if(r||i){const y=s?this.fullLayer:this.drawLayer||this.fullLayer;d=this.draw({workId:n,layer:y})}if(!r){const y=Date.now();return y-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=y,{type:f.DrawWork,dataType:b.Local,workId:n,op:this.tmpPoints.map(u=>[...u.XY,0]).flat(1),isSync:!0,index:0}):{type:f.None}}const p=E(d,this.oldRect);return this.oldRect=d,{rect:p,type:f.DrawWork,dataType:b.Local,workId:n}}consumeAll(t){var e,o;const{data:s}=t,r=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!r)return{type:f.None};if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[r]};const i=this.fullLayer,n=this.draw({workId:r,layer:i});this.oldRect=n;const a=this.tmpPoints.map(c=>[...c.XY,0]).flat(1),l=G(a);return(o=this.vNodes)==null||o.setInfo(r,{rect:n,op:a,opt:this.workOptions,toolsType:this.toolsType,canRotate:this.canRotate,scaleType:this.scaleType,centerPos:N.getCenterPos(n,i)}),{rect:n,type:f.FullWork,dataType:b.Local,workId:r,ops:l,isSync:!0,opt:this.workOptions}}draw(t){const{workId:e,layer:o}=t,{strokeColor:s,thickness:r,zIndex:i,scale:n,rotate:a,translate:l}=this.workOptions,c=o.worldPosition,h=o.worldScaling,{points:d,rect:p}=this.computDrawPoints(r),y={pos:[p.x+p.w/2,p.y+p.h/2],name:e,id:e,close:!0,points:d,fillColor:s,strokeColor:s,lineWidth:0,normalize:!0,zIndex:i};n&&(y.scale=n),a&&(y.rotate=a),l&&(y.translate=l);const u=new ot(y);if(this.replace(o,e,u),n||a||l){const m=u.getBoundingClientRect();return{x:Math.floor(m.x-N.SafeBorderPadding),y:Math.floor(m.y-N.SafeBorderPadding),w:Math.floor(m.width+N.SafeBorderPadding*2),h:Math.floor(m.height+N.SafeBorderPadding*2)}}return{x:Math.floor(p.x*h[0]+c[0]-N.SafeBorderPadding),y:Math.floor(p.y*h[1]+c[1]-N.SafeBorderPadding),w:Math.floor(p.w*h[0]+2*N.SafeBorderPadding),h:Math.floor(p.h*h[1]+2*N.SafeBorderPadding)}}computDrawPoints(t){return this.tmpPoints[1].distance(this.tmpPoints[0])>this.arrowTipWidth?this.computFullArrowPoints(t):this.computTrianglePoints()}computFullArrowPoints(t){const e=k.Sub(this.tmpPoints[1],this.tmpPoints[0]).uni(),o=k.Per(e).mul(t/2),s=O.Sub(this.tmpPoints[0],o),r=O.Add(this.tmpPoints[0],o),i=k.Mul(e,this.arrowTipWidth),n=k.Sub(this.tmpPoints[1],i),a=O.Sub(n,o),l=O.Add(n,o),c=k.Per(e).mul(t*1.5),h=O.Sub(n,c),d=O.Add(n,c),p=[s,a,h,this.tmpPoints[1],d,l,r];return{points:p.map(y=>O.Sub(y,this.tmpPoints[0]).XY).flat(1),rect:B(p),isTriangle:!1,pos:this.tmpPoints[0].XY}}computTrianglePoints(){const t=k.Sub(this.tmpPoints[1],this.tmpPoints[0]).uni(),e=this.tmpPoints[1].distance(this.tmpPoints[0]),o=k.Per(t).mul(Math.floor(e*3/8)),s=O.Sub(this.tmpPoints[0],o),r=O.Add(this.tmpPoints[0],o),i=[s,this.tmpPoints[1],r];return{points:i.map(n=>O.Sub(n,this.tmpPoints[0]).XY).flat(1),rect:B(i),isTriangle:!0,pos:this.tmpPoints[0].XY}}updateTempPoints(t){const e=t.slice(-2),o=new O(e[0],e[1]),s=this.tmpPoints[0],{thickness:r}=this.workOptions;if(s.isNear(o,r))return!1;if(this.tmpPoints.length===2){if(o.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=o}else this.tmpPoints.push(o);return!0}consumeService(t){var e,o;const{op:s,isFullWork:r}=t,i=(e=this.workId)==null?void 0:e.toString();if(!i)return;this.tmpPoints.length=0;for(let l=0;l<s.length;l+=3)this.tmpPoints.push(new O(s[l],s[l+1],s[l+2]));const n=r?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:i,layer:n});return this.oldRect=a,(o=this.vNodes)==null||o.setInfo(i,{rect:a,op:s,opt:this.workOptions,toolsType:this.toolsType,canRotate:this.canRotate,scaleType:this.scaleType,centerPos:N.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){var e;const{node:o,opt:s,vNodes:r}=t,{strokeColor:i}=s,n=r.get(o.name);return i&&(o.setAttribute("strokeColor",i),o.setAttribute("fillColor",i),(e=n==null?void 0:n.opt)!=null&&e.strokeColor&&(n.opt.strokeColor=i),n&&r.setInfo(o.name,n)),N.updateNodeOpt(t)}}class Ot extends N{constructor(t){super(t),w(this,"canRotate",!1),w(this,"scaleType",U.all),w(this,"toolsType",v.Ellipse),w(this,"tmpPoints",[]),w(this,"workOptions"),w(this,"oldRect"),w(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:r,isMainThread:i}=t,n=(e=o==null?void 0:o.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a,workState:l}=o,c=a==null?void 0:a.length;if(!c||c<2)return{type:f.None};let h;if(l===D.Start?(this.tmpPoints=[new O(a[0],a[1])],h=!1):h=this.updateTempPoints(a),!h)return{type:f.None};let d;if(r||i){const y=s?this.fullLayer:this.drawLayer||this.fullLayer;d=this.draw({workId:n,layer:y,isDrawing:!0})}if(!r){const y=Date.now();return y-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=y,{type:f.DrawWork,dataType:b.Local,workId:n,op:this.tmpPoints.map(u=>[...u.XY,0]).flat(1),isSync:!0,index:0}):{type:f.None}}const p=E(d,this.oldRect);return this.oldRect=d,{rect:p,type:f.DrawWork,dataType:b.Local,workId:n}}consumeAll(t){var e,o;const{data:s}=t,r=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!r)return{type:f.None};if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[r]};const i=this.fullLayer,n=this.draw({workId:r,layer:i,isDrawing:!1});this.oldRect=n;const a=this.tmpPoints.map(c=>[...c.XY,0]).flat(1),l=G(a);return(o=this.vNodes)==null||o.setInfo(r,{rect:n,op:a,opt:this.workOptions,toolsType:this.toolsType,canRotate:this.canRotate,scaleType:this.scaleType,centerPos:n&&N.getCenterPos(n,i)}),{rect:n,type:f.FullWork,dataType:b.Local,workId:r,ops:l,isSync:!0,opt:this.workOptions}}draw(t){const{workId:e,layer:o,isDrawing:s}=t,{strokeColor:r,fillColor:i,thickness:n,zIndex:a,scale:l,rotate:c,translate:h}=this.workOptions,d=o.worldScaling,{radius:p,rect:y,pos:u}=this.computDrawPoints(n),m={pos:u,name:e,id:e,radius:p,lineWidth:n,fillColor:i!=="transparent"&&i||void 0,strokeColor:r,normalize:!0},P={name:e,id:e,zIndex:a,pos:u,anchor:[.5,.5],size:[y.w,y.h]};l&&(P.scale=l),c&&(P.rotate=c),h&&(P.translate=h);const L=new J(P);if(s){const T=new st({d:"M-4,0H4M0,-4V4",normalize:!0,pos:[0,0],strokeColor:r,lineWidth:1,scale:[1/d[0],1/d[1]]});L.append(T)}const I=new jt({...m,pos:[0,0]});L.append(I),this.replace(o,e,L);const S=L.getBoundingClientRect();return{x:Math.floor(S.x-N.SafeBorderPadding),y:Math.floor(S.y-N.SafeBorderPadding),w:Math.floor(S.width+N.SafeBorderPadding*2),h:Math.floor(S.height+N.SafeBorderPadding*2)}}computDrawPoints(t){const e=B(this.tmpPoints),o=B(this.tmpPoints,t),s=[Math.floor(e.x+e.w/2),Math.floor(e.y+e.h/2)];return{rect:o,pos:s,radius:[Math.floor(e.w/2),Math.floor(e.h/2)]}}updateTempPoints(t){const e=t.slice(-2),o=new O(e[0],e[1]),s=this.tmpPoints[0],{thickness:r}=this.workOptions;if(s.isNear(o,r))return!1;if(this.tmpPoints.length===2){if(o.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=o}else this.tmpPoints.push(o);return!0}consumeService(t){var e,o;const{op:s,isFullWork:r}=t,i=(e=this.workId)==null?void 0:e.toString();if(!i)return;this.tmpPoints.length=0;for(let l=0;l<s.length;l+=3)this.tmpPoints.push(new O(s[l],s[l+1],s[l+2]));const n=r?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:i,layer:n,isDrawing:!1});return this.oldRect=a,(o=this.vNodes)==null||o.setInfo(i,{rect:a,op:s,opt:this.workOptions,toolsType:this.toolsType,canRotate:this.canRotate,scaleType:this.scaleType,centerPos:N.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){var e,o;const{node:s,opt:r,vNodes:i}=t,{strokeColor:n,fillColor:a}=r,l=i.get(s.name);let c=s;return s.tagName==="GROUP"&&(c=s.children[0]),n&&(c.setAttribute("strokeColor",n),(e=l==null?void 0:l.opt)!=null&&e.strokeColor&&(l.opt.strokeColor=n)),a&&(a==="transparent"?c.setAttribute("fillColor","rgba(0,0,0,0)"):c.setAttribute("fillColor",a),(o=l==null?void 0:l.opt)!=null&&o.fillColor&&(l.opt.fillColor=a)),l&&i.setInfo(s.name,l),N.updateNodeOpt(t)}}class Ct extends N{constructor(t){super(t),w(this,"canRotate",!0),w(this,"scaleType",U.all),w(this,"toolsType",v.Rectangle),w(this,"tmpPoints",[]),w(this,"workOptions"),w(this,"oldRect"),w(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}transformData(){const t=B(this.tmpPoints);return[[t.x,t.y,0],[t.x+t.w,t.y,0],[t.x+t.w,t.y+t.h,0],[t.x,t.y+t.h,0]]}computDrawPoints(t){const{thickness:e}=this.workOptions,o=[];for(const i of t)o.push(new k(...i));const s=B(o,e),r=[s.x+s.w/2,s.y+s.h/2];return{rect:s,pos:r,points:o.map(i=>i.XY).flat(1)}}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:r,isMainThread:i}=t,n=(e=o==null?void 0:o.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a,workState:l}=o,c=a==null?void 0:a.length;if(!c||c<2)return{type:f.None};let h;if(l===D.Start?(this.tmpPoints=[new O(a[0],a[1])],h=!1):h=this.updateTempPoints(a),!h)return{type:f.None};const d=this.transformData();let p;if(r||i){const u=s?this.fullLayer:this.drawLayer||this.fullLayer;p=this.draw({ps:d,workId:n,layer:u,isDrawing:!0})}if(!r){const u=Date.now();return u-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=u,{type:f.DrawWork,dataType:b.Local,workId:n,op:d.flat(1),isSync:!0,index:0}):{type:f.None}}const y=E(p,this.oldRect);return this.oldRect=p,{rect:y,type:f.DrawWork,dataType:b.Local,workId:n}}consumeAll(t){var e,o;const{data:s}=t,r=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!r)return{type:f.None};if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[r]};const i=this.transformData(),n=this.fullLayer,a=this.draw({ps:i,workId:r,layer:n,isDrawing:!1});this.oldRect=a;const l=i.flat(1),c=G(l);return(o=this.vNodes)==null||o.setInfo(r,{rect:a,op:l,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&N.getCenterPos(a,n)}),{rect:a,type:f.FullWork,dataType:b.Local,workId:r,ops:c,opt:this.workOptions,isSync:!0}}draw(t){const{workId:e,layer:o,isDrawing:s,ps:r,replaceId:i}=t,{strokeColor:n,fillColor:a,thickness:l,zIndex:c,scale:h,rotate:d,translate:p,textOpt:y}=this.workOptions,u=o.worldPosition,m=o.worldScaling,{points:P,rect:L,pos:I}=this.computDrawPoints(r),S={close:!0,normalize:!0,points:P,lineWidth:l,fillColor:a!=="transparent"&&a||void 0,strokeColor:n,lineJoin:"round"},T={x:Math.floor(L.x*m[0]+u[0]-N.SafeBorderPadding),y:Math.floor(L.y*m[1]+u[1]-N.SafeBorderPadding),w:Math.floor(L.w*m[0]+2*N.SafeBorderPadding),h:Math.floor(L.h*m[0]+2*N.SafeBorderPadding)},W=new J({name:e,id:e,zIndex:c,pos:I,anchor:[.5,.5],size:[L.w,L.h],scale:h,rotate:d,translate:p}),M=new ot({...S,pos:[0,0]});if(W.appendChild(M),s){const g=new st({d:"M-4,0H4M0,-4V4",normalize:!0,pos:[0,0],strokeColor:n,lineWidth:1,scale:[1/m[0],1/m[1]]});W.appendChild(g)}if(this.replace(o,i||e,W),h||d||p){const g=W.getBoundingClientRect();return{x:Math.floor(g.x-N.SafeBorderPadding),y:Math.floor(g.y-N.SafeBorderPadding),w:Math.floor(g.width+2*N.SafeBorderPadding),h:Math.floor(g.height+2*N.SafeBorderPadding)}}return T}updateTempPoints(t){const e=t.slice(-2),o=new O(e[0],e[1]),s=this.tmpPoints[0],{thickness:r}=this.workOptions;if(s.isNear(o,r))return!1;if(this.tmpPoints.length===2){if(o.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=o}else this.tmpPoints.push(o);return!0}consumeService(t){var e,o;const{op:s,isFullWork:r,replaceId:i}=t,n=(e=this.workId)==null?void 0:e.toString();if(!n)return;const a=[];for(let h=0;h<s.length;h+=3)a.push([s[h],s[h+1],s[h+2]]);const l=r?this.fullLayer:this.drawLayer||this.fullLayer,c=this.draw({ps:a,workId:n,layer:l,isDrawing:!1,replaceId:i});return this.oldRect=c,(o=this.vNodes)==null||o.setInfo(n,{rect:c,op:s,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:c&&N.getCenterPos(c,l)}),c}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){var e,o;const{node:s,opt:r,vNodes:i}=t,{strokeColor:n,fillColor:a,fontColor:l,fontBgColor:c,bold:h,italic:d,lineThrough:p,underline:y,fontSize:u}=r,m=i.get(s.name);let P=s;if(s.tagName==="GROUP"&&(P=s.children[0]),n&&(P.setAttribute("strokeColor",n),(e=m==null?void 0:m.opt)!=null&&e.strokeColor&&(m.opt.strokeColor=n)),a&&(a==="transparent"?P.setAttribute("fillColor","rgba(0,0,0,0)"):P.setAttribute("fillColor",a),(o=m==null?void 0:m.opt)!=null&&o.fillColor&&(m.opt.fillColor=a)),m!=null&&m.opt.textOpt){const L=m.opt.textOpt;l&&L.fontColor&&(L.fontColor=l),c&&L.fontBgColor&&(L.fontBgColor=c),h&&(L.bold=h),d&&(L.italic=d),tt(p)&&(L.lineThrough=p),tt(y)&&(L.underline=y),u&&(L.fontSize=u)}return m&&i.setInfo(s.name,m),N.updateNodeOpt(t)}}class Mt extends N{constructor(t){super(t),w(this,"canRotate",!1),w(this,"scaleType",U.all),w(this,"toolsType",v.Star),w(this,"tmpPoints",[]),w(this,"workOptions"),w(this,"oldRect"),w(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:r,isMainThread:i}=t,n=(e=o==null?void 0:o.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a,workState:l}=o,c=a==null?void 0:a.length;if(!c||c<2)return{type:f.None};let h;if(l===D.Start?(this.tmpPoints=[new O(a[0],a[1])],h=!1):h=this.updateTempPoints(a),!h)return{type:f.None};let d;if(r||i){const y=s?this.fullLayer:this.drawLayer||this.fullLayer;d=this.draw({workId:n,layer:y,isDrawing:!0})}if(!r){const y=Date.now();return y-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=y,{type:f.DrawWork,dataType:b.Local,workId:n,op:this.tmpPoints.map(u=>[...u.XY,0]).flat(1),isSync:!0,index:0}):{type:f.None}}const p=E(d,this.oldRect);return this.oldRect=d,{rect:p,type:f.DrawWork,dataType:b.Local,workId:n}}consumeAll(t){var e,o;const{data:s}=t,r=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!r)return{type:f.None};if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[r]};const i=this.fullLayer,n=this.draw({workId:r,layer:i,isDrawing:!1});this.oldRect=n;const a=this.tmpPoints.map(c=>[...c.XY,0]).flat(1),l=G(a);return(o=this.vNodes)==null||o.setInfo(r,{rect:n,op:a,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:n&&N.getCenterPos(n,i)}),{rect:n,type:f.FullWork,dataType:b.Local,workId:r,ops:l,isSync:!0,opt:this.workOptions}}draw(t){const{workId:e,layer:o,isDrawing:s}=t,{strokeColor:r,fillColor:i,thickness:n,zIndex:a,vertices:l,innerVerticeStep:c,innerRatio:h,scale:d,rotate:p,translate:y}=this.workOptions,u=o.worldScaling,{rect:m,pos:P,points:L}=this.computDrawPoints(n,l,c,h),I={close:!0,points:L,lineWidth:n,fillColor:i!=="transparent"&&i||void 0,strokeColor:r,normalize:!0,lineJoin:"round"},S={name:e,id:e,zIndex:a,pos:P,anchor:[.5,.5],size:[m.w,m.h],className:`${P[0]},${P[1]}`};d&&(S.scale=d),p&&(S.rotate=p),y&&(S.translate=y);const T=new J(S);if(s){const g=new st({d:"M-4,0H4M0,-4V4",normalize:!0,pos:[0,0],strokeColor:r,lineWidth:1,scale:[1/u[0],1/u[1]]});T.append(g)}const W=new ot({...I,pos:[0,0]});T.append(W),this.replace(o,e,T);const M=T.getBoundingClientRect();return{x:Math.floor(M.x-N.SafeBorderPadding),y:Math.floor(M.y-N.SafeBorderPadding),w:Math.floor(M.width+N.SafeBorderPadding*2),h:Math.floor(M.height+N.SafeBorderPadding*2)}}computDrawPoints(t,e,o,s){const r=B(this.tmpPoints),i=[Math.floor(r.x+r.w/2),Math.floor(r.y+r.h/2)],n=Pt(r.w,r.h),a=Math.floor(Math.min(r.w,r.h)/2),l=s*a,c=[],h=2*Math.PI/e;for(let d=0;d<e;d++){const p=d*h-.5*Math.PI;let y,u;d%o===1?(y=l*n[0]*Math.cos(p),u=l*n[1]*Math.sin(p)):(y=a*n[0]*Math.cos(p),u=a*n[1]*Math.sin(p),c.push(y,u)),c.push(y,u)}return{rect:B(this.tmpPoints,t),pos:i,points:c}}updateTempPoints(t){const e=t.slice(-2),o=new O(e[0],e[1]),s=this.tmpPoints[0],{thickness:r}=this.workOptions;if(s.isNear(o,r)||O.Sub(s,o).XY.includes(0))return!1;if(this.tmpPoints.length===2){if(o.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=o}else this.tmpPoints.push(o);return!0}consumeService(t){var e,o;const{op:s,isFullWork:r}=t,i=(e=this.workId)==null?void 0:e.toString();if(!i)return;this.tmpPoints.length=0;for(let l=0;l<s.length;l+=3)this.tmpPoints.push(new O(s[l],s[l+1],s[l+2]));const n=r?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:i,layer:n,isDrawing:!1});return this.oldRect=a,(o=this.vNodes)==null||o.setInfo(i,{rect:a,op:s,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&N.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){const{node:e,opt:o,vNodes:s}=t,{strokeColor:r,fillColor:i,toolsType:n,vertices:a,innerVerticeStep:l,innerRatio:c}=o,h=s.get(e.name),d=h==null?void 0:h.opt;let p=e;return e.tagName==="GROUP"&&(p=e.children[0]),r&&(p.setAttribute("strokeColor",r),d!=null&&d.strokeColor&&(d.strokeColor=r)),i&&(i==="transparent"?p.setAttribute("fillColor","rgba(0,0,0,0)"):p.setAttribute("fillColor",i),d!=null&&d.fillColor&&(d.fillColor=i)),n===v.Star&&(a&&(d.vertices=a),l&&(d.innerVerticeStep=l),c&&(d.innerRatio=c)),h&&s.setInfo(e.name,{...h,opt:d}),N.updateNodeOpt(t)}}class Dt extends N{constructor(t){super(t),w(this,"canRotate",!1),w(this,"scaleType",U.all),w(this,"toolsType",v.Polygon),w(this,"tmpPoints",[]),w(this,"workOptions"),w(this,"oldRect"),w(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:r,isMainThread:i}=t,n=(e=o==null?void 0:o.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a,workState:l}=o,c=a==null?void 0:a.length;if(!c||c<2)return{type:f.None};let h;if(l===D.Start?(this.tmpPoints=[new O(a[0],a[1])],h=!1):h=this.updateTempPoints(a),!h)return{type:f.None};let d;if(r||i){const y=s?this.fullLayer:this.drawLayer||this.fullLayer;d=this.draw({workId:n,layer:y,isDrawing:!0})}if(!r){const y=Date.now();return y-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=y,{type:f.DrawWork,dataType:b.Local,workId:n,op:this.tmpPoints.map(u=>[...u.XY,0]).flat(1),isSync:!0,index:0}):{type:f.None}}const p=E(d,this.oldRect);return this.oldRect=d,{rect:p,type:f.DrawWork,dataType:b.Local,workId:n}}consumeAll(t){var e,o;const{data:s}=t,r=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!r)return{type:f.None};if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[r]};const i=this.fullLayer,n=this.draw({workId:r,layer:i,isDrawing:!1});this.oldRect=n;const a=this.tmpPoints.map(c=>[...c.XY,0]).flat(1),l=G(a);return(o=this.vNodes)==null||o.setInfo(r,{rect:n,op:a,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:n&&N.getCenterPos(n,i)}),{rect:n,type:f.FullWork,dataType:b.Local,workId:r,ops:l,isSync:!0,opt:this.workOptions}}draw(t){const{workId:e,layer:o,isDrawing:s}=t,{strokeColor:r,fillColor:i,thickness:n,zIndex:a,vertices:l,scale:c,rotate:h,translate:d}=this.workOptions,p=o.worldScaling,{rect:y,pos:u,points:m}=this.computDrawPoints(n,l),P={close:!0,points:m,lineWidth:n,fillColor:i!=="transparent"&&i||void 0,strokeColor:r,normalize:!0,lineJoin:"round"},L={name:e,id:e,zIndex:a,pos:u,anchor:[.5,.5],size:[y.w,y.h]};c&&(L.scale=c),h&&(L.rotate=h),d&&(L.translate=d);const I=new J(L);if(s){const W=new st({d:"M-4,0H4M0,-4V4",normalize:!0,pos:[0,0],strokeColor:r,lineWidth:1,scale:[1/p[0],1/p[1]]});I.append(W)}const S=new ot({...P,pos:[0,0]});I.append(S),this.replace(o,e,I);const T=I.getBoundingClientRect();return{x:Math.floor(T.x-N.SafeBorderPadding),y:Math.floor(T.y-N.SafeBorderPadding),w:Math.floor(T.width+N.SafeBorderPadding*2),h:Math.floor(T.height+N.SafeBorderPadding*2)}}computDrawPoints(t,e){const o=B(this.tmpPoints),s=[Math.floor(o.x+o.w/2),Math.floor(o.y+o.h/2)],r=Pt(o.w,o.h),i=Math.floor(Math.min(o.w,o.h)/2),n=[],a=2*Math.PI/e;for(let l=0;l<e;l++){const c=l*a-.5*Math.PI,h=i*r[0]*Math.cos(c),d=i*r[1]*Math.sin(c);n.push(h,d)}return{rect:B(this.tmpPoints,t),pos:s,points:n}}updateTempPoints(t){const e=t.slice(-2),o=new O(e[0],e[1]),s=this.tmpPoints[0],{thickness:r}=this.workOptions;if(s.isNear(o,r)||O.Sub(s,o).XY.includes(0))return!1;if(this.tmpPoints.length===2){if(o.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=o}else this.tmpPoints.push(o);return!0}consumeService(t){var e,o;const{op:s,isFullWork:r}=t,i=(e=this.workId)==null?void 0:e.toString();if(!i)return;this.tmpPoints.length=0;for(let l=0;l<s.length;l+=3)this.tmpPoints.push(new O(s[l],s[l+1],s[l+2]));const n=r?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:i,layer:n,isDrawing:!1});return this.oldRect=a,(o=this.vNodes)==null||o.setInfo(i,{rect:a,op:s,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&N.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){const{node:e,opt:o,vNodes:s}=t,{strokeColor:r,fillColor:i,toolsType:n,vertices:a}=o,l=s.get(e.name),c=l==null?void 0:l.opt;let h=e;return e.tagName==="GROUP"&&(h=e.children[0]),r&&(h.setAttribute("strokeColor",r),c!=null&&c.strokeColor&&(c.strokeColor=r)),i&&(i==="transparent"?h.setAttribute("fillColor","rgba(0,0,0,0)"):h.setAttribute("fillColor",i),c!=null&&c.fillColor&&(c.fillColor=i)),n===v.Polygon&&a&&(c.vertices=a),l&&s.setInfo(e.name,{...l,opt:c}),N.updateNodeOpt(t)}}class V{static bezier(t,e){const o=[];for(let s=0;s<e.length;s+=4){const r=e[s],i=e[s+1],n=e[s+2],a=e[s+3];r&&i&&n&&a?o.push(...V.getBezierPoints(t,r,i,n,a)):r&&i&&n?o.push(...V.getBezierPoints(t,r,i,n)):r&&i?o.push(...V.getBezierPoints(t,r,i)):r&&o.push(r)}return o}static getBezierPoints(t=10,e,o,s,r){let i=null;const n=[];!s&&!r?i=V.oneBezier:s&&!r?i=V.twoBezier:s&&r&&(i=V.threeBezier);for(let a=0;a<t;a++)i&&n.push(i(a/t,e,o,s,r));return r?n.push(r):s&&n.push(s),n}static oneBezier(t,e,o){const s=e.x+(o.x-e.x)*t,r=e.y+(o.y-e.y)*t;return new k(s,r)}static twoBezier(t,e,o,s){const r=(1-t)*(1-t)*e.x+2*t*(1-t)*o.x+t*t*s.x,i=(1-t)*(1-t)*e.y+2*t*(1-t)*o.y+t*t*s.y;return new k(r,i)}static threeBezier(t,e,o,s,r){const i=e.x*(1-t)*(1-t)*(1-t)+3*o.x*t*(1-t)*(1-t)+3*s.x*t*t*(1-t)+r.x*t*t*t,n=e.y*(1-t)*(1-t)*(1-t)+3*o.y*t*(1-t)*(1-t)+3*s.y*t*t*(1-t)+r.y*t*t*t;return new k(i,n)}}class At extends N{constructor(t){super(t),w(this,"canRotate",!1),w(this,"scaleType",U.all),w(this,"toolsType",v.SpeechBalloon),w(this,"ratio",.8),w(this,"tmpPoints",[]),w(this,"workOptions"),w(this,"oldRect"),w(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:r,isMainThread:i}=t,n=(e=o==null?void 0:o.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a,workState:l}=o,c=a==null?void 0:a.length;if(!c||c<2)return{type:f.None};let h;if(l===D.Start?(this.tmpPoints=[new O(a[0],a[1])],h=!1):h=this.updateTempPoints(a),!h)return{type:f.None};let d;if(r||i){const y=s?this.fullLayer:this.drawLayer||this.fullLayer;d=this.draw({workId:n,layer:y,isDrawing:!0})}if(!r){const y=Date.now();return y-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=y,{type:f.DrawWork,dataType:b.Local,workId:n,op:this.tmpPoints.map(u=>[...u.XY,0]).flat(1),isSync:!0,index:0}):{type:f.None}}const p=E(d,this.oldRect);return this.oldRect=d,{rect:p,type:f.DrawWork,dataType:b.Local,workId:n}}consumeAll(t){var e,o;const{data:s}=t,r=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!r)return{type:f.None};if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[r]};const i=this.fullLayer,n=this.draw({workId:r,layer:i,isDrawing:!1});this.oldRect=n;const a=this.tmpPoints.map(c=>[...c.XY,0]).flat(1),l=G(a);return(o=this.vNodes)==null||o.setInfo(r,{rect:n,op:a,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:n&&N.getCenterPos(n,i)}),{rect:n,type:f.FullWork,dataType:b.Local,workId:r,ops:l,isSync:!0,opt:this.workOptions}}draw(t){const{workId:e,layer:o}=t,{strokeColor:s,fillColor:r,thickness:i,zIndex:n,placement:a,scale:l,rotate:c,translate:h}=this.workOptions,{rect:d,pos:p,points:y}=this.computDrawPoints(i,a),u={points:y.map(S=>S.XY),lineWidth:i,fillColor:r!=="transparent"&&r||void 0,strokeColor:s,normalize:!0,className:`${p[0]},${p[1]}`,lineJoin:"round",close:!0},m={name:e,id:e,zIndex:n,pos:p,anchor:[.5,.5],size:[d.w,d.h]};l&&(m.scale=l),c&&(m.rotate=c),h&&(m.translate=h);const P=new J(m),L=new ot({...u,pos:[0,0]});P.append(L),this.replace(o,e,P);const I=P.getBoundingClientRect();return{x:Math.floor(I.x-N.SafeBorderPadding),y:Math.floor(I.y-N.SafeBorderPadding),w:Math.floor(I.width+N.SafeBorderPadding*2),h:Math.floor(I.height+N.SafeBorderPadding*2)}}transformControlPoints(t){const e=B(this.tmpPoints);switch(t){case"bottom":case"bottomLeft":case"bottomRight":{const o=e.y+e.h*this.ratio;return[new k(e.x,e.y,0),new k(e.x+e.w,e.y,0),new k(e.x+e.w,o,0),new k(e.x,o,0)]}case"top":case"topLeft":case"topRight":{const o=e.y+e.h*(1-this.ratio);return[new k(e.x,o,0),new k(e.x+e.w,o,0),new k(e.x+e.w,e.y+e.h,0),new k(e.x,e.y+e.h,0)]}case"left":case"leftBottom":case"leftTop":{const o=e.x+e.w*(1-this.ratio);return[new k(o,e.y,0),new k(e.x+e.w,e.y,0),new k(e.x+e.w,e.y+e.h,0),new k(o,e.y+e.h,0)]}case"right":case"rightBottom":case"rightTop":{const o=e.x+e.w*this.ratio;return[new k(e.x,e.y,0),new k(o,e.y,0),new k(o,e.y+e.h,0),new k(e.x,e.y+e.h,0)]}}}computDrawPoints(t,e){const o=B(this.tmpPoints),s=this.transformControlPoints(e),r=Math.floor(o.w*.1),i=Math.floor(o.h*.1),n=[],a=k.Add(s[0],new k(0,i,0)),l=k.Add(s[0],new k(r,0,0)),c=V.getBezierPoints(10,a,s[0],l),h=k.Sub(s[1],new k(r,0,0)),d=k.Add(s[1],new k(0,i,0)),p=V.getBezierPoints(10,h,s[1],d),y=k.Sub(s[2],new k(0,i,0)),u=k.Sub(s[2],new k(r,0,0)),m=V.getBezierPoints(10,y,s[2],u),P=k.Add(s[3],new k(r,0,0)),L=k.Sub(s[3],new k(0,i,0)),I=V.getBezierPoints(10,P,s[3],L),S=r*(1-this.ratio)*10,T=i*(1-this.ratio)*10;switch(e){case"bottom":{const g=k.Sub(s[2],new k(r*5-S/2,0,0)),x=k.Sub(s[2],new k(r*5,-T,0)),C=k.Sub(s[2],new k(r*5+S/2,0,0));n.push(x,C,...I,...c,...p,...m,g);break}case"bottomRight":{const g=k.Sub(s[2],new k(r*1.1,0,0)),x=k.Sub(s[2],new k(r*1.1+S/2,-T,0)),C=k.Sub(s[2],new k(r*1.1+S,0,0));n.push(x,C,...I,...c,...p,...m,g);break}case"bottomLeft":{const g=k.Add(s[3],new k(r*1.1+S,0,0)),x=k.Add(s[3],new k(r*1.1+S/2,T,0)),C=k.Add(s[3],new k(r*1.1,0,0));n.push(x,C,...I,...c,...p,...m,g);break}case"top":{const g=k.Sub(s[1],new k(r*5-S/2,0,0)),x=k.Sub(s[1],new k(r*5,T,0)),C=k.Sub(s[1],new k(r*5+S/2,0,0));n.push(x,g,...p,...m,...I,...c,C);break}case"topRight":{const g=k.Sub(s[1],new k(r*1.1,0,0)),x=k.Sub(s[1],new k(r*1.1+S/2,T,0)),C=k.Sub(s[1],new k(r*1.1+S,0,0));n.push(x,g,...p,...m,...I,...c,C);break}case"topLeft":{const g=k.Add(s[0],new k(r*1.1+S,0,0)),x=k.Add(s[0],new k(r*1.1+S/2,-T,0)),C=k.Add(s[0],new k(r*1.1,0,0));n.push(x,g,...p,...m,...I,...c,C);break}case"left":{const g=k.Add(s[0],new k(0,i*5-T/2,0)),x=k.Add(s[0],new k(-S,i*5,0)),C=k.Add(s[0],new k(0,i*5+T/2,0));n.push(x,g,...c,...p,...m,...I,C);break}case"leftTop":{const g=k.Add(s[0],new k(0,i*1.1,0)),x=k.Add(s[0],new k(-S,i*1.1+T/2,0)),C=k.Add(s[0],new k(0,i*1.1+T,0));n.push(x,g,...c,...p,...m,...I,C);break}case"leftBottom":{const g=k.Sub(s[3],new k(0,i*1.1+T,0)),x=k.Sub(s[3],new k(S,i*1.1+T/2,0)),C=k.Sub(s[3],new k(0,i*1.1,0));n.push(x,g,...c,...p,...m,...I,C);break}case"right":{const g=k.Add(s[1],new k(0,i*5-T/2,0)),x=k.Add(s[1],new k(S,i*5,0)),C=k.Add(s[1],new k(0,i*5+T/2,0));n.push(x,C,...m,...I,...c,...p,g);break}case"rightTop":{const g=k.Add(s[1],new k(0,i*1.1,0)),x=k.Add(s[1],new k(S,i*1.1+T/2,0)),C=k.Add(s[1],new k(0,i*1.1+T,0));n.push(x,C,...m,...I,...c,...p,g);break}case"rightBottom":{const g=k.Sub(s[2],new k(0,i*1.1+T,0)),x=k.Sub(s[2],new k(-S,i*1.1+T/2,0)),C=k.Sub(s[2],new k(0,i*1.1,0));n.push(x,C,...m,...I,...c,...p,g);break}}const W=B(this.tmpPoints,t),M=[Math.floor(W.x+W.w/2),Math.floor(W.y+W.h/2)];return{rect:W,pos:M,points:n}}updateTempPoints(t){const e=t.slice(-2),o=new O(e[0],e[1]),s=this.tmpPoints[0],{thickness:r}=this.workOptions;if(s.isNear(o,r)||O.Sub(s,o).XY.includes(0))return!1;if(this.tmpPoints.length===2){if(o.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=o}else this.tmpPoints.push(o);return!0}consumeService(t){var e,o;const{op:s,isFullWork:r}=t,i=(e=this.workId)==null?void 0:e.toString();if(!i)return;this.tmpPoints.length=0;for(let l=0;l<s.length;l+=3)this.tmpPoints.push(new O(s[l],s[l+1],s[l+2]));const n=r?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:i,layer:n,isDrawing:!1});return this.oldRect=a,(o=this.vNodes)==null||o.setInfo(i,{rect:a,op:s,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&N.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){const{node:e,opt:o,vNodes:s}=t,{strokeColor:r,fillColor:i,toolsType:n,placement:a}=o,l=s.get(e.name),c=l==null?void 0:l.opt;let h=e;return e.tagName==="GROUP"&&(h=e.children[0]),r&&(h.setAttribute("strokeColor",r),c!=null&&c.strokeColor&&(c.strokeColor=r)),i&&(i==="transparent"?h.setAttribute("fillColor","rgba(0,0,0,0)"):h.setAttribute("fillColor",i),c!=null&&c.fillColor&&(c.fillColor=i)),n===v.SpeechBalloon&&a&&(c.placement=a),l&&s.setInfo(e.name,{...l,opt:c}),N.updateNodeOpt(t)}}class pt extends N{constructor(t){super(t),w(this,"canRotate",!0),w(this,"scaleType",U.all),w(this,"toolsType",v.Image),w(this,"tmpPoints",[]),w(this,"workOptions"),w(this,"oldRect"),this.workOptions=t.toolsOpt,this.scaleType=pt.getScaleType(this.workOptions)}consume(){return{type:f.None}}consumeAll(){return{type:f.None}}draw(t){const{layer:e,workId:o,replaceId:s,imageBitmap:r,isMainThread:i}=t,{centerX:n,centerY:a,width:l,height:c,rotate:h,zIndex:d}=this.workOptions,p={anchor:[.5,.5],pos:[n,a],name:o,size:[l,c],zIndex:d,rotate:!i&&180+(h||0)||h,texture:r},y=new Vt(p);this.replace(e,s||o,y);const u=y.getBoundingClientRect();if(u)return{x:Math.floor(u.x-N.SafeBorderPadding),y:Math.floor(u.y-N.SafeBorderPadding),w:Math.floor(u.width+N.SafeBorderPadding*2),h:Math.floor(u.height+N.SafeBorderPadding*2)}}consumeService(){}async consumeServiceAsync(t){var e,o,s,r;const{isFullWork:i,replaceId:n,scene:a,isMainThread:l}=t,{src:c,uuid:h}=this.workOptions,d=((e=this.workId)==null?void 0:e.toString())||h,p=i?this.fullLayer:this.drawLayer||this.fullLayer;if(c){const y=await a.preload({id:h,src:this.workOptions.src}),u=this.draw({workId:d,layer:p,replaceId:n,imageBitmap:y[0],isMainThread:l});return this.oldRect=d&&((s=(o=this.vNodes)==null?void 0:o.get(d))==null?void 0:s.rect)||void 0,(r=this.vNodes)==null||r.setInfo(d,{rect:u,op:[],opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:u&&N.getCenterPos(u,p)}),u}}clearTmpPoints(){this.tmpPoints.length=0}static getScaleType(t){const{uniformScale:e,rotate:o}=t;return e!==!1?U.proportional:o&&Math.abs(o)%90>0?U.proportional:U.all}static updateNodeOpt(t){const{node:e,opt:o,vNodes:s,targetNode:r}=t,{translate:i,box:n,boxScale:a,boxTranslate:l,angle:c,isLocked:h,zIndex:d}=o,p=r&&Z(r)||s.get(e.name);if(!p)return;const y=e.parent;if(y){if(q(d)&&(e.setAttribute("zIndex",d),p.opt.zIndex=d),tt(h)&&(p.opt.locked=h),n&&l&&a){const{centerX:u,centerY:m,width:P,height:L,uniformScale:I,rotate:S}=p.opt,T=Math.min(a[0],a[1]),W=I!==!1?[T,T]:a,M=Gt({x:u-P/2,y:m-L/2,w:P,h:L},S||0),g=Ht(M,new k(u,m),W),x=Kt(g,new k(u,m),-(S||0)),C=B(x);p.opt.width=Math.round(C.w),p.opt.height=Math.round(C.h);const z=[l[0]/y.worldScaling[0],l[1]/y.worldScaling[1]];p.opt.centerX=u+z[0],p.opt.centerY=m+z[1];const F=[p.centerPos[0]+z[0],p.centerPos[1]+z[1]];if(p.centerPos=F,r){let X=It(p.rect,a);X=ht(X,z),p.rect=X}else{const X=N.getRectFromLayer(y,e.name);p.rect=X||p.rect}}else if(i)if(p.opt.centerX=p.opt.centerX+i[0],p.opt.centerY=p.opt.centerY+i[1],p.centerPos=[p.centerPos[0]+i[0],p.centerPos[1]+i[1]],r){const u=[i[0]*y.worldScaling[0],i[1]*y.worldScaling[1]],m=ht(p.rect,u);p.rect=m}else{const u=N.getRectFromLayer(y,e.name);p.rect=u||p.rect}else if(q(c))if(p.opt.rotate=c,p.scaleType=pt.getScaleType(p.opt),r){const u=Tt(p.rect,c);p.rect=u}else{const u=N.getRectFromLayer(y,e.name);p.rect=u||p.rect}return p&&s.setInfo(e.name,p),p==null?void 0:p.rect}}}class Et extends N{constructor(t){super(t),w(this,"canRotate",!1),w(this,"scaleType",U.both),w(this,"toolsType",v.Straight),w(this,"tmpPoints",[]),w(this,"workOptions"),w(this,"oldRect"),w(this,"straightTipWidth"),w(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.straightTipWidth=this.workOptions.thickness/2,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:r,isMainThread:i}=t,n=(e=o==null?void 0:o.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a,workState:l}=o,c=a==null?void 0:a.length;if(!c||c<2)return{type:f.None};let h;if(l===D.Start?(this.tmpPoints=[new O(a[0],a[1])],h=!1):h=this.updateTempPoints(a),!h)return{type:f.None};let d;if(r||i){const y=s?this.fullLayer:this.drawLayer||this.fullLayer;d=this.draw({workId:n,layer:y})}if(!r){const y=Date.now();return y-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=y,{type:f.DrawWork,dataType:b.Local,workId:n,op:this.tmpPoints.map(u=>[...u.XY,0]).flat(1),isSync:!0,index:0}):{type:f.None}}const p=E(d,this.oldRect);return this.oldRect=d,{rect:p,type:f.DrawWork,dataType:b.Local,workId:n}}consumeAll(t){var e,o;const{data:s}=t,r=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!r)return{type:f.None};if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[r]};const i=this.fullLayer,n=this.draw({workId:r,layer:i});this.oldRect=n;const a=this.tmpPoints.map(c=>[...c.XY,0]).flat(1),l=G(a);return(o=this.vNodes)==null||o.setInfo(r,{rect:n,op:a,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:n&&N.getCenterPos(n,i)}),{rect:n,type:f.FullWork,dataType:b.Local,workId:r,ops:l,isSync:!0,opt:this.workOptions}}draw(t){const{workId:e,layer:o}=t,{strokeColor:s,thickness:r,zIndex:i,scale:n,rotate:a,translate:l}=this.workOptions,c=o.worldPosition,h=o.worldScaling,{d,rect:p}=this.computDrawPoints(r),y=[p.x+p.w/2,p.y+p.h/2],u={pos:y,name:e,id:e,d,fillColor:s,strokeColor:s,lineWidth:0,className:`${y[0]},${y[1]}`,normalize:!0,zIndex:i};n&&(u.scale=n),a&&(u.rotate=a),l&&(u.translate=l);const m=new st(u);if(this.replace(o,e,m),a||n||l){const P=m.getBoundingClientRect();return{x:Math.floor(P.x-N.SafeBorderPadding),y:Math.floor(P.y-N.SafeBorderPadding),w:Math.floor(P.width+N.SafeBorderPadding*2),h:Math.floor(P.height+N.SafeBorderPadding*2)}}return{x:Math.floor(p.x*h[0]+c[0]-N.SafeBorderPadding),y:Math.floor(p.y*h[1]+c[1]-N.SafeBorderPadding),w:Math.floor(p.w*h[0]+2*N.SafeBorderPadding),h:Math.floor(p.h*h[1]+2*N.SafeBorderPadding)}}computDrawPoints(t){return this.tmpPoints[1].distance(this.tmpPoints[0])>this.straightTipWidth?this.computFullPoints(t):this.computDotPoints(t)}computFullPoints(t){const e=k.Sub(this.tmpPoints[1],this.tmpPoints[0]).uni(),o=k.Per(e).mul(t/2),s=O.Sub(this.tmpPoints[0],o),r=O.Add(this.tmpPoints[0],o),i=O.Sub(this.tmpPoints[1],o),n=O.Add(this.tmpPoints[1],o),a=O.GetSemicircleStroke(this.tmpPoints[1],i,-1,8),l=O.GetSemicircleStroke(this.tmpPoints[0],r,-1,8),c=[s,i,...a,n,r,...l];return{d:at(c,!0),rect:B(c),isDot:!1,pos:this.tmpPoints[0].XY}}computDotPoints(t){const e=O.GetDotStroke(this.tmpPoints[0],t/2,8);return{d:at(e,!0),rect:B(e),isDot:!0,pos:this.tmpPoints[0].XY}}updateTempPoints(t){const e=t.slice(-2),o=new O(e[0],e[1]),s=this.tmpPoints[0],{thickness:r}=this.workOptions;if(s.isNear(o,r))return!1;if(this.tmpPoints.length===2){if(o.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=o}else this.tmpPoints.push(o);return!0}consumeService(t){var e,o;const{op:s,isFullWork:r}=t,i=(e=this.workId)==null?void 0:e.toString();if(!i)return;this.tmpPoints.length=0;for(let l=0;l<s.length;l+=3)this.tmpPoints.push(new O(s[l],s[l+1],s[l+2]));const n=r?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:i,layer:n});return this.oldRect=a,(o=this.vNodes)==null||o.setInfo(i,{rect:a,op:s,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&N.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){var e;const{node:o,opt:s,vNodes:r}=t,{strokeColor:i}=s,n=r.get(o.name);return i&&(o.setAttribute("strokeColor",i),o.setAttribute("fillColor",i),(e=n==null?void 0:n.opt)!=null&&e.strokeColor&&(n.opt.strokeColor=i)),n&&r.setInfo(o.name,n),N.updateNodeOpt(t)}}class wt extends N{constructor(t){super(t),w(this,"canRotate",!1),w(this,"scaleType",U.all),w(this,"toolsType",v.Text),w(this,"tmpPoints",[]),w(this,"workOptions"),w(this,"oldRect"),this.workOptions=t.toolsOpt}consume(){return{type:f.None}}consumeAll(){return{type:f.None}}consumeService(){}async draw(t){const{workId:e,layer:o,isDrawLabel:s}=t,{boxSize:r,boxPoint:i,zIndex:n}=this.workOptions,a=o.worldPosition,l=o.worldScaling;if(!i||!r)return;const c={name:e,id:e,pos:[i[0]+r[0]/2,i[1]+r[1]/2],anchor:[.5,.5],size:r,zIndex:n},h=new J(c),d={x:i[0],y:i[1],w:r[0],h:r[1]},p=new ft({normalize:!0,pos:[0,0],size:r});if(h.append(p),s){const y=s&&await wt.createLabels(this.workOptions,h)||[];h.append(...y)}return this.replace(o,e,h),{x:Math.floor(d.x*l[0]+a[0]),y:Math.floor(d.y*l[1]+a[1]),w:Math.floor(d.w*l[0]),h:Math.floor(d.h*l[1])}}async consumeServiceAsync(t){var e,o,s,r;const i=(e=this.workId)==null?void 0:e.toString();if(!i)return;const{isFullWork:n,replaceId:a,isDrawLabel:l}=t;this.oldRect=a&&((s=(o=this.vNodes)==null?void 0:o.get(a))==null?void 0:s.rect)||void 0;const c=n?this.fullLayer:this.drawLayer||this.fullLayer,h=await this.draw({workId:i,layer:c,isDrawLabel:l||this.workOptions.workState===D.Done});return(r=this.vNodes)==null||r.setInfo(i,{rect:h,op:[],opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:h&&N.getCenterPos(h,c)}),h}updataOptService(){}async updataOptServiceAsync(t){var e,o;if(!this.workId)return;const s=this.workId.toString(),{fontColor:r,fontBgColor:i,bold:n,italic:a,lineThrough:l,underline:c,zIndex:h}=t,d=(e=this.vNodes)==null?void 0:e.get(s);if(!d)return;r&&(d.opt.fontColor=r),i&&(d.opt.fontBgColor=i),n&&(d.opt.bold=n),a&&(d.opt.italic=a),tt(l)&&(d.opt.lineThrough=l),tt(c)&&(d.opt.underline=c),q(h)&&(d.opt.zIndex=h),this.oldRect=d.rect;const p=await this.draw({workId:s,layer:this.fullLayer,isDrawLabel:this.workOptions.workState===D.Done});return(o=this.vNodes)==null||o.setInfo(s,{rect:p,op:[],opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:p&&N.getCenterPos(p,this.fullLayer)}),p}clearTmpPoints(){this.tmpPoints.length=0}static async createLabels(t,e){const o=[],s=t.text.split(","),r=s.length,{fontSize:i,lineHeight:n,bold:a,textAlign:l,italic:c,boxSize:h,fontFamily:d,verticalAlign:p,fontColor:y,fontBgColor:u,underline:m,lineThrough:P}=t;for(let L=0;L<r;L++){const I=s[L],S=n||i*1.2;if(I){const T={anchor:[0,.5],text:I,fontSize:i,lineHeight:S,fontFamily:d,fontWeight:a,fillColor:y,bgcolor:u,textAlign:l,fontStyle:c,name:L.toString(),className:"label"},W=[0,0];if(p==="middle"){const g=(r-1)/2;W[1]=(L-g)*S}if(l==="left"){const g=h&&-h[0]/2||0;W[0]=c==="italic"&&g||g+5}T.pos=W;const M=new Jt(T);o.push(M)}}if(await new Promise(L=>{setTimeout(L,0)}),m||P){const L=[],[I]=e.worldScaling;for(let S=0;S<o.length;S++){const{width:T}=o[S].getBoundingClientRect();if(T){const W=o[S].getAttribute("pos");if(m){const M={normalize:!1,pos:[W[0],W[1]+i/2],lineWidth:Math.floor(i/10),points:[0,0,T/I,0],strokeColor:y,name:`${S}_underline`,className:"underline"},g=new ot(M);L.push(g)}if(P){const M={normalize:!1,pos:W,lineWidth:Math.floor(i/10),points:[0,0,T/I,0],strokeColor:y,name:`${S}_lineThrough`,className:"lineThrough"},g=new ot(M);L.push(g)}}}return o.concat(L)}return o}static updateNodeOpt(t){const{node:e,opt:o,vNodes:s,targetNode:r}=t,{fontBgColor:i,fontColor:n,translate:a,box:l,boxScale:c,boxTranslate:h,bold:d,italic:p,lineThrough:y,underline:u,fontSize:m,textInfos:P,zIndex:L}=o,I=r&&Z(r)||s.get(e.name);if(!I)return;const S=e.parent;if(!S)return;const T=I.opt;if(q(L)&&(e.setAttribute("zIndex",L),I.opt.zIndex=L),n&&T.fontColor&&(T.fontColor=n,e.children.forEach(W=>{W.tagName==="LABEL"?W.setAttribute("fillColor",n):W.tagName==="POLYLINE"&&W.setAttribute("strokeColor",n)})),i&&T.fontBgColor&&(T.fontBgColor=i,e.children.forEach(W=>{W.tagName==="LABEL"&&W.setAttribute("bgcolor",i)})),d&&(T.bold=d),p&&(T.italic=p),tt(y)&&(T.lineThrough=y),tt(u)&&(T.underline=u),m&&(T.fontSize=m),l&&h&&c){const W=P==null?void 0:P.get(e.name);if(W){const{fontSize:x,boxSize:C}=W;T.boxSize=C||T.boxSize,T.fontSize=x||T.fontSize}const M=I.rect,g=ht(It(M,c),h);T.boxPoint=g&&[(g.x-S.worldPosition[0])/S.worldScaling[0],(g.y-S.worldPosition[1])/S.worldScaling[1]]}else if(a&&T.boxPoint&&(T.boxPoint=[T.boxPoint[0]+a[0],T.boxPoint[1]+a[1]],I.centerPos=[I.centerPos[0]+a[0],I.centerPos[1]+a[1]],r)){const W=[a[0]/S.worldScaling[0],a[1]/S.worldScaling[1]];I.rect=ht(I.rect,W)}return I&&s.setInfo(e.name,I),I==null?void 0:I.rect}static getRectFromLayer(t,e){const o=t.getElementsByName(e)[0];if(o){const s=o.getBoundingClientRect();return{x:Math.floor(s.x),y:Math.floor(s.y),w:Math.floor(s.width),h:Math.floor(s.height)}}}}function zt(R){switch(R){case v.Arrow:return Rt;case v.Pencil:return Wt;case v.Straight:return Et;case v.Ellipse:return Ot;case v.Polygon:case v.Triangle:return Dt;case v.Star:case v.Rhombus:return Mt;case v.Rectangle:return Ct;case v.SpeechBalloon:return At;case v.Text:return wt;case v.LaserPen:return Lt;case v.Eraser:return bt;case v.Selector:return H;case v.Image:return pt}}function yt(R,t){const{toolsType:e,...o}=R;switch(e){case v.Arrow:return new Rt(o);case v.Pencil:return new Wt(o);case v.Straight:return new Et(o);case v.Ellipse:return new Ot(o);case v.Polygon:case v.Triangle:return new Dt(o);case v.Star:case v.Rhombus:return new Mt(o);case v.Rectangle:return new Ct(o);case v.SpeechBalloon:return new At(o);case v.Text:return new wt(o);case v.LaserPen:return new Lt(o);case v.Eraser:return new bt(o,t);case v.Selector:return o.vNodes?new H({...o,vNodes:o.vNodes,drawLayer:o.fullLayer}):void 0;case v.Image:return new pt(o);default:return}}function Bt(R){const t=[],e=["PATH","SPRITE","POLYLINE","RECT","ELLIPSE"];for(const o of R){if(o.tagName==="GROUP"&&o.children.length)return Bt(o.children);o.tagName&&e.includes(o.tagName)&&t.push(o)}return t}const _t=R=>{if(R.tagName==="GROUP"){const t=Object.getOwnPropertySymbols(R).find(e=>e.toString()==="Symbol(sealed)");if(t&&R[t])return!0}return!1},te=R=>!R.isHid,ut="cursorhover";class ee{constructor(t,e){w(this,"viewId"),w(this,"scene"),w(this,"fullLayer"),w(this,"curNodeMap",new Map),w(this,"targetNodeMap",[]),this.viewId=t,this.scene=e}init(t){this.fullLayer=t}get(t){return this.curNodeMap.get(t)}hasRenderNodes(){let t=!1;for(const e of this.curNodeMap.values())te(e)&&(t=!0);return t}has(t){this.curNodeMap.has(t)}setInfo(t,e){const o=this.curNodeMap.get(t)||{name:t,rect:e.rect};e.rect&&(o.rect=Z(e.rect)),e.op&&(o.op=Z(e.op)),e.canRotate&&(o.canRotate=e.canRotate),e.scaleType&&(o.scaleType=e.scaleType),e.opt&&(o.opt=Z(e.opt)),e.toolsType&&(o.toolsType=e.toolsType),e.centerPos&&(o.centerPos=Z(e.centerPos)),tt(e.isSelected)&&(o.isSelected=e.isSelected),o.rect?this.curNodeMap.set(t,o):this.curNodeMap.delete(t)}selected(t){this.setInfo(t,{isSelected:!0})}unSelected(t){this.setInfo(t,{isSelected:!1})}delete(t){this.curNodeMap.delete(t)}clear(){this.curNodeMap.clear(),this.targetNodeMap.length=0}hasRectIntersectRange(t,e=!0){for(const o of this.curNodeMap.values())if(lt(t,o.rect)){if(e&&o.toolsType===v.Image&&o.opt.locked||e&&o.toolsType===v.Text&&(o.opt.workState===D.Doing||o.opt.workState===D.Start))continue;return!0}return!1}getRectIntersectRange(t,e=!0){let o;const s=new Map;for(const[r,i]of this.curNodeMap.entries())if(lt(t,i.rect)){if(e&&i.toolsType===v.Image&&i.opt.locked||e&&i.toolsType===v.Text&&(i.opt.workState===D.Doing||i.opt.workState===D.Start))continue;o=E(o,i.rect),s.set(r,i)}return{rectRange:o,nodeRange:s}}getNodeRectFormShape(t,e){const o=zt(e.toolsType);return this.fullLayer&&(o==null?void 0:o.getRectFromLayer(this.fullLayer,t))}updateNodesRect(){this.curNodeMap.forEach((t,e)=>{const o=this.getNodeRectFormShape(e,t);o?(t.rect=o,this.curNodeMap.set(e,t)):this.curNodeMap.delete(e)})}combineIntersectRect(t){let e=t;return this.curNodeMap.forEach(o=>{lt(e,o.rect)&&(e=E(e,o.rect))}),e}setTarget(){return this.targetNodeMap.push(Z(this.curNodeMap)),this.targetNodeMap.length-1}getLastTarget(){return this.targetNodeMap[this.targetNodeMap.length-1]}deleteLastTarget(){this.targetNodeMap.length=this.targetNodeMap.length-1}getTarget(t){return this.targetNodeMap[t]}deleteTarget(t){this.targetNodeMap.length=t}clearTarget(){this.targetNodeMap.length=0}}class oe{constructor(t){w(this,"vNodes"),w(this,"thread"),w(this,"serviceWorkShapes",new Map),w(this,"localWorkShapes",new Map),w(this,"tmpOpt"),w(this,"tmpWorkShapeNode"),w(this,"animationId"),this.vNodes=t.vNodes,this.thread=t.thread}destroy(){this.clearAll()}clearAll(){this.thread.topLayer.children.length&&(this.thread.topLayer.parent.children.forEach(t=>{t.name!=="viewport"&&t.remove()}),this.thread.serviceLayer.removeAllChildren()),this.serviceWorkShapes.clear(),this.localWorkShapes.clear()}consumeDraw(t){const{workId:e,dataType:o}=t;if(o===b.Service)this.activeServiceWorkShape(t);else{const s=e==null?void 0:e.toString(),r=s&&this.localWorkShapes.get(s);if(!r)return;const i=r.node.consume({data:t,isFullWork:!1,isSubWorker:!0});i.rect&&(r.result=i,r.workState=D.Doing,s&&this.localWorkShapes.set(s,r))}this.runAnimation()}setToolsOpt(t){this.tmpOpt=t,this.tmpWorkShapeNode=this.createWorkShapeNode(t)}createWorkShapeNode(t){const{toolsType:e}=t;if(e===v.LaserPen)return yt({...t,vNodes:this.vNodes,fullLayer:this.thread.topLayer,drawLayer:this.thread.topLayer})}getTmpWorkShapeNode(){return this.tmpWorkShapeNode}setTmpWorkId(t){if(t&&this.tmpWorkShapeNode){this.tmpWorkShapeNode.setWorkId(t),this.localWorkShapes.set(t,{node:this.tmpWorkShapeNode,toolsType:this.tmpWorkShapeNode.toolsType,workState:D.Start}),this.tmpOpt&&this.setToolsOpt(this.tmpOpt);return}}setNodeKey(t,e,o){return t.toolsType=e,t.node=this.createWorkShapeNode({toolsType:e,toolsOpt:o}),t}activeServiceWorkShape(t){var e,o;const{workId:s,opt:r,toolsType:i,type:n,updateNodeOpt:a,ops:l,op:c}=t;if(!s)return;const h=s.toString(),d=(e=this.vNodes.get(h))==null?void 0:e.rect;if(!((o=this.serviceWorkShapes)!=null&&o.has(h))){let y={toolsType:i,animationWorkData:c||[],animationIndex:0,type:n,updateNodeOpt:a,ops:l,oldRect:d};i&&r&&(y=this.setNodeKey(y,i,r)),this.serviceWorkShapes.set(h,y)}const p=this.serviceWorkShapes.get(h);n&&(p.type=n),l&&(p.animationWorkData=ct(l),p.ops=l),a&&(p.updateNodeOpt=a),c&&(p.animationWorkData=c),p.node&&p.node.getWorkId()!==h&&p.node.setWorkId(h),d&&(p.oldRect=d),i&&r&&(p.toolsType!==i&&i&&r&&this.setNodeKey(p,i,r),p.node&&p.node.setWorkOptions(r))}computNextAnimationIndex(t,e){var o;const s=Math.floor((t.animationWorkData||[]).slice(t.animationIndex).length*32/e/(((o=t.node)==null?void 0:o.syncUnitTime)||1e3))*e;return Math.min((t.animationIndex||0)+(s||e),(t.animationWorkData||[]).length)}animationDraw(){var t,e,o,s;this.animationId=void 0;let r=!1;const i=new Map,n=[];for(const[a,l]of this.serviceWorkShapes.entries())switch(l.toolsType){case v.LaserPen:{const c=this.computNextAnimationIndex(l,8),h=Math.max(0,l.animationIndex||0),d=(l.animationWorkData||[]).slice(h,c);if((l.animationIndex||0)<c&&((t=l.node)==null||t.consumeService({op:d,isFullWork:!1}),l.animationIndex=c,d.length&&i.set(a,{workState:h===0?D.Start:c===((e=l.animationWorkData)==null?void 0:e.length)?D.Done:D.Doing,op:d.slice(-2)})),l.isDel){(o=l.node)==null||o.clearTmpPoints(),this.serviceWorkShapes.delete(a);break}l.ops&&l.animationIndex===((s=l.animationWorkData)==null?void 0:s.length)&&!l.isDel&&(this.thread.topLayer.getElementsByName(a.toString())[0]||(l.isDel=!0,this.serviceWorkShapes.set(a,l))),r=!0;break}}for(const[a,l]of this.localWorkShapes.entries()){const{result:c,toolsType:h,isDel:d,workState:p}=l;switch(h){case v.LaserPen:{if(d){l.node.clearTmpPoints(),this.localWorkShapes.delete(a),n.push({removeIds:[a.toString()],type:f.RemoveNode});break}c&&((c.op||c.ops)&&n.push(c),l.result=void 0),!this.thread.topLayer.getElementsByName(a.toString())[0]&&p===D.Done&&(l.isDel=!0,this.localWorkShapes.set(a,l)),r=!0;break}}}r&&this.runAnimation(),i.size&&i.forEach((a,l)=>{n.push({type:f.Cursor,uid:l.split(kt)[0],op:a.op,workState:a.workState,viewId:this.thread.viewId})}),n.length&&this.thread.post({sp:n})}runAnimation(){this.animationId||(this.animationId=requestAnimationFrame(this.animationDraw.bind(this)))}setWorkOptions(t,e){var o,s,r;(o=this.localWorkShapes.get(t))!=null&&o.node||this.setTmpWorkId(t),(r=(s=this.localWorkShapes.get(t))==null?void 0:s.node)==null||r.setWorkOptions(e)}consumeDrawAll(t){const{workId:e,dataType:o}=t;if(o===b.Service)this.activeServiceWorkShape(t);else{const s=e==null?void 0:e.toString(),r=s&&this.localWorkShapes.get(s);if(!r)return;const i=r.node.consumeAll({data:t});r.result=i,r.workState=D.Done,s&&this.localWorkShapes.set(s,r)}this.runAnimation()}}class se{constructor(t){w(this,"vNodes"),w(this,"thread"),w(this,"workShapes",new Map),w(this,"effectSelectNodeData",new Set),w(this,"batchEraserRemoveNodes",new Set),w(this,"batchEraserWorks",new Set),w(this,"tmpOpt"),w(this,"tmpWorkShapeNode"),w(this,"drawCount",0),w(this,"batchEraserCombine",Yt(()=>{this.updateBatchEraserCombineNode(this.batchEraserWorks,this.batchEraserRemoveNodes),this.batchEraserWorks.clear(),this.batchEraserRemoveNodes.clear()},100,{leading:!1})),this.vNodes=t.vNodes,this.thread=t.thread}workShapesDone(t,e){for(const o of this.workShapes.keys())this.consumeDrawAll({workId:o,scenePath:t,viewId:this.thread.viewId,msgType:f.DrawWork,dataType:b.Local},e)}async updateSelector(t){var e;const o=this.workShapes.get(Y);if(!((e=o==null?void 0:o.selectIds)!=null&&e.length))return;const{callback:s,...r}=t,{updateSelectorOpt:i,willSerializeData:n,scene:a}=r,l=await(o==null?void 0:o.updateSelector({updateSelectorOpt:i,selectIds:o.selectIds,vNodes:this.vNodes,willSerializeData:n,worker:this,scene:a,isMainThread:!0})),c=new Map;o.selectIds.forEach(p=>{const y=this.vNodes.get(p);if(y){const{toolsType:u,op:m,opt:P}=y;c.set(p,{opt:P,toolsType:u,ops:(m==null?void 0:m.length)&&G(m)||void 0})}});const h=[],d=s&&s({res:l,workShapeNode:o,param:r,postData:{sp:h},newServiceStore:c})||{sp:h};d.sp.length&&this.thread.post(d)}destroy(){this.clearAll()}clearAllWorkShapesCache(){this.workShapes.forEach(t=>t.clearTmpPoints()),this.workShapes.clear()}clearAll(){if(this.thread.localLayer.children.length&&(this.thread.topLayer.parent.children.forEach(t=>{t.name!=="viewport"&&t.remove()}),this.thread.localLayer.removeAllChildren()),this.workShapes.get(Y)){const t=[];t.push({type:f.Select,dataType:b.Local,selectIds:[],willSyncService:!1}),this.thread.post({sp:t})}this.workShapes.clear(),this.effectSelectNodeData.clear(),this.batchEraserWorks.clear(),this.batchEraserRemoveNodes.clear()}async checkTextActive(t){const{op:e,viewId:o,dataType:s}=t;if(e!=null&&e.length){let r;for(const i of this.vNodes.curNodeMap.values()){const{rect:n,name:a,toolsType:l,opt:c}=i,h=e[0]*this.thread.fullLayer.worldScaling[0]+this.thread.fullLayer.worldPosition[0],d=e[1]*this.thread.fullLayer.worldScaling[1]+this.thread.fullLayer.worldPosition[1];if(l===v.Text&&qt([h,d],n)&&c.workState===D.Done){r=a;break}}r&&(await this.blurSelector({viewId:o,msgType:f.Select,dataType:s,isSync:!0}),this.thread.post({sp:[{type:f.GetTextActive,toolsType:v.Text,workId:r}]}))}}cursorHover(t){const{opt:e,toolsType:o,point:s}=t,r=this.setFullWork({workId:ut,toolsType:o,opt:e});r&&s&&r.cursorHover(s)}updateFullSelectWork(t){var e,o,s,r,i;const n=this.workShapes.get(Y),{selectIds:a}=t;if(!(a!=null&&a.length)){this.blurSelector(t);return}if(!n){!this.setFullWork(t)&&t.workId&&((e=this.tmpWorkShapeNode)==null?void 0:e.toolsType)===v.Selector&&this.setTmpWorkId(t.workId.toString()),this.updateFullSelectWork(t);return}if(n&&a!=null&&a.length){const{selectRect:l}=n.updateSelectIds(a),c=[{...t,selectorColor:((o=t.opt)==null?void 0:o.strokeColor)||n.selectorColor,strokeColor:((s=t.opt)==null?void 0:s.strokeColor)||n.strokeColor,fillColor:((r=t.opt)==null?void 0:r.fillColor)||n.fillColor,textOpt:((i=t.opt)==null?void 0:i.textOpt)||n.textOpt,canTextEdit:n.canTextEdit,canRotate:n.canRotate,scaleType:n.scaleType,type:f.Select,selectRect:l,points:n.getChildrenPoints(),willSyncService:(t==null?void 0:t.willSyncService)||!1,opt:(t==null?void 0:t.willSyncService)&&n.getWorkOptions()||void 0,canLock:n.canLock,isLocked:n.isLocked,toolsTypes:n.toolsTypes,shapeOpt:n.shapeOpt}];this.thread.post({sp:c})}}removeWork(t){const{workId:e}=t,o=e==null?void 0:e.toString();o&&this.removeNode(o)}removeNode(t){var e;this.vNodes.get(t)&&((e=this.thread.fullLayer)==null||e.getElementsByName(t).forEach(o=>{o.remove()}),this.vNodes.delete(t)),this.workShapes.has(t)&&(this.thread.localLayer.getElementsByName(t).forEach(o=>{o.remove()}),this.clearWorkShapeNodeCache(t))}setFullWork(t){const{workId:e,opt:o,toolsType:s}=t;if(e&&o&&s){const r=e.toString(),i=this.workShapes.get(r)||this.createWorkShapeNode({toolsOpt:o,toolsType:s,workId:r});return i?(i.setWorkId(r),this.workShapes.set(r,i),i):void 0}}async consumeFull(t,e){var o;const s=this.setFullWork(t),r=t.ops&&ct(t.ops);if(s){const i=(o=t.workId)==null?void 0:o.toString();s.toolsType===v.Image&&e?await s.consumeServiceAsync({scene:e,isFullWork:!0,replaceId:i,isMainThread:!0}):s.toolsType===v.Text?await s.consumeServiceAsync({isFullWork:!0,replaceId:i}):s.consumeService({op:r,isFullWork:!0,replaceId:i}),t!=null&&t.updateNodeOpt&&s.updataOptService(t.updateNodeOpt);const n=[];t.workId&&this.workShapes.delete(t.workId.toString()),t.willSyncService&&n.push({opt:t.opt,toolsType:t.toolsType,type:f.FullWork,workId:t.workId,ops:t.ops,updateNodeOpt:t.updateNodeOpt,viewId:this.thread.viewId}),n.length&&this.thread.post({sp:n})}}async colloctEffectSelectWork(t){const e=this.workShapes.get(Y),{workId:o,msgType:s}=t;if(e&&o&&e.selectIds&&e.selectIds.includes(o.toString())){s===f.RemoveNode?e.selectIds=e.selectIds.filter(r=>r!==o.toString()):this.effectSelectNodeData.add(t),await new Promise(r=>{setTimeout(()=>{r(!0)},0)}),await this.runEffectSelectWork(!0).then(()=>{var r;(r=this.effectSelectNodeData)==null||r.clear()});return}return t}async runEffectSelectWork(t){var e,o,s;for(const r of this.effectSelectNodeData.values()){const i=this.setFullWork(r);if(i){const n=(e=r.workId)==null?void 0:e.toString();if(i.toolsType===v.Image)await i.consumeServiceAsync({scene:(s=(o=this.thread.localLayer)==null?void 0:o.parent)==null?void 0:s.parent,isFullWork:!0,replaceId:n,isMainThread:!0});else if(i.toolsType===v.Text)await i.consumeServiceAsync({isFullWork:!0,replaceId:n});else{const a=r.ops&&ct(r.ops);i.consumeService({op:a,isFullWork:!0,replaceId:n}),r!=null&&r.updateNodeOpt&&i.updataOptService(r.updateNodeOpt)}r.workId&&this.workShapes.delete(r.workId.toString())}}this.reRenderSelector(t)}reRenderSelector(t=!1){var e;const o=this.workShapes.get(Y);if(!o)return;if(o&&!((e=o.selectIds)!=null&&e.length))return this.blurSelector();const s=o.reRenderSelector();s&&this.thread.post({sp:[{type:f.Select,selectIds:o.selectIds,selectRect:s,willSyncService:t,viewId:this.thread.viewId,points:o.getChildrenPoints(),textOpt:o.textOpt,selectorColor:o.selectorColor,strokeColor:o.strokeColor,fillColor:o.fillColor,canTextEdit:o.canTextEdit,canRotate:o.canRotate,scaleType:o.scaleType,opt:o.getWorkOptions()||void 0,canLock:o.canLock,isLocked:o.isLocked,toolsTypes:o.toolsTypes,shapeOpt:o.shapeOpt}]})}async blurSelector(t){var e;const o=this.workShapes.get(Y),s=o==null?void 0:o.blurSelector();if(this.clearWorkShapeNodeCache(Y),((e=this.thread.fullLayer)==null?void 0:e.parent).children.forEach(r=>{r.name===Y&&r.remove()}),s){const r=[];r.push({...s,isSync:t==null?void 0:t.isSync}),this.thread.post({sp:r})}}clearWorkShapeNodeCache(t){var e,o;(e=this.getWorkShape(t))==null||e.clearTmpPoints(),this.workShapes.delete(t),((o=this.tmpWorkShapeNode)==null?void 0:o.getWorkId())===t&&this.setTmpWorkId(void 0)}drawEraser(t){var e,o;const s=[];if((e=t.newWorkDatas)!=null&&e.size){for(const r of t.newWorkDatas.values()){const i=r.workId.toString();this.batchEraserWorks.add(i),s.push({type:f.FullWork,workId:i,ops:G(r.op),opt:r.opt,toolsType:r.toolsType,updateNodeOpt:{useAnimation:!1}})}delete t.newWorkDatas}(o=t.removeIds)==null||o.forEach(r=>{this.batchEraserRemoveNodes.add(r)}),s.push(t),this.thread.post({sp:s}),this.batchEraserCombine()}updateBatchEraserCombineNode(t,e){for(const o of e.keys())this.thread.fullLayer.getElementsByName(o).forEach(s=>{s.remove()});t.forEach(o=>{const s=this.vNodes.get(o);if(s&&s.toolsType===v.Pencil&&!this.thread.fullLayer.getElementsByName(o)[0]){const r=this.setFullWork({...s,workId:o});r&&r.consumeService({op:s.op,isFullWork:!0})}})}getWorkShape(t){return this.workShapes.get(t)}getWorkShapes(){return this.workShapes}consumeDraw(t,e){const{op:o,workId:s,scenePath:r}=t;if(o!=null&&o.length&&s){const i=this.workShapes.get(s.toString());if(!i)return;const n=i.toolsType;if(n===v.LaserPen)return;switch(n){case v.Selector:{const a=i.consume({data:t,isFullWork:!0});a.type===f.Select&&(a.selectIds&&e.runReverseSelectWork(a.selectIds),this.thread.post({sp:[a]}))}break;case v.Eraser:{const a=i.consume({data:t,isFullWork:!0});a!=null&&a.rect&&this.drawEraser(a)}break;case v.Arrow:case v.Straight:case v.Ellipse:case v.Rectangle:case v.Star:case v.Polygon:case v.SpeechBalloon:case v.Pencil:{const a=i.consume({data:t,isFullWork:!1,isMainThread:!0});a&&(this.drawCount++,this.thread.post({drawCount:this.drawCount,sp:a.op&&[{...a,scenePath:r}]||void 0}))}break}}}consumeDrawAll(t,e){var o,s,r;const{workId:i,scenePath:n}=t;if(i){const a=i.toString(),l=this.workShapes.get(a);if(!l)return;const c=l.toolsType;if(c===v.LaserPen)return;const h=this.workShapes.get(ut),d=(o=h==null?void 0:h.selectIds)==null?void 0:o[0],p=l.consumeAll({data:t});switch(c){case v.Selector:p.selectIds&&d&&(s=p.selectIds)!=null&&s.includes(d)&&h.cursorBlur(),p.type===f.Select&&(p.selectIds&&e.runReverseSelectWork(p.selectIds),this.thread.post({sp:[{...p,scenePath:n}]})),(r=l.selectIds)!=null&&r.length?l.clearTmpPoints():this.clearWorkShapeNodeCache(a);break;case v.Eraser:p!=null&&p.rect&&this.drawEraser({...p,scenePath:n}),l.clearTmpPoints();break;case v.Arrow:case v.Straight:case v.Ellipse:case v.Rectangle:case v.Star:case v.Polygon:case v.SpeechBalloon:case v.Pencil:p&&(this.drawCount=0,this.thread.post({drawCount:this.drawCount,sp:[p]})),this.clearWorkShapeNodeCache(a);break}}}getTmpWorkShapeNode(){return this.tmpWorkShapeNode}setToolsOpt(t){var e;const{toolsType:o}=t;(e=this.tmpOpt)!=null&&e.toolsType&&this.tmpOpt.toolsType!==o&&this.clearAllWorkShapesCache(),this.tmpOpt=t,this.tmpWorkShapeNode=this.createWorkShapeNode(t)}setTmpWorkId(t){if(t&&this.tmpWorkShapeNode){this.tmpWorkShapeNode.setWorkId(t),this.workShapes.set(t,this.tmpWorkShapeNode),this.tmpOpt&&this.setToolsOpt(this.tmpOpt);return}}setWorkOptions(t,e){var o;this.workShapes.get(t)||this.setTmpWorkId(t),(o=this.workShapes.get(t))==null||o.setWorkOptions(e)}createWorkShapeNode(t){return yt({...t,vNodes:this.vNodes,fullLayer:this.thread.fullLayer,drawLayer:this.thread.localLayer},this.thread.serviceWork)}}class re{constructor(t){w(this,"vNodes"),w(this,"thread"),w(this,"workShapes",new Map),w(this,"selectorWorkShapes",new Map),w(this,"willRunEffectSelectorIds",new Set),w(this,"runEffectId"),w(this,"animationId"),this.vNodes=t.vNodes,this.thread=t.thread}destroy(){this.clearAll()}clearAll(){this.thread.serviceLayer.children.length&&(this.thread.serviceLayer.parent.children.forEach(t=>{t.name!=="viewport"&&t.remove()}),this.thread.serviceLayer.removeAllChildren()),this.workShapes.clear(),this.selectorWorkShapes.clear(),this.willRunEffectSelectorIds.clear()}runEffect(){this.runEffectId||(this.runEffectId=setTimeout(this.effectRunSelector.bind(this),0))}effectRunSelector(){this.runEffectId=void 0,this.willRunEffectSelectorIds.forEach(t=>{var e,o;const s=this.selectorWorkShapes.get(t);s&&s.selectIds&&((e=s.node)==null||e.selectServiceNode(t,s,!0)),(o=s==null?void 0:s.selectIds)!=null&&o.length||this.selectorWorkShapes.delete(t)}),this.willRunEffectSelectorIds.clear()}runSelectWork(t){this.activeSelectorShape(t);const{workId:e}=t,o=e==null?void 0:e.toString();o&&this.willRunEffectSelectorIds.add(o),this.runEffect()}removeWork(t){const{workId:e}=t,o=e==null?void 0:e.toString();if(o){if(this.workShapes.get(o)){this.workShapes.delete(o),this.removeNode(o,t);return}this.removeNode(o,t)}}consumeFull(t){this.activeWorkShape(t),this.runAnimation()}runReverseSelectWork(t){t.forEach(e=>{this.selectorWorkShapes.forEach((o,s)=>{var r;if((r=o.selectIds)!=null&&r.length){const i=o.selectIds.indexOf(e);i>-1&&(o.selectIds.splice(i,1),this.willRunEffectSelectorIds.add(s))}})}),this.willRunEffectSelectorIds.size&&this.runEffect()}consumeDraw(t){this.activeWorkShape(t),this.runAnimation()}computNextAnimationIndex(t,e){var o;const s=Math.floor((t.animationWorkData||[]).slice(t.animationIndex).length*32/e/(((o=t.node)==null?void 0:o.syncUnitTime)||1e3))*e;return Math.min((t.animationIndex||0)+(s||e),(t.animationWorkData||[]).length)}async animationDraw(){var t,e,o,s,r,i,n,a,l,c,h,d,p,y,u,m;this.animationId=void 0;let P=!1;const L=new Map;for(const[I,S]of this.workShapes.entries())switch(S.toolsType){case v.Image:{await((e=S.node)==null?void 0:e.consumeServiceAsync({isFullWork:!0,scene:(t=this.thread.fullLayer.parent)==null?void 0:t.parent,isMainThread:!0})),this.selectorWorkShapes.forEach((T,W)=>{var M;(M=T.selectIds)!=null&&M.includes(I)&&(this.willRunEffectSelectorIds.add(W),this.runEffect())}),this.workShapes.delete(I);break}case v.Text:{S.node&&(await((o=S.node)==null?void 0:o.consumeServiceAsync({isFullWork:!0,replaceId:I})),this.selectorWorkShapes.forEach((T,W)=>{var M;(M=T.selectIds)!=null&&M.includes(I)&&(this.willRunEffectSelectorIds.add(W),this.runEffect())}),(s=S.node)==null||s.clearTmpPoints(),this.workShapes.delete(I));break}case v.Arrow:case v.Straight:case v.Rectangle:case v.Ellipse:case v.Star:case v.Polygon:case v.SpeechBalloon:{const T=!!S.ops;if((r=S.animationWorkData)!=null&&r.length){const W=S.oldRect;(i=S.node)==null||i.consumeService({op:S.animationWorkData,isFullWork:T}),T&&(this.selectorWorkShapes.forEach((M,g)=>{var x;(x=M.selectIds)!=null&&x.includes(I)&&(this.willRunEffectSelectorIds.add(g),this.runEffect())}),(n=S.node)==null||n.clearTmpPoints(),this.workShapes.delete(I)),L.set(I,{workState:W?S.ops?D.Done:D.Doing:D.Start,op:S.animationWorkData.filter((M,g)=>{if(g%3!==2)return!0}).slice(-2)}),S.animationWorkData.length=0}break}case v.Pencil:{if(!S.useAnimation&&S.ops)(a=S.node)==null||a.consumeService({op:S.animationWorkData||[],isFullWork:!0,replaceId:I}),(l=S.node)==null||l.updataOptService(S.updateNodeOpt),this.selectorWorkShapes.forEach((T,W)=>{var M;(M=T.selectIds)!=null&&M.includes(I)&&(this.willRunEffectSelectorIds.add(W),this.runEffect())}),(c=S.node)==null||c.clearTmpPoints(),this.workShapes.delete(I);else if(S.useAnimation){if(S.isDel){(h=S.node)==null||h.clearTmpPoints(),this.workShapes.delete(I);break}const T=3,W=this.computNextAnimationIndex(S,T),M=S.isDiff?0:Math.max(0,(S.animationIndex||0)-T),g=(S.animationWorkData||[]).slice(M,W),x=(p=(d=S.node)==null?void 0:d.getWorkId())==null?void 0:p.toString();if((S.animationIndex||0)<W||S.isDiff){if((y=S.node)==null||y.consumeService({op:g,isFullWork:!1}),S.animationIndex=W,S.isDiff&&(S.isDiff=!1),g.length){const C=g.filter((z,F)=>{if(F%T!==T-1)return!0}).slice(-2);L.set(I,{workState:M===0?D.Start:W===((u=S.animationWorkData)==null?void 0:u.length)?D.Done:D.Doing,op:C})}}else S.ops&&((m=S.node)==null||m.consumeService({op:S.animationWorkData||[],isFullWork:!0,replaceId:x}),S.isDel=!0,L.set(I,{workState:D.Done,op:g.filter((C,z)=>{if(z%T!==T-1)return!0}).slice(-2)}));P=!0;break}break}}if(P&&this.runAnimation(),L.size){const I=[];L.forEach((S,T)=>{I.push({type:f.Cursor,uid:T.split(kt)[0],op:S.op,workState:S.workState,viewId:this.thread.viewId})}),this.thread.post({sp:I})}}runAnimation(){this.animationId||(this.animationId=requestAnimationFrame(this.animationDraw.bind(this)))}hasDiffData(t,e,o){const s=t.length;if(e.length<s)return!0;switch(o){case v.Pencil:{for(let r=0;r<s;r+=3)if(e[r]!==t[r]||e[r+1]!==t[r+1])return!0;break}case v.LaserPen:{for(let r=0;r<s;r+=2)if(e[r]!==t[r]||e[r+1]!==t[r+1])return!0;break}}return!1}activeWorkShape(t){var e,o,s,r;const{workId:i,opt:n,toolsType:a,type:l,updateNodeOpt:c,ops:h,op:d,useAnimation:p}=t;if(!i)return;const y=i.toString(),u=(e=this.vNodes.get(y))==null?void 0:e.rect;if(!((o=this.workShapes)!=null&&o.has(y))){let P={toolsType:a,animationWorkData:d||[],animationIndex:0,type:l,updateNodeOpt:c,ops:h,useAnimation:typeof p<"u"?p:typeof(c==null?void 0:c.useAnimation)<"u"?c==null?void 0:c.useAnimation:!0,oldRect:u,isDiff:!1};a&&n&&(P=this.setNodeKey(P,a,n)),(s=this.workShapes)==null||s.set(y,P)}const m=(r=this.workShapes)==null?void 0:r.get(y);l&&(m.type=l),h&&(m.animationWorkData=ct(h),m.ops=h),c&&(m.updateNodeOpt=c),d&&(m.isDiff=this.hasDiffData(m.animationWorkData||[],d,m.toolsType),m.animationWorkData=d),m.node&&m.node.getWorkId()!==y&&m.node.setWorkId(y),u&&(m.oldRect=u),a&&n&&(m.toolsType!==a&&a&&n&&this.setNodeKey(m,a,n),m.node&&m.node.setWorkOptions(n))}removeNode(t,e){t.indexOf(Y)>-1&&this.removeSelectWork(e),this.thread.fullLayer.getElementsByName(t).forEach(o=>{o.remove()}),this.thread.serviceLayer.getElementsByName(t).forEach(o=>{o.remove()}),this.vNodes.delete(t)}removeSelectWork(t){const{workId:e}=t,o=e==null?void 0:e.toString();o&&(this.activeSelectorShape(t),this.willRunEffectSelectorIds.add(o)),this.runEffect()}activeSelectorShape(t){var e,o,s;const{workId:r,opt:i,toolsType:n,type:a,selectIds:l}=t;if(!r)return;const c=r.toString();if(!((e=this.selectorWorkShapes)!=null&&e.has(c))){let d={toolsType:n,selectIds:l,type:a,opt:i};n&&i&&(d=this.setNodeKey(d,n,i)),(o=this.selectorWorkShapes)==null||o.set(c,d)}const h=(s=this.selectorWorkShapes)==null?void 0:s.get(c);a&&(h.type=a),h.node&&h.node.getWorkId()!==c&&h.node.setWorkId(c),h.selectIds=l||[]}setNodeKey(t,e,o){return t.toolsType=e,t.node=yt({toolsType:e,toolsOpt:o,vNodes:this.vNodes,fullLayer:this.thread.fullLayer,drawLayer:this.thread.serviceLayer},this),t}}class K{constructor(){w(this,"localWork"),w(this,"serviceWork"),w(this,"scene")}registerMainThread(t,e,o){return this.localWork=t,this.serviceWork=e,this.scene=o,this}}class ie extends K{constructor(){super(...arguments),w(this,"emitEventType",A.CopyNode)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.FullWork&&o===b.Local&&s===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o}=t;o&&await((e=this.localWork)==null?void 0:e.consumeFull(t,this.scene))}}class ne extends K{constructor(){super(...arguments),w(this,"emitEventType",A.SetColorNode)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===b.Local&&s===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willRefreshSelector:r,willSyncService:i,willSerializeData:n,textUpdateForWoker:a}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willRefreshSelector:r,willSyncService:i,willSerializeData:n,textUpdateForWoker:a,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:o,newServiceStore:s}=t,{willSyncService:r,isSync:i,textUpdateForWoker:n}=e,a=o.sp||[];if(r)for(const[l,c]of s.entries())n&&c.toolsType===v.Text?a.push({...c,workId:l,type:f.TextUpdate,dataType:b.Local,willSyncService:!0}):a.push({...c,workId:l,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:i});return{sp:a}}}class ae extends K{constructor(){super(...arguments),w(this,"emitEventType",A.ZIndexNode)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===b.Local&&s===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willRefreshSelector:r,willSyncService:i,willSerializeData:n}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willRefreshSelector:r,willSyncService:i,willSerializeData:n,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:o,newServiceStore:s}=t,{willSyncService:r,isSync:i}=e,n=o.sp||[];if(r&&n)for(const[a,l]of s.entries())n.push({...l,workId:a,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:i});return{sp:n}}}class le extends K{constructor(){super(...arguments),w(this,"emitEventType",A.TranslateNode)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===b.Local&&s===this.emitEventType)return await this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e,o;const{workId:s,updateNodeOpt:r,willRefreshSelector:i,willSyncService:n,willSerializeData:a,textUpdateForWoker:l,emitEventType:c}=t;s===H.selectorId&&r&&(r.workState===D.Done&&r!=null&&r.translate&&(r.translate[0]||r.translate[1])||r.workState!==D.Done?await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:r,willRefreshSelector:i,willSyncService:n,willSerializeData:a,isSync:!0,textUpdateForWoker:l,emitEventType:c,scene:this.scene,callback:this.updateSelectorCallback})):r.workState===D.Done&&((o=this.localWork)==null||o.vNodes.deleteLastTarget()))}updateSelectorCallback(t){const{param:e,postData:o,newServiceStore:s,workShapeNode:r,res:i}=t,{willSyncService:n,isSync:a,updateSelectorOpt:l,textUpdateForWoker:c}=e,h=l.workState,d=o.sp||[];if(h===D.Start)return{sp:[],render:[]};const p=i==null?void 0:i.selectRect;if(n){h===D.Doing&&d.push({type:f.Select,selectIds:r.selectIds,selectRect:p,willSyncService:!0,isSync:!0,points:r.getChildrenPoints(),textOpt:r.textOpt});for(const[y,u]of s.entries())c&&u.toolsType===v.Text?d.push({...u,workId:y,type:f.TextUpdate,dataType:b.Local,willSyncService:!0}):d.push({...u,workId:y,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:a})}return{sp:d}}}class ce extends K{constructor(){super(...arguments),w(this,"emitEventType",A.DeleteNode)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.RemoveNode){if(o===b.Local&&s===this.emitEventType)return this.consumeForLocalWorker(t),!0;if(o===b.Service&&s===this.emitEventType)return this.consumeForServiceWorker(t),!0}}consumeForLocalWorker(t){if(!this.localWork)return;const{removeIds:e,willSyncService:o}=t;if(!(e!=null&&e.length))return;const s=[],r=[];for(const i of e){if(i===Y){const a=this.localWork.workShapes.get(Y);if(!a)return;const l=a.selectIds&&[...a.selectIds]||[];for(const c of l){if(this.localWork.vNodes.get(c)){const h=this.commandDeleteText(c);h&&s.push(h)}this.localWork.removeNode(c),r.push(c)}this.localWork.blurSelector();continue}const n=this.commandDeleteText(i);n&&s.push(n),this.localWork.removeNode(i),r.push(i)}o&&s.push({type:f.RemoveNode,removeIds:r}),s.length&&this.localWork.thread.post({sp:s})}consumeForServiceWorker(t){this.serviceWork&&this.serviceWork.removeWork(t)}commandDeleteText(t){var e;const o=(e=this.localWork)==null?void 0:e.vNodes.get(t);if(o&&o.toolsType===v.Text)return{type:f.TextUpdate,toolsType:v.Text,workId:t,dataType:b.Local}}}class he extends K{constructor(){super(...arguments),w(this,"emitEventType",A.ScaleNode)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===b.Local&&s===this.emitEventType)return await this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willSyncService:r,willSerializeData:i}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willSyncService:r,willSerializeData:i,isSync:!0,scene:this.scene,callback:this.updateSelectorCallback.bind(this)}))}updateSelectorCallback(t){const{param:e,postData:o,workShapeNode:s,res:r,newServiceStore:i}=t,{updateSelectorOpt:n,willSyncService:a,willSerializeData:l}=e,c=n.workState,h=o.sp||[],d=r==null?void 0:r.selectRect;if(c===D.Start)return{sp:[],render:[]};if(a){c===D.Doing&&h.push({type:f.Select,selectIds:s.selectIds,selectRect:d,willSyncService:!0,isSync:!0,points:s.getChildrenPoints(),textOpt:s.textOpt}),l&&c===D.Done&&h.push({type:f.Select,selectIds:s.selectIds,selectRect:d,willSyncService:!1,isSync:!0,points:s.getChildrenPoints(),textOpt:s.textOpt});for(const[p,y]of i.entries())y.toolsType===v.Text?h.push({...y,workId:p,type:f.TextUpdate,dataType:b.Local,willSyncService:!0}):h.push({...y,workId:p,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:!0})}return{sp:h}}}class pe extends K{constructor(){super(...arguments),w(this,"emitEventType",A.RotateNode)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===b.Local&&s===this.emitEventType)return await this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willRefreshSelector:r,willSyncService:i,willSerializeData:n,emitEventType:a}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willRefreshSelector:r,willSyncService:i,willSerializeData:n,emitEventType:a,isSync:!0,scene:this.scene,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:o,workShapeNode:s,res:r,newServiceStore:i}=t,{updateSelectorOpt:n,willSyncService:a,willSerializeData:l,isSync:c}=e,h=n.workState,d=o.sp||[],p=r==null?void 0:r.selectRect;if(a){l&&h===D.Done&&d.push({type:f.Select,selectIds:s.selectIds,selectRect:p,willSyncService:!0,isSync:c,points:s.getChildrenPoints()});for(const[y,u]of i.entries())d.push({...u,workId:y,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:c})}return{sp:d}}}class de extends K{constructor(){super(...arguments),w(this,"emitEventType",A.SetFontStyle)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===b.Local&&s===this.emitEventType)return await this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willRefreshSelector:r,willSyncService:i,willSerializeData:n,textUpdateForWoker:a}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willRefreshSelector:r,willSyncService:i,willSerializeData:n,textUpdateForWoker:a,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:o,newServiceStore:s,workShapeNode:r,res:i}=t,{willSyncService:n,isSync:a,updateSelectorOpt:l,textUpdateForWoker:c}=e,h=o.sp||[],d=i==null?void 0:i.selectRect;if(n&&h){l.fontSize&&h.push({type:f.Select,selectIds:r.selectIds,selectRect:d,willSyncService:n,isSync:a,points:r.getChildrenPoints()});for(const[p,y]of s.entries())c&&y.toolsType===v.Text?h.push({...y,workId:p,type:f.TextUpdate,dataType:b.Local,willSyncService:!0}):h.push({...y,workId:p,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:a})}return{sp:h}}}class ue extends K{constructor(){super(...arguments),w(this,"emitEventType",A.SetPoint)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===b.Local&&s===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willRefreshSelector:r,willSyncService:i,willSerializeData:n,textUpdateForWoker:a}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willRefreshSelector:r,willSyncService:i,emitEventType:this.emitEventType,willSerializeData:n,isSync:!0,textUpdateForWoker:a,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:o,newServiceStore:s,workShapeNode:r,res:i}=t,{willSyncService:n,isSync:a}=e,l=o.sp||[],c=i==null?void 0:i.selectRect;if(n&&l){for(const[h,d]of s.entries())l.push({...d,workId:h,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:a});l.push({type:f.Select,selectIds:r.selectIds,selectRect:c,willSyncService:n,isSync:a,points:r.getChildrenPoints()})}return{sp:l}}}class we extends K{constructor(){super(...arguments),w(this,"emitEventType",A.SetLock)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===b.Local&&s===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willRefreshSelector:r,willSyncService:i,willSerializeData:n}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willRefreshSelector:r,willSyncService:i,willSerializeData:n,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:o,newServiceStore:s,workShapeNode:r,res:i}=t,{willSyncService:n,isSync:a,updateSelectorOpt:l}=e,c=o.sp||[],h=i==null?void 0:i.selectRect;if(n&&c){for(const[d,p]of s.entries())c.push({...p,workId:d,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:a});c.push({isLocked:l.isLocked,selectorColor:r.selectorColor,scaleType:r.scaleType,canRotate:r.canRotate,type:f.Select,selectIds:r.selectIds,selectRect:h,willSyncService:n,isSync:a})}return{sp:c}}}class ye extends K{constructor(){super(...arguments),w(this,"emitEventType",A.SetShapeOpt)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===b.Local&&s===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willRefreshSelector:r,willSyncService:i,willSerializeData:n}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willRefreshSelector:r,willSyncService:i,willSerializeData:n,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:o,newServiceStore:s}=t,{willSyncService:r,isSync:i}=e,n=o.sp||[];if(r&&n)for(const[a,l]of s.entries())n.push({...l,workId:a,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:i});return{sp:n}}}class fe{constructor(t){w(this,"builders",new Map),this.builders=new Map(t.map(e=>[e,this.build(e)]))}build(t){switch(t){case A.TranslateNode:return new le;case A.ZIndexNode:return new ae;case A.CopyNode:return new ie;case A.SetColorNode:return new ne;case A.DeleteNode:return new ce;case A.ScaleNode:return new he;case A.RotateNode:return new pe;case A.SetFontStyle:return new de;case A.SetPoint:return new ue;case A.SetLock:return new we;case A.SetShapeOpt:return new ye}}registerForMainThread(t,e,o){return this.builders.forEach(s=>{s&&s.registerMainThread(t,e,o)}),this}async consumeForMainThread(t){for(const e of this.builders.values())if(await(e==null?void 0:e.consume(t)))return!0;return!1}}class me{constructor(t,e){w(this,"viewId"),w(this,"fullLayer"),w(this,"topLayer"),w(this,"localLayer"),w(this,"serviceLayer"),w(this,"snapshotFullLayer"),w(this,"vNodes"),w(this,"master"),w(this,"opt"),w(this,"cameraOpt"),w(this,"scene"),w(this,"localWork"),w(this,"serviceWork"),w(this,"topWork"),w(this,"mainThreadPostId"),w(this,"combinePostMsg",new Set),w(this,"methodBuilder"),this.viewId=t,this.opt=e,this.scene=this.createScene({...e.canvasOpt,container:e.container}),this.master=e.master,this.fullLayer=this.createLayer("fullLayer",this.scene,{...e.layerOpt,bufferSize:this.viewId==="mainView"?4e3:2e3}),this.topLayer=this.createLayer("topLayer",this.scene,{...e.layerOpt,bufferSize:this.viewId==="mainView"?1500:1e3}),this.localLayer=this.createLayer("localLayer",this.scene,{...e.layerOpt,bufferSize:this.viewId==="mainView"?1500:1e3}),this.serviceLayer=this.createLayer("serviceLayer",this.scene,{...e.layerOpt,bufferSize:this.viewId==="mainView"?1500:1e3}),this.vNodes=new ee(t,this.scene);const o={thread:this,vNodes:this.vNodes};this.localWork=new se(o),this.serviceWork=new re(o),this.topWork=new oe(o),this.vNodes.init(this.fullLayer),this.methodBuilder=new fe([A.CopyNode,A.SetColorNode,A.DeleteNode,A.RotateNode,A.ScaleNode,A.TranslateNode,A.ZIndexNode,A.SetFontStyle,A.SetPoint,A.SetLock,A.SetShapeOpt]).registerForMainThread(this.localWork,this.serviceWork,this.scene)}post(t){this.combinePostMsg.add(t),this.runBatchPostData()}async on(t,e){if(!await this.methodBuilder.consumeForMainThread(t)){const{msgType:o,toolsType:s,opt:r,dataType:i,workId:n,workState:a}=t,l=n==null?void 0:n.toString();switch(o){case f.Destroy:this.destroy();break;case f.Clear:this.clearAll();break;case f.UpdateCamera:this.updateCamera(t),e&&this.post({workerTasksqueueCount:e});break;case f.UpdateTools:if(i===b.Local&&s&&r){const c={toolsType:s,toolsOpt:r};this.localWork.setToolsOpt(c)}break;case f.CreateWork:if(n&&r&&s){if(s===v.LaserPen){this.topWork.getTmpWorkShapeNode()||this.topWork.setToolsOpt({toolsType:s,toolsOpt:r}),l&&this.topWork.setWorkOptions(l,r);break}this.localWork.getTmpWorkShapeNode()||this.localWork.setToolsOpt({toolsType:s,toolsOpt:r}),l&&this.localWork.setWorkOptions(l,r)}break;case f.DrawWork:a===D.Done&&i===b.Local?this.consumeDrawAll(i,t):this.consumeDraw(i,t);break;case f.UpdateNode:case f.FullWork:if(s===v.LaserPen){this.consumeDrawAll(i,t);break}this.consumeFull(i,t);break;case f.RemoveNode:this.removeNode(t);return;case f.Select:i===b.Service&&(n===Y?this.localWork.updateFullSelectWork(t):this.serviceWork.runSelectWork(t));break;case f.CursorHover:this.localWork.cursorHover(t);break;case f.GetTextActive:i===b.Local&&this.localWork.checkTextActive(t);break}}}async removeNode(t){const{dataType:e,workId:o}=t;if(o===Y){this.localWork.blurSelector(t);return}e===b.Local&&(this.localWork.removeWork(t),await this.localWork.colloctEffectSelectWork(t)),e===b.Service&&(this.serviceWork.removeWork(t),await this.localWork.colloctEffectSelectWork(t))}async consumeFull(t,e){const o=await this.localWork.colloctEffectSelectWork(e);o&&t===b.Local&&await this.localWork.consumeFull(o,this.scene),o&&t===b.Service&&this.serviceWork.consumeFull(o)}setCameraOpt(t){this.cameraOpt=t;const{scale:e,centerX:o,centerY:s,width:r,height:i}=t;(r!==this.scene.width||i!==this.scene.height)&&this.updateScene({width:r,height:i}),this.fullLayer.setAttribute("scale",[e,e]),this.fullLayer.setAttribute("translate",[-o,-s]),this.topLayer.setAttribute("scale",[e,e]),this.topLayer.setAttribute("translate",[-o,-s]),this.localLayer.setAttribute("scale",[e,e]),this.localLayer.setAttribute("translate",[-o,-s]),this.serviceLayer.setAttribute("scale",[e,e]),this.serviceLayer.setAttribute("translate",[-o,-s])}runBatchPostData(){this.mainThreadPostId||(this.mainThreadPostId=requestAnimationFrame(this.combinePost.bind(this)))}combinePostData(){var t;this.mainThreadPostId=void 0;const e=[];let o,s;for(const r of this.combinePostMsg.values()){if((t=r.sp)!=null&&t.length)for(const i of r.sp){let n=!1;for(const a of e)if(nt(i,a)){n=!0;break}n||e.push(i)}q(r.drawCount)&&(o=r.drawCount),q(r.workerTasksqueueCount)&&(s=r.workerTasksqueueCount)}return this.combinePostMsg.clear(),{sp:e,drawCount:o,workerTasksqueueCount:s}}combinePost(){var t,e,o;const s=this.combinePostData(),r=(t=s.sp)==null?void 0:t.filter(i=>i.type!==f.None||Object.keys(i).filter(n=>n==="type").length);r!=null&&r.length&&(s.sp=r.map(i=>i.viewId?i:{...i,viewId:this.viewId})),((e=s.sp)==null?void 0:e.length)===0&&delete s.sp,s.drawCount===void 0&&delete s.drawCount,s.workerTasksqueueCount===void 0&&delete s.workerTasksqueueCount,(s!=null&&s.drawCount||s!=null&&s.workerTasksqueueCount||(o=s.sp)!=null&&o.length)&&this.opt.post(s)}clearAll(){this.fullLayer.children.length&&(this.fullLayer.parent.children.forEach(t=>{t.name!=="viewport"&&t.remove()}),this.fullLayer.removeAllChildren()),this.localWork.clearAll(),this.topWork.clearAll(),this.serviceWork.clearAll(),this.vNodes.clear()}consumeDrawAll(t,e){const{ops:o,op:s,workId:r}=e;if((o||s!=null&&s.length)&&r){const i=r.toString();if(this.topWork.localWorkShapes.get(i)){this.topWork.consumeDrawAll(e);return}if(this.localWork.workShapes.get(i)){this.localWork.consumeDrawAll(e,this.serviceWork);return}}}consumeDraw(t,e){const{op:o,workId:s}=e;if(o!=null&&o.length&&s){const r=s.toString();if(this.topWork.localWorkShapes.get(r)){this.topWork.consumeDraw(e);return}if(this.localWork.workShapes.get(r)){this.localWork.consumeDraw(e,this.serviceWork);return}t===b.Service&&this.serviceWork.consumeDraw(e)}}updateCamera(t){var e;const{cameraOpt:o,scenePath:s}=t;if(o&&!nt(this.cameraOpt,o)){const r=this.localWork.getWorkShape(ut);if(r&&(e=r.selectIds)!=null&&e.length&&r.cursorBlur(),s&&[...this.localWork.getWorkShapes().keys()].filter(i=>i!==ut).length&&this.localWork.workShapesDone(s,this.serviceWork),this.setCameraOpt(o),this.vNodes.curNodeMap.size&&(this.vNodes.clearTarget(),this.vNodes.updateNodesRect(),this.localWork.reRenderSelector(),this.serviceWork.selectorWorkShapes.size))for(const[i,n]of this.serviceWork.selectorWorkShapes.entries())this.serviceWork.runSelectWork({workId:i,selectIds:n.selectIds,msgType:f.Select,dataType:b.Service,viewId:this.viewId})}}createScene(t){return new vt({displayRatio:this.opt.displayer.dpr,depth:!1,desynchronized:!0,...t,autoRender:!0})}createLayer(t,e,o){const{width:s,height:r}=o,i=`canvas-${t}`,n=e.layer(i,{...o,offscreen:!1}),a=new J({anchor:[.5,.5],pos:[s*.5,r*.5],size:[s,r],name:"viewport",id:t});return n.append(a),a}updateScene(t){this.scene.attr({...t});const{width:e,height:o}=t;this.scene.width=e,this.scene.height=o,this.updateLayer({width:e,height:o})}updateLayer(t){const{width:e,height:o}=t;this.fullLayer.parent.setAttribute("width",e),this.fullLayer.parent.setAttribute("height",o),this.fullLayer.setAttribute("size",[e,o]),this.fullLayer.setAttribute("pos",[e*.5,o*.5]),this.topLayer.parent.setAttribute("width",e),this.topLayer.parent.setAttribute("height",o),this.topLayer.setAttribute("size",[e,o]),this.topLayer.setAttribute("pos",[e*.5,o*.5]),this.localLayer.parent.setAttribute("width",e),this.localLayer.parent.setAttribute("height",o),this.localLayer.setAttribute("size",[e,o]),this.localLayer.setAttribute("pos",[e*.5,o*.5]),this.serviceLayer.parent.setAttribute("width",e),this.serviceLayer.parent.setAttribute("height",o),this.serviceLayer.setAttribute("size",[e,o]),this.serviceLayer.setAttribute("pos",[e*.5,o*.5])}destroy(){this.vNodes.clear(),this.fullLayer.remove(),this.topLayer.remove(),this.localLayer.remove(),this.serviceLayer.remove(),this.scene.remove(),this.localWork.destroy(),this.serviceWork.destroy(),this.topWork.destroy()}}class ke{constructor(t,e){w(this,"viewId"),w(this,"fullLayer"),w(this,"master"),w(this,"opt"),w(this,"scene"),w(this,"mainThreadPostId"),w(this,"combinePostMsg",new Set),w(this,"workShapes",new Map),this.viewId=t,this.opt=e,this.scene=this.createScene({...e.canvasOpt,container:e.container}),this.master=e.master,this.fullLayer=this.createLayer("fullLayer",this.scene,{...e.layerOpt,bufferSize:this.viewId==="mainView"?6e3:3e3})}post(t){this.combinePostMsg.add(t),this.runBatchPostData()}async on(t){const{msgType:e}=t;switch(e){case f.Snapshot:await this.getSnapshot(t),this.destroy();return;case f.BoundingBox:await this.getBoundingRect(t),this.destroy();return}}createWorkShapeNode(t){return yt({...t,fullLayer:this.fullLayer,drawLayer:void 0})}setFullWork(t){const{workId:e,opt:o,toolsType:s}=t;if(e&&o&&s){const r=e.toString(),i=this.workShapes.get(r)||this.createWorkShapeNode({toolsOpt:o,toolsType:s,workId:r});return i?(i.setWorkId(e.toString()),this.workShapes.set(r,i),i):void 0}}async runFullWork(t){var e,o;const s=this.setFullWork(t),r=t.ops&&ct(t.ops);if(s){let i,n;const a=(e=s.getWorkId())==null?void 0:e.toString();return s.toolsType===v.Image?i=await s.consumeServiceAsync({isFullWork:!0,scene:(o=this.fullLayer.parent)==null?void 0:o.parent,isMainThread:!0}):s.toolsType===v.Text?i=await s.consumeServiceAsync({isFullWork:!0,replaceId:a,isDrawLabel:!0}):(i=s.consumeService({op:r,isFullWork:!0,replaceId:a}),n=(t==null?void 0:t.updateNodeOpt)&&s.updataOptService(t.updateNodeOpt)),E(i,n)}}async getSnapshot(t){const{scenePath:e,scenes:o,cameraOpt:s,w:r,h:i}=t;if(e&&o&&s){this.setCameraOpt(s);let n;for(const[l,c]of Object.entries(o))if(c!=null&&c.type)switch(c==null?void 0:c.type){case f.UpdateNode:case f.FullWork:{const{opt:h}=c,d=await this.runFullWork({...c,opt:h,workId:l,msgType:f.FullWork,dataType:b.Service,viewId:this.viewId});n=E(n,d);break}}let a;r&&i&&(a={resizeWidth:r,resizeHeight:i}),await this.getSnapshotRender({scenePath:e,options:a})}}getSceneRect(){const{width:t,height:e}=this.scene;return{x:0,y:0,w:Math.floor(t),h:Math.floor(e)}}getRectImageBitmap(t,e){const o=t.x*this.opt.displayer.dpr,s=t.y*this.opt.displayer.dpr,r=t.w>0&&t.w*this.opt.displayer.dpr||1,i=t.h>0&&t.h*this.opt.displayer.dpr||1;return createImageBitmap(this.fullLayer.parent.canvas,o,s,r,i,e)}async getSnapshotRender(t){var e,o;const{scenePath:s,options:r}=t;((e=this.fullLayer)==null?void 0:e.parent).render();const i=await this.getRectImageBitmap(this.getSceneRect(),r);i&&(this.post({sp:[{type:f.Snapshot,scenePath:s,imageBitmap:i,viewId:this.viewId}]}),(o=this.fullLayer)==null||o.removeAllChildren())}async getBoundingRect(t){const{scenePath:e,scenes:o,cameraOpt:s}=t;if(e&&o&&s){this.setCameraOpt(s);let r;for(const[i,n]of Object.entries(o))if(n!=null&&n.type)switch(n==null?void 0:n.type){case f.UpdateNode:case f.FullWork:{const a=await this.runFullWork({...n,workId:i,msgType:f.FullWork,dataType:b.Service,viewId:this.viewId});r=E(r,a);break}}r&&this.post({sp:[{type:f.BoundingBox,scenePath:e,rect:r}]})}}setCameraOpt(t){const{scale:e,centerX:o,centerY:s,width:r,height:i}=t;this.updateScene({width:r,height:i}),this.fullLayer.setAttribute("scale",[e,e]),this.fullLayer.setAttribute("translate",[-o,-s])}runBatchPostData(){this.mainThreadPostId||(this.mainThreadPostId=requestAnimationFrame(this.combinePost.bind(this)))}combinePostData(){var t;this.mainThreadPostId=void 0;const e=[];for(const o of this.combinePostMsg.values())if((t=o.sp)!=null&&t.length)for(const s of o.sp){let r=!1;for(const i of e)if(nt(s,i)){r=!0;break}r||e.push(s)}return this.combinePostMsg.clear(),{sp:e}}combinePost(){var t,e,o;const s=this.combinePostData(),r=(t=s.sp)==null?void 0:t.filter(i=>i.type!==f.None||Object.keys(i).filter(n=>n==="type").length);r!=null&&r.length&&(s.sp=r.map(i=>i.viewId?i:{...i,viewId:this.viewId})),((e=s.sp)==null?void 0:e.length)===0&&delete s.sp,(s!=null&&s.drawCount||s!=null&&s.workerTasksqueueCount||(o=s.sp)!=null&&o.length)&&this.opt.post(s)}createScene(t){return new vt({displayRatio:this.opt.displayer.dpr,depth:!1,desynchronized:!0,...t,autoRender:!1})}createLayer(t,e,o){const{width:s,height:r}=o,i=`canvas-${t}`,n=e.layer(i,o),a=new J({anchor:[.5,.5],pos:[s*.5,r*.5],size:[s,r],name:"viewport",id:t});return n.append(a),a}updateScene(t){this.scene.attr({...t});const{width:e,height:o}=t;this.scene.width=e,this.scene.height=o,this.updateLayer({width:e,height:o})}updateLayer(t){const{width:e,height:o}=t;this.fullLayer.parent.setAttribute("width",e),this.fullLayer.parent.setAttribute("height",o),this.fullLayer.setAttribute("size",[e,o]),this.fullLayer.setAttribute("pos",[e*.5,o*.5])}destroy(){this.fullLayer.remove(),this.scene.remove()}}class ge{constructor(t){w(this,"mainThreadMap",new Map),w(this,"snapshotThread"),w(this,"master"),this.master=t}post(t){const{drawCount:e,sp:o,workerTasksqueueCount:s}=t;q(s)&&this.master.setWorkerTasksqueueCount(s),q(e)&&this.master.setMaxDrawCount(e),o&&this.master.collectorSyncData(o)}destroy(){this.mainThreadMap.clear()}createMainThread(t,e){return new me(t,e)}createSnapshotThread(t,e){return new ke(t,e)}consume(t){var e,o,s,r;for(const i of t.values()){const{msgType:n,viewId:a,tasksqueue:l,mainTasksqueueCount:c,layerOpt:h,offscreenCanvasOpt:d,cameraOpt:p}=i;if(n===f.Init){const u=(e=this.master.control.viewContainerManager.getView(a))==null?void 0:e.displayer,m=u==null?void 0:u.canvasContainerRef.current;if(u&&m&&h&&d){const P=this.createMainThread(a,{displayer:u,container:m,layerOpt:h,master:this.master,canvasOpt:d,post:this.post.bind(this)});this.mainThreadMap.set(a,P),P&&p&&P.setCameraOpt(p)}continue}if((n===f.Snapshot||n===f.BoundingBox)&&a===((o=this.master.control.viewContainerManager.mainView)==null?void 0:o.id)){const u=(s=this.master.control.viewContainerManager.getView(a))==null?void 0:s.displayer,m=(r=u.snapshotContainerRef)==null?void 0:r.current;if(u&&m&&p){m.style.width=`${p.width}px`,m.style.height=`${p.height}px`;const P={...gt.defaultLayerOpt,offscreen:!1,width:p.width,height:p.height},L={...gt.defaultScreenCanvasOpt,width:p.width,height:p.height};this.snapshotThread=this.createSnapshotThread(a,{displayer:u,container:m,layerOpt:P,master:this.master,canvasOpt:L,post:this.post.bind(this)}),this.snapshotThread.on(i).then(()=>{this.snapshotThread=void 0,m.innerHTML="",m.style.width="",m.style.height=""});continue}}if(n===f.TasksQueue&&l!=null&&l.size&&c){for(const[u,m]of this.mainThreadMap.entries()){const P=l.get(u);P&&m.on(P,c)}continue}if(a===Ft){for(const u of this.mainThreadMap.values())u.on(i),n===f.Destroy&&this.mainThreadMap.delete(a);continue}const y=this.mainThreadMap.get(a);y&&(y.on(i),n===f.Destroy&&this.mainThreadMap.delete(a))}}}export{ge as MainThreadManagerImpl};
