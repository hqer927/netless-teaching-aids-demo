import{k as f,h as zt,U as ce,b as he,A as X,G as dt,y as wt,S as A,V as W,j as D,l as pt,C as k,R as Wt,W as Ft,P as Rt,T as Ut,_ as Yt,a as J,Q as ut,c as E,o as Lt,$ as et,u as C,J as z,L as pe,E as Xt,z as St,d as Ht,D as de,e as U,x as S,f as ft,I as ue,g as $t,i as Mt,n as rt,Y as ye,m as me,p as at,q as Gt,r as we,B as Q,X as fe,s as H,t as lt,v as Se,w as jt,F as ke,H as ge,K as ve,M as Te,N as Pe,O as Ie,Z as ct,a0 as ht}from"./index-DjiaADBO.js";var Le=Object.defineProperty,Ne=(R,t,e)=>t in R?Le(R,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):R[t]=e,u=(R,t,e)=>(Ne(R,typeof t!="symbol"?t+"":t,e),e),be=Pe,xe=Ie,Re="[object Number]";function We(R){return typeof R=="number"||xe(R)&&be(R)==Re}var Oe=We;const Z=he(Oe),qt=class q{constructor(t){u(this,"syncUnitTime",dt.syncOpt.interval),u(this,"vNodes"),u(this,"drawLayer"),u(this,"fullLayer"),u(this,"workId");const{vNodes:e,fullLayer:s,drawLayer:o,workId:i,toolsOpt:r}=t;this.vNodes=e,this.fullLayer=s,this.drawLayer=o,this.workId=i,this.syncUnitTime=r.syncUnitTime||this.syncUnitTime}get baseConsumeResult(){return{workId:this.workId,toolsType:this.toolsType,opt:this.workOptions}}filterSamePoints(t,e=.01){return t.reduce((s,o)=>{const i=s[s.length-1];return(o&&!i||o&&i&&!o.isNear(i,e))&&s.push(o),s},[])}setWorkId(t){this.workId=t}getWorkId(){return this.workId}getWorkOptions(){return this.workOptions}setWorkOptions(t){var e,s,o;this.workOptions=t,this.syncUnitTime=t.syncUnitTime||this.syncUnitTime;const i=(e=this.workId)==null?void 0:e.toString(),r=i&&((s=this.vNodes)==null?void 0:s.get(i))||void 0;i&&r&&(r.opt=t,(o=this.vNodes)==null||o.setInfo(i,r))}updataOptService(t){var e,s;let o;const i=(e=this.workId)==null?void 0:e.toString();if(i&&t){const r=this.fullLayer.getElementsByName(i)||this.drawLayer&&this.drawLayer.getElementsByName(i)||[];if(r.length!==1)return;const n=r[0],{pos:a,zIndex:l,scale:c,angle:p,translate:d}=t,h={};Z(l)&&(h.zIndex=l),a&&(h.pos=[a[0],a[1]]),c&&(h.scale=c),p&&(h.rotate=p),d&&(h.translate=d),n.attr(h);const w=n==null?void 0:n.getBoundingClientRect();return w&&(o=E(o,{x:Math.floor(w.x-q.SafeBorderPadding),y:Math.floor(w.y-q.SafeBorderPadding),w:Math.floor(w.width+q.SafeBorderPadding*2),h:Math.floor(w.height+q.SafeBorderPadding*2)})),(s=this.vNodes)==null||s.setInfo(i,{rect:o,centerPos:a}),o}}replace(t,e,s){var o;const i=t.getElementsByName(e),r=i.length;if(r){if(r>1)for(let n=1;n<i.length;n++)t.removeChild(i[n]),i[n].disconnect();s?t.replaceChild(s,i[0]):t.removeChild(i[0]),i[0].disconnect()}else s&&t.append(s);this.fullLayer===t?(o=this.drawLayer)==null||o.getElementsByName(e).forEach(n=>{var a;(a=this.drawLayer)==null||a.removeChild(n),n.disconnect()}):this.fullLayer.getElementsByName(e).forEach(n=>{this.fullLayer.removeChild(n),n.disconnect()})}static updateNodeOpt(t){const{node:e,opt:s,vNodes:o,willSerializeData:i,targetNode:r}=t,{zIndex:n,translate:a,angle:l,box:c,boxScale:p,boxTranslate:d,pointMap:h}=s;let w;const y=r&&et(r)||o.get(e.name);if(!y)return;Z(n)&&(e.setAttribute("zIndex",n),y.opt.zIndex=n);const m=e.parent;if(m){if(c&&d&&p){const{rect:T}=y,b=[];for(let O=0;O<y.op.length;O+=3)b.push(new C(y.op[O],y.op[O+1],y.op[O+2]));const I=z(b),g=[I.w*m.worldScaling[0],I.h*m.worldScaling[0]],P=[T.w-g[0],T.h-g[1]],N=[(T.w*p[0]-P[0])/g[0],(T.h*p[1]-P[1])/g[1]],M=[d[0]/m.worldScaling[0],d[1]/m.worldScaling[1]],v=y.op.map((O,$)=>{const B=$%3;return B===0?O+M[0]:B===1?O+M[1]:O}),x=[y.centerPos[0]+M[0],y.centerPos[1]+M[1]];pe(v,x,N),Xt(v)&&(y.op=v),y.centerPos=x}else if(a)if(e.setAttribute("translate",a),y.opt.translate=a,r){const T=[a[0]*m.worldScaling[0],a[1]*m.worldScaling[1]];w=St(y.rect,T),y.rect=w}else{const T=q.getRectFromLayer(m,e.name);y.rect=T||y.rect}else if(Z(l))if(e.setAttribute("rotate",l),y.opt.rotate=l,r)w=Ht(y.rect,l),y.rect=w;else{const T=q.getRectFromLayer(m,e.name);y.rect=T||y.rect}if(h){const T=h.get(e.name);if(T)for(let b=0,I=0;b<y.op.length;b+=3,I++)y.op[b]=T[I][0],y.op[b+1]=T[I][1]}if(i){if(a){const T=[a[0],a[1]],b=y.op.map((I,g)=>{const P=g%3;return P===0?I+T[0]:P===1?I+T[1]:I});y.op=b,y.centerPos=[y.centerPos[0]+T[0],y.centerPos[1]+T[1]],y!=null&&y.opt&&(y.opt.translate=void 0)}else if(Z(l)){const T=y.op;de(T,y.centerPos,l),y.op=T,y!=null&&y.opt&&(y.opt.rotate=void 0)}}y&&o.setInfo(e.name,y)}}static getCenterPos(t,e){const{worldPosition:s,worldScaling:o}=e;return[(t.x+t.w/2-s[0])/o[0],(t.y+t.h/2-s[1])/o[1]]}static getRectFromLayer(t,e){const s=t.getElementsByName(e)[0];if(s){const o=s.getBoundingClientRect();return{x:Math.floor(o.x-q.SafeBorderPadding),y:Math.floor(o.y-q.SafeBorderPadding),w:Math.floor(o.width+q.SafeBorderPadding*2),h:Math.floor(o.height+q.SafeBorderPadding*2)}}}};u(qt,"SafeBorderPadding",10);let L=qt;function yt(R,t=!0){const e=R.length;if(e<2)return"";let s=R[0],o=R[1];if(e===2)return`M${ct(s)}L${ct(o)}`;let i="";for(let r=2,n=e-1;r<n;r++)s=R[r],o=R[r+1],i+=ht(s,o);return t?`M${ht(R[0],R[1])}Q${ct(R[1])}${ht(R[1],R[2])}T${i}${ht(R[e-1],R[0])}${ht(R[0],R[1])}Z`:`M${ct(R[0])}Q${ct(R[1])}${ht(R[1],R[2])}${R.length>3?"T":""}${i}L${ct(R[e-1])}`}class Vt extends L{constructor(t){super(t),u(this,"canRotate",!0),u(this,"scaleType",U.all),u(this,"toolsType",k.Pencil),u(this,"syncTimestamp"),u(this,"syncIndex",0),u(this,"tmpPoints",[]),u(this,"MAX_REPEAR",10),u(this,"uniThickness"),u(this,"workOptions"),u(this,"centerPos",[0,0]),this.workOptions=t.toolsOpt,this.uniThickness=this.MAX_REPEAR/this.workOptions.thickness/10,this.syncTimestamp=0}combineConsume(){var t;const e=(t=this.workId)==null?void 0:t.toString();if(this.tmpPoints.length<2)return{type:f.None};const s=this.transformDataAll(!0),o={name:e};let i;const r=this.drawLayer||this.fullLayer;return s.length&&(i=this.draw({attrs:o,tasks:s,replaceId:e,layer:r})),{rect:i,type:f.DrawWork,dataType:W.Local}}setWorkOptions(t){super.setWorkOptions(t),this.syncTimestamp=Date.now()}consume(t){const{data:e,isFullWork:s,isSubWorker:o,isMainThread:i,drawCount:r,replaceId:n}=t,{workId:a}=e,{tasks:l,effects:c,consumeIndex:p}=this.transformData(e,!1);this.syncIndex=Math.min(this.syncIndex,p,Math.max(0,this.tmpPoints.length-2));const d={name:a,id:r==null?void 0:r.toString()};let h,w=!1;const y=this.syncIndex;if(this.syncTimestamp===0&&(this.syncTimestamp=Date.now()),l.length&&(l[0].taskId-this.syncTimestamp>this.syncUnitTime&&(w=!0,this.syncTimestamp=l[0].taskId,this.syncIndex=this.tmpPoints.length),o||i)){const T=s?this.fullLayer:this.drawLayer||this.fullLayer;h=this.draw({attrs:d,tasks:l,effects:c,layer:T,replaceId:n})}if(o)return p>10&&this.tmpPoints.splice(0,p-10),{rect:h,type:f.DrawWork,dataType:W.Local};const m=[];return this.tmpPoints.slice(y).forEach(T=>{m.push(T.x,T.y,this.computRadius(T.z,this.workOptions.thickness))}),{...this.baseConsumeResult,type:f.DrawWork,dataType:W.Local,rect:h,op:w?m:void 0,index:w?y*3:void 0,updateNodeOpt:{useAnimation:!0}}}consumeAll(t){var e;const s=this.workId;if(t.data){const{op:c,workState:p}=t.data;c!=null&&c.length&&p===D.Done&&this.workOptions.strokeType===H.Stroke&&this.updateTempPointsWithPressureWhenDone(c)}const o=this.transformDataAll(!0),i={name:s};let r;const n=this.fullLayer;if(o.length&&(r=this.draw({attrs:i,tasks:o,replaceId:s,layer:n})),this.tmpPoints.length<2)return this.replace(n,s),{type:f.RemoveNode,removeIds:[s],rect:r};const a=[];this.tmpPoints.map(c=>{a.push(c.x,c.y,this.computRadius(c.z,this.workOptions.thickness))}),this.syncTimestamp=0,delete this.workOptions.syncUnitTime;const l=Q(a);return(e=this.vNodes)==null||e.setInfo(s,{rect:r,op:a,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:r&&L.getCenterPos(r,n)}),{...this.baseConsumeResult,rect:r,type:f.FullWork,dataType:W.Local,ops:l,updateNodeOpt:{pos:this.centerPos,useAnimation:!0}}}clearTmpPoints(){this.tmpPoints.length=0,this.syncTimestamp=0,this.syncIndex=0}consumeService(t){var e,s;const{op:o,isFullWork:i,replaceId:r}=t;this.tmpPoints.length=0;for(let p=0;p<o.length;p+=3){const d=new C(o[p],o[p+1],o[p+2]);if(this.tmpPoints.length>0){const h=this.tmpPoints[this.tmpPoints.length-1],w=S.Sub(d,h).uni();d.setv(w)}this.tmpPoints.push(d)}if(this.tmpPoints.length<2)return;const n=this.transformDataAll(!1),a=(e=this.workId)==null?void 0:e.toString(),l={name:a};let c;if(a&&n.length){const p=i?this.fullLayer:this.drawLayer||this.fullLayer;c=this.draw({attrs:l,tasks:n,replaceId:r,layer:p}),(s=this.vNodes)==null||s.setInfo(a,{rect:c,op:o,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:c&&L.getCenterPos(c,p)})}return c}transformDataAll(t=!0){const e=this.filterSamePoints(this.tmpPoints,this.workOptions.thickness);return this.getTaskPoints(e,t&&this.workOptions.thickness||void 0)}draw(t){const{attrs:e,tasks:s,replaceId:o,effects:i,layer:r}=t,{strokeColor:n,strokeType:a,thickness:l,zIndex:c,scale:p,rotate:d,translate:h}=this.workOptions;i!=null&&i.size&&(i.forEach(I=>{var g;(g=r.getElementById(I+""))==null||g.remove()}),i.clear());let w;const y=[],m=r.worldPosition,T=r.worldScaling;for(let I=0;I<s.length;I++){const{pos:g,points:P}=s[I],{ps:N,rect:M}=this.computDrawPoints(P);let v;const x=P.length===1;a===H.Stroke||x?v=yt(N,!0):v=yt(N,!1);const O={pos:g,d:v,fillColor:a===H.Stroke||x?n:void 0,lineDash:a===H.Dotted&&!x?[1,l*2]:a===H.LongDotted&&!x?[l,l*2]:void 0,strokeColor:n,lineCap:a===H.Stroke||x?void 0:"round",lineWidth:a===H.Stroke||x?0:l};w=E(w,{x:Math.floor((M.x+g[0])*T[0]+m[0]-L.SafeBorderPadding),y:Math.floor((M.y+g[1])*T[1]+m[1]-L.SafeBorderPadding),w:Math.floor(M.w*T[0]+2*L.SafeBorderPadding),h:Math.floor(M.h*T[1]+2*L.SafeBorderPadding)}),y.push(O)}p&&(e.scale=p),d&&(e.rotate=d),h&&(e.translate=h);const b=new J;if(w){this.centerPos=L.getCenterPos(w,r),b.attr({...e,normalize:!0,anchor:[.5,.5],bgcolor:a===H.Stroke?n:void 0,pos:this.centerPos,size:[(w.w-2*L.SafeBorderPadding)/T[0],(w.h-2*L.SafeBorderPadding)/T[1]],zIndex:c});const I=y.map(g=>(g.pos=[g.pos[0]-this.centerPos[0],g.pos[1]-this.centerPos[1]],new lt(g)));b.append(...I),a===H.Stroke&&b.seal(),this.replace(r,o||e.workId,b)}if(p||d||h){const I=b==null?void 0:b.getBoundingClientRect();if(I)return{x:Math.floor(I.x-L.SafeBorderPadding),y:Math.floor(I.y-L.SafeBorderPadding),w:Math.floor(I.width+L.SafeBorderPadding*2),h:Math.floor(I.height+L.SafeBorderPadding*2)}}return w}computDrawPoints(t){return this.workOptions.strokeType===H.Stroke||t.length===1?this.computStroke(t):this.computNomal(t)}computNomal(t){let e=this.workOptions.thickness;const s=t.map(o=>(e=Math.max(e,o.radius),o.point));return{ps:s,rect:z(s,e)}}computStroke(t){return t.length===1?this.computDotStroke(t[0]):this.computLineStroke(t)}computLineStroke(t){const e=[],s=[];for(let a=0;a<t.length;a++){const{point:l,radius:c}=t[a];let p=l.v;a===0&&t.length>1&&(p=t[a+1].point.v);const d=S.Per(p).mul(c);e.push(C.Sub(l,d)),s.push(C.Add(l,d))}const o=t[t.length-1],i=C.GetSemicircleStroke(o.point,e[e.length-1],-1,8),r=C.GetSemicircleStroke(t[0].point,s[0],-1,8),n=e.concat(i,s.reverse(),r);return{ps:n,rect:z(n)}}computDotStroke(t){const{point:e,radius:s}=t,o={x:e.x-s,y:e.y-s,w:s*2,h:s*2};return{ps:C.GetDotStroke(e,s,8),rect:o}}transformData(t,e){const{op:s,workState:o}=t;let i=this.tmpPoints.length-1,r=[];if(s!=null&&s.length&&o){const{strokeType:n,thickness:a}=this.workOptions,l=new Set;i=n===H.Stroke?this.updateTempPointsWithPressure(s,a,l):this.updateTempPoints(s,a,l);const c=e?this.tmpPoints:this.tmpPoints.slice(i);return r=this.getTaskPoints(c,a),{tasks:r,effects:l,consumeIndex:i}}return{tasks:r,consumeIndex:i}}computRadius(t,e){return t*.03*e+e*.5}getMinZ(t,e){return((e||Math.max(1,Math.floor(t*.3)))-t*.5)*100/t/3}getTaskPoints(t,e){var s;const o=[];if(t.length===0)return[];let i=0,r=t[0].x,n=t[0].y,a=[r,n],l=[],c=t[0].t;for(;i<t.length;){const p=t[i],d=p.x-r,h=p.y-n,w=p.z,y=e?this.computRadius(w,e):w;if(l.push({point:new C(d,h,w,t[i].v),radius:y}),i>0&&i<t.length-1){const m=t[i].getAngleByPoints(t[i-1],t[i+1]);if(m<90||m>270){const T=(s=l.pop())==null?void 0:s.point.clone();T&&o.push({taskId:c,pos:a,points:[...l,{point:T,radius:y}]}),r=t[i].x,n=t[i].y,a=[r,n];const b=p.x-r,I=p.y-n;l=[{point:new C(b,I,w),radius:y}],c=Date.now()}}i++}return o.push({taskId:c,pos:a,points:l}),o}updateTempPointsWithPressure(t,e,s){const o=Date.now(),i=this.tmpPoints.length;let r=i;for(let a=0;a<t.length;a+=2){r=Math.min(r,i);const l=this.tmpPoints.length,c=new C(t[a],t[a+1]);if(l===0){this.tmpPoints.push(c);continue}const p=l-1,d=this.tmpPoints[p],h=S.Sub(c,d).uni();if(c.isNear(d,e)){if(d.z<this.MAX_REPEAR){if(d.setz(Math.min(d.z+1,this.MAX_REPEAR)),r=Math.min(r,p),l>1){let m=l-1;for(;m>0;){const T=this.tmpPoints[m].distance(this.tmpPoints[m-1]),b=Math.max(this.tmpPoints[m].z-this.uniThickness*T,0);if(this.tmpPoints[m-1].z>=b)break;this.tmpPoints[m-1].setz(b),r=Math.min(r,m-1),m--}}}else r=1/0;continue}c.setv(h);const w=c.distance(d),y=Math.max(d.z-this.uniThickness*w,0);l>1&&S.Equals(h,d.v,.02)&&(y>0||d.z<=0)&&(s&&d.t&&s.add(d.t),this.tmpPoints.pop(),r=Math.min(p,r)),c.setz(y),this.tmpPoints.push(c)}if(r===1/0)return this.tmpPoints.length;let n=i;if(r===i){n=Math.max(n-1,0);const a=this.tmpPoints[n].t;a&&(s==null||s.add(a))}else{let a=i-1;for(n=r;a>=0;){const l=this.tmpPoints[a].t;if(l&&(s==null||s.add(l),a<=r)){n=a,a=-1;break}a--}}return this.tmpPoints[n].setT(o),n}updateTempPoints(t,e,s){var o;const i=Date.now(),r=this.tmpPoints.length;let n=r;for(let l=0;l<t.length;l+=2){const c=this.tmpPoints.length,p=new C(t[l],t[l+1]);if(c===0){this.tmpPoints.push(p);continue}const d=c-1,h=this.tmpPoints[d],w=S.Sub(p,h).uni();if(p.isNear(h,e/2)){n=Math.min(d,n);continue}S.Equals(w,h.v,.02)&&(s&&h.t&&s.add(h.t),this.tmpPoints.pop(),n=Math.min(d,n)),p.setv(w),this.tmpPoints.push(p)}let a=r;if(n===r){a=Math.max(a-1,0);const l=this.tmpPoints[a].t;l&&(s==null||s.add(l))}else{let l=Math.min(r-1,n);for(a=n;l>=0;){const c=(o=this.tmpPoints[l])==null?void 0:o.t;if(c&&(s==null||s.add(c),l<=n)){a=l,l=-1;break}l--}}return this.tmpPoints[a].setT(i),a}updateTempPointsWithPressureWhenDone(t){const{thickness:e}=this.workOptions,s=t.length,o=this.getMinZ(e);for(let i=0;i<s;i+=2){const r=this.tmpPoints.length,n=new C(t[i],t[i+1]);if(r===0){this.tmpPoints.push(n);continue}const a=r-1,l=this.tmpPoints[a],c=S.Sub(n,l).uni(),p=n.distance(l);if(r>1&&l.z===o)break;if(n.isNear(l,e/2)){if(s<3&&l.z<this.MAX_REPEAR&&(l.setz(Math.min(l.z+1,this.MAX_REPEAR)),r>1)){let h=r-1;for(;h>0;){const w=this.tmpPoints[h].distance(this.tmpPoints[h-1]),y=Math.max(this.tmpPoints[h].z-this.uniThickness*w,-e/4);if(this.tmpPoints[h-1].z>=y)break;this.tmpPoints[h-1].setz(y),h--}}continue}n.setv(c);const d=Math.max(l.z-this.uniThickness*p,o);r>1&&S.Equals(c,l.v,.02)&&l.z<=0&&this.tmpPoints.pop(),n.setz(d),this.tmpPoints.push(n)}}static updateNodeOpt(t){var e;const{node:s,opt:o,vNodes:i}=t,{strokeColor:r}=o,n=i.get(s.name);return r&&(s.tagName==="GROUP"?Ce(s)?s.setAttribute("bgcolor",r):s.children.forEach(a=>{a.setAttribute("strokeColor",r),a.getAttribute("fillColor")&&a.setAttribute("fillColor",r)}):(s.setAttribute("strokeColor",r),s.setAttribute("fillColor",r)),(e=n==null?void 0:n.opt)!=null&&e.strokeColor&&(n.opt.strokeColor=r)),n&&i.setInfo(s.name,n),L.updateNodeOpt(t)}}class Zt extends L{constructor(t){super(t),u(this,"toolsType",k.LaserPen),u(this,"canRotate",!1),u(this,"scaleType",U.none),u(this,"syncTimestamp"),u(this,"syncIndex",0),u(this,"tmpPoints",[]),u(this,"workOptions"),u(this,"consumeIndex",0),this.workOptions=t.toolsOpt,this.syncTimestamp=0}combineConsume(){}setWorkOptions(t){super.setWorkOptions(t),this.syncTimestamp=Date.now()}consume(t){const{data:e,isSubWorker:s}=t,{workId:o,op:i}=e;if((i==null?void 0:i.length)===0)return{type:f.None};if(this.updateTempPoints(i||[]),this.consumeIndex>this.tmpPoints.length-4)return{type:f.None};const{strokeColor:r,thickness:n,strokeType:a}=this.workOptions,l=z(this.tmpPoints,n);let c=!1;const p=this.syncIndex,d=this.tmpPoints.slice(this.consumeIndex);this.consumeIndex=this.tmpPoints.length-1,this.syncTimestamp===0&&(this.syncTimestamp=Date.now());const h={name:o==null?void 0:o.toString(),opacity:1,lineDash:a===H.Dotted?[1,n*2]:a===H.LongDotted?[n,n*2]:void 0,strokeColor:r,lineCap:"round",lineWidth:n,anchor:[.5,.5]},w=this.getTaskPoints(d);if(w.length){const m=Date.now();m-this.syncTimestamp>this.syncUnitTime&&(c=!0,this.syncTimestamp=m,this.syncIndex=this.tmpPoints.length),s&&this.draw({attrs:h,tasks:w,isDot:!1,layer:this.drawLayer||this.fullLayer})}const y=[];return this.tmpPoints.slice(p).forEach(m=>{y.push(m.x,m.y)}),{rect:{x:l.x*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],y:l.y*this.fullLayer.worldScaling[1]+this.fullLayer.worldPosition[1],w:l.w*this.fullLayer.worldScaling[0],h:l.h*this.fullLayer.worldScaling[1]},type:f.DrawWork,dataType:W.Local,op:c?y:void 0,index:c?p*2:void 0,...this.baseConsumeResult}}consumeAll(){var t;const e=(t=this.workId)==null?void 0:t.toString();let s;if(this.tmpPoints.length-1>this.consumeIndex){let r=this.tmpPoints.slice(this.consumeIndex);const n=r.length===1,{strokeColor:a,thickness:l,strokeType:c}=this.workOptions;if(n){const h=this.computDotStroke({point:r[0],radius:l/2});r=h.ps,s=h.rect}else s=z(this.tmpPoints,l);const p={name:e==null?void 0:e.toString(),fillColor:n?a:void 0,opacity:1,lineDash:c===H.Dotted&&!n?[1,l*2]:c===H.LongDotted&&!n?[l,l*2]:void 0,strokeColor:a,lineCap:n?void 0:"round",lineWidth:n?0:l,anchor:[.5,.5]},d=this.getTaskPoints(r);d.length&&this.draw({attrs:p,tasks:d,isDot:n,layer:this.drawLayer||this.fullLayer})}const o=[];this.tmpPoints.forEach(r=>{o.push(r.x,r.y)});const i=Q(o);return{rect:s&&{x:s.x*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],y:s.y*this.fullLayer.worldScaling[1]+this.fullLayer.worldPosition[1],w:s.w*this.fullLayer.worldScaling[0],h:s.h*this.fullLayer.worldScaling[1]},type:f.FullWork,dataType:W.Local,ops:i,index:this.syncIndex*2,...this.baseConsumeResult}}clearTmpPoints(){this.tmpPoints.length=0,this.syncTimestamp=0,this.syncIndex=0}consumeService(t){var e;const{op:s,replaceId:o,isFullWork:i}=t,{strokeColor:r,thickness:n,strokeType:a}=this.workOptions;if(!s.length){const y=z(this.tmpPoints,n);return{x:y.x*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],y:y.y*this.fullLayer.worldScaling[1]+this.fullLayer.worldPosition[1],w:y.w*this.fullLayer.worldScaling[0],h:y.h*this.fullLayer.worldScaling[1]}}const l=Math.max(0,this.tmpPoints.length-1);this.updateTempPoints(s||[]);let c,p=this.tmpPoints.slice(l);const d=p.length===1;if(d){const y=this.computDotStroke({point:p[0],radius:n/2});p=y.ps,c=y.rect}else c=z(this.tmpPoints,n);const h={name:(e=this.workId)==null?void 0:e.toString(),fillColor:d?r:void 0,opacity:1,lineDash:a===H.Dotted&&!d?[1,n*2]:a===H.LongDotted&&!d?[n,n*2]:void 0,strokeColor:r,lineCap:d?void 0:"round",lineWidth:d?0:n,anchor:[.5,.5]},w=this.getTaskPoints(p);if(w.length){const y=i?this.fullLayer:this.drawLayer||this.fullLayer;this.draw({attrs:h,tasks:w,isDot:d,replaceId:o,layer:y})}return{x:c.x*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],y:c.y*this.fullLayer.worldScaling[1]+this.fullLayer.worldPosition[1],w:c.w*this.fullLayer.worldScaling[0],h:c.h*this.fullLayer.worldScaling[1]}}computDotStroke(t){const{point:e,radius:s}=t,o={x:e.x-s,y:e.y-s,w:s*2,h:s*2};return{ps:C.GetDotStroke(e,s,8),rect:o}}updateTempPoints(t){const e=this.tmpPoints.length;for(let s=0;s<t.length;s+=2){if(e){const o=this.tmpPoints.slice(-1)[0];o&&o.x===t[s]&&o.y===t[s+1]&&this.tmpPoints.pop()}this.tmpPoints.push(new C(t[s],t[s+1]))}}async draw(t){const{attrs:e,tasks:s,isDot:o,layer:i}=t,{duration:r}=this.workOptions;for(const n of s){const a=new lt,{pos:l,points:c}=n;let p;o?p=yt(c,!0):p=yt(c,!1),a.attr({...e,pos:l,d:p});const{vertex:d,fragment:h}=this.workOptions;if(d&&h){const w=i.renderer.createProgram({vertex:d,fragment:h}),{width:y,height:m}=i.getResolution();a.setUniforms({u_time:0,u_resolution:[y,m]}),a.setProgram(w)}i.appendChild(a),a.transition(r).attr({scale:o?[.1,.1]:[1,1],lineWidth:o?0:1}).then(()=>{a.remove()})}}getTaskPoints(t){var e;const s=[];if(t.length===0)return[];let o=0,i=t[0].x,r=t[0].y,n=[i,r],a=[];for(;o<t.length;){const l=t[o],c=l.x-i,p=l.y-r;if(a.push(new C(c,p)),o>0&&o<t.length-1){const d=t[o].getAngleByPoints(t[o-1],t[o+1]);if(d<90||d>270){const h=(e=a.pop())==null?void 0:e.clone();h&&s.push({pos:n,points:[...a,h]}),i=t[o].x,r=t[o].y,n=[i,r];const w=l.x-i,y=l.y-r;a=[new C(w,y)]}}o++}return s.push({pos:n,points:a}),s}removeLocal(){}removeService(t){let e;const s=[];return this.fullLayer.getElementsByName(t).forEach(o=>{if(o.name===t){const i=o.getBoundingClientRect();e=E(e,{x:i.x,y:i.y,w:i.width,h:i.height}),s.push(o)}}),s.length&&s.forEach(o=>o.remove()),e}}const Jt=class Nt extends L{constructor(t,e){super(t),u(this,"canRotate",!1),u(this,"scaleType",U.none),u(this,"toolsType",k.Eraser),u(this,"serviceWork"),u(this,"tmpPoints",[]),u(this,"workOptions"),u(this,"worldPosition"),u(this,"worldScaling"),u(this,"eraserRect"),u(this,"eraserPolyline"),this.serviceWork=e,this.workOptions=t.toolsOpt,this.worldPosition=this.fullLayer.worldPosition,this.worldScaling=this.fullLayer.worldScaling}combineConsume(){}consumeService(){}setWorkOptions(t){super.setWorkOptions(t)}createEraserRect(t){const e=t[0]*this.worldScaling[0]+this.worldPosition[0],s=t[1]*this.worldScaling[1]+this.worldPosition[1],{width:o,height:i}=Nt.eraserSizes[this.workOptions.thickness];this.eraserRect={x:e-o*.5,y:s-i*.5,w:o,h:i},this.eraserPolyline=[this.eraserRect.x,this.eraserRect.y,this.eraserRect.x+this.eraserRect.w,this.eraserRect.y+this.eraserRect.h]}computRectCenterPoints(){const t=this.tmpPoints.slice(-2);if(this.tmpPoints.length===4){const e=new S(this.tmpPoints[0],this.tmpPoints[1]),s=new S(this.tmpPoints[2],this.tmpPoints[3]),o=S.Sub(s,e).uni(),i=S.Dist(e,s),{width:r,height:n}=Nt.eraserSizes[this.workOptions.thickness],a=Math.min(r,n),l=Math.round(i/a);if(l>1){const c=[];for(let p=0;p<l;p++){const d=S.Mul(o,p*a);c.push(this.tmpPoints[0]+d.x,this.tmpPoints[1]+d.y)}return c.concat(t)}}return t}isNear(t,e){const s=new S(t[0],t[1]),o=new S(e[0],e[1]),{width:i,height:r}=Nt.eraserSizes[this.workOptions.thickness];return S.Dist(s,o)<Math.hypot(i,r)*.5}cutPolyline(t,e){let s=[e],o=0;for(;o<t.length;){const n=t[o];if(n.length<2)break;s=i(s,n),o++}return s;function i(n,a){const l=n;for(let c=0;c<n.length;c++){const p=n[c],d=p.findIndex((h,w)=>w<p.length-1?r([h,p[w+1]],[a[0],a[1]]):!1);if(d!==-1&&d>-1){const h=[],w=p.slice(0,d+1);if(S.Equals(p[d],a[0])||w.push(a[0].clone().setz(p[d].z)),w.length>1&&h.push(w),d+a.length-1<p.length-1){const y=d+a.length-1,m=p.slice(y),T=a[a.length-1];S.Equals(p[y],T)||m.unshift(T.clone().setz(p[y].z)),m.length>1&&h.push(m)}return l.splice(c,1,...h),l}}return l}function r(n,a){const l=S.Sub(n[1],n[0]),c=S.Sub(a[1],a[0]),p=S.Sub(a[0],n[0]);return Math.abs(S.Cpr(l,c))<.1&&Math.abs(S.Cpr(l,p))<.1}}isSamePoint(t,e){return t[0]===e[0]&&t[1]===e[1]}translateIntersect(t){const e=[];for(let s=0;s<t.length;s++){const o=t[s].filter((n,a,l)=>!(a>0&&this.isSamePoint(n,l[a-1]))),i=[];let r=0;for(;r<o.length;){const n=o[r],a=new S(n[0],n[1]);i.push(a),r++}e.push(i)}return e}isLineEraser(t,e){return!(t===k.Pencil&&!e)}remove(t){const{curNodeMap:e,removeIds:s,newWorkDatas:o}=t,{isLine:i}=this.workOptions;let r;for(const[n,a]of e.entries())if(a.rect&&this.eraserRect&&this.eraserPolyline&&ft(this.eraserRect,a.rect)){const{op:l,toolsType:c}=a,p=this.isLineEraser(c,i),d=[],h=[];for(let y=0;y<l.length;y+=3){const m=new S(l[y]*this.worldScaling[0]+this.worldPosition[0],l[y+1]*this.worldScaling[1]+this.worldPosition[1],l[y+2]);h.push(m),d.push(new C(m.x,m.y))}const w=d.length&&z(d)||a.rect;if(ft(w,this.eraserRect)){if(h.length>1){const y=ue.polyline(h.map(m=>m.XY),this.eraserPolyline);if(y.length&&(s.add(a.name),!p)){const m=this.translateIntersect(y),T=this.cutPolyline(m,h);for(let b=0;b<T.length;b++){const I=`${n}_s_${b}`,g=[];T[b].forEach(P=>{g.push((P.x-this.worldPosition[0])/this.worldScaling[0],(P.y-this.worldPosition[1])/this.worldScaling[1],P.z)}),a.opt&&a.toolsType&&this.vNodes&&(this.vNodes.setInfo(I,{rect:w,op:g,opt:a.opt,canRotate:a.canRotate,scaleType:a.scaleType,toolsType:a.toolsType}),o.set(I,{workId:I,op:g,opt:a.opt,toolsType:a.toolsType}))}}}else s.add(a.name);r=E(r,w)}}return s.forEach(n=>{var a;return(a=this.vNodes)==null?void 0:a.delete(n)}),r&&(r.x-=L.SafeBorderPadding,r.y-=L.SafeBorderPadding,r.w+=L.SafeBorderPadding*2,r.h+=L.SafeBorderPadding*2),r}consume(t){const{op:e}=t.data;if(!e||e.length===0)return{type:f.None,...this.baseConsumeResult};const s=this.tmpPoints.length;if(s>1&&this.isNear([e[0],e[1]],[this.tmpPoints[s-2],this.tmpPoints[s-1]]))return{type:f.None,...this.baseConsumeResult};s===4&&(this.tmpPoints.shift(),this.tmpPoints.shift()),this.tmpPoints.push(e[0],e[1]);const o=this.computRectCenterPoints();let i;const r=new Set,n=new Map;if(!this.vNodes)return{type:f.None,...this.baseConsumeResult};this.vNodes.setTarget();const a=this.getUnLockNodeMap(this.vNodes.getLastTarget());for(let l=0;l<o.length-1;l+=2){this.createEraserRect(o.slice(l,l+2));const c=this.remove({curNodeMap:a,removeIds:r,newWorkDatas:n});i=E(i,c)}if(this.vNodes.deleteLastTarget(),i&&r.size){for(const l of n.keys())r.has(l)&&n.delete(l);return{type:f.RemoveNode,rect:i,removeIds:[...r],newWorkDatas:n}}return{type:f.None,...this.baseConsumeResult}}consumeAll(t){return this.consume(t)}clearTmpPoints(){this.tmpPoints.length=0}getUnLockNodeMap(t){var e;if(this.serviceWork){const s=et(t),o=this.serviceWork.selectorWorkShapes,i=this.serviceWork.workShapes;for(const r of o.values())if((e=r.selectIds)!=null&&e.length)for(const n of r.selectIds)s.delete(n);for(const r of i.keys())s.delete(r);return s}return t}};u(Jt,"eraserSizes",Object.freeze([Object.freeze({width:18,height:26}),Object.freeze({width:26,height:34}),Object.freeze({width:34,height:50})]));let Qt=Jt;const Ot=class nt extends L{constructor(t){super(t),u(this,"toolsType",k.Selector),u(this,"tmpPoints",[]),u(this,"workOptions"),u(this,"vNodes"),u(this,"selectIds"),u(this,"selectorColor"),u(this,"strokeColor"),u(this,"fillColor"),u(this,"oldSelectRect"),u(this,"canRotate",!1),u(this,"canTextEdit",!1),u(this,"canLock",!1),u(this,"scaleType",U.all),u(this,"toolsTypes"),u(this,"shapeOpt"),u(this,"textOpt"),u(this,"isLocked"),this.workOptions=t.toolsOpt,this.vNodes=t.vNodes}computSelector(t=!0){const e=z(this.tmpPoints);if(e.w===0||e.h===0)return{selectIds:[],intersectRect:void 0,subNodeMap:new Map};const{rectRange:s,nodeRange:o}=this.vNodes.getRectIntersectRange(e,t);return{selectIds:[...o.keys()],intersectRect:s,subNodeMap:o}}updateTempPoints(t){const e=this.tmpPoints.length,s=t.length;if(s>1){const o=new C(t[s-2]*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],t[s-1]*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[1]);e===2?this.tmpPoints.splice(1,1,o):this.tmpPoints.push(o)}}drawSelector(t){const{drawRect:e,subNodeMap:s,selectorId:o,layer:i,isService:r}=t,n=new J({pos:[e.x,e.y],anchor:[0,0],size:[e.w,e.h],id:o,name:o,zIndex:9999}),a=[];if(r){const l=new $t({normalize:!0,pos:[e.w/2,e.h/2],lineWidth:1,strokeColor:this.selectorColor||this.workOptions.strokeColor,width:e.w,height:e.h,name:nt.selectorBorderId});a.push(l)}s.forEach((l,c)=>{const p=[l.rect.x+l.rect.w/2-e.x,l.rect.y+l.rect.h/2-e.y],d=new $t({normalize:!0,pos:p,lineWidth:1,strokeColor:s.size>1?this.selectorColor||this.workOptions.strokeColor:void 0,width:l.rect.w,height:l.rect.h,id:`selector-${c}`,name:`selector-${c}`});a.push(d)}),a&&n.append(...a),(i==null?void 0:i.parent).appendChild(n)}draw(t,e,s,o=!1){var i,r;const{intersectRect:n,subNodeMap:a}=s;(r=(i=e.parent)==null?void 0:i.getElementById(t))==null||r.remove(),n&&this.drawSelector({drawRect:n,subNodeMap:a,selectorId:t,layer:e,isService:o})}getSelecteorInfo(t){this.scaleType=U.all,this.canRotate=!1,this.textOpt=void 0,this.strokeColor=void 0,this.fillColor=void 0,this.canTextEdit=!1,this.canLock=!1,this.isLocked=!1,this.toolsTypes=void 0,this.shapeOpt=void 0;const e=new Set;let s;for(const o of t.values()){const{opt:i,canRotate:r,scaleType:n,toolsType:a}=o;this.selectorColor=this.workOptions.strokeColor,i.strokeColor&&(this.strokeColor=i.strokeColor),i.fillColor&&(this.fillColor=i.fillColor),i.textOpt&&(this.textOpt=i.textOpt),a===k.SpeechBalloon&&(e.add(a),this.shapeOpt||(this.shapeOpt={}),this.shapeOpt.placement=i.placement),a===k.Polygon&&(e.add(a),this.shapeOpt||(this.shapeOpt={}),this.shapeOpt.vertices=i.vertices),a===k.Star&&(e.add(a),this.shapeOpt||(this.shapeOpt={}),this.shapeOpt.vertices=i.vertices,this.shapeOpt.innerRatio=i.innerRatio,this.shapeOpt.innerVerticeStep=i.innerVerticeStep),a===k.Text&&(this.textOpt=i),t.size===1&&(this.textOpt&&(this.canTextEdit=!0),this.canRotate=r,this.scaleType=n),n===U.none&&(this.scaleType=n),a===k.Image&&(s=o)}e.size&&(this.toolsTypes=[...e]),s&&(t.size===1?(this.canLock=!0,s.opt.locked&&(this.isLocked=!0,this.scaleType=U.none,this.canRotate=!1,this.textOpt=void 0,this.fillColor=void 0,this.selectorColor="rgb(177,177,177)",this.strokeColor=void 0,this.canTextEdit=!1)):t.size>1&&!s.opt.locked&&(this.canLock=!1,this.canRotate=!1))}getChildrenPoints(){var t,e;if(this.scaleType===U.both&&((t=this.selectIds)==null?void 0:t.length)===1){const s=this.selectIds[0],o=(e=this.vNodes.get(s))==null?void 0:e.op;if(o){const i=[];for(let r=0;r<o.length;r+=3)i.push([o[r],o[r+1]]);return i}}}consume(t){const{op:e,workState:s}=t.data;let o=this.oldSelectRect;if(s===D.Start&&(o=this.unSelectedAllIds()),!(e!=null&&e.length)||!this.vNodes.curNodeMap.size)return{type:f.None};this.updateTempPoints(e);const i=this.computSelector();if(this.selectIds&&Lt(this.selectIds,i.selectIds))return{type:f.None};this.selectIds=i.selectIds;const r=i.intersectRect;this.getSelecteorInfo(i.subNodeMap),this.draw(nt.selectorId,this.fullLayer,i),this.oldSelectRect=r;const n=this.getChildrenPoints();return{type:f.Select,dataType:W.Local,rect:E(r,o),selectIds:i.selectIds,selectRect:r,selectorColor:this.selectorColor,strokeColor:this.strokeColor,fillColor:this.fillColor,textOpt:this.textOpt,canTextEdit:this.canTextEdit,canRotate:this.canRotate,canLock:this.canLock,scaleType:this.scaleType,willSyncService:!0,points:n,isLocked:this.isLocked,toolsTypes:this.toolsTypes,shapeOpt:this.shapeOpt,...this.baseConsumeResult}}consumeAll(){var t,e;let s=this.oldSelectRect;if(!((t=this.selectIds)!=null&&t.length)&&this.tmpPoints[0]&&this.selectSingleTool(this.tmpPoints[0].XY,nt.selectorId,!1),(e=this.selectIds)!=null&&e.length&&(s=this.selectedByIds(this.selectIds)),s){const o=this.getChildrenPoints();return{type:f.Select,dataType:W.Local,rect:this.oldSelectRect,selectIds:this.selectIds,selectorColor:this.selectorColor,selectRect:this.oldSelectRect,strokeColor:this.strokeColor,fillColor:this.fillColor,textOpt:this.textOpt,canTextEdit:this.canTextEdit,canRotate:this.canRotate,canLock:this.canLock,scaleType:this.scaleType,willSyncService:!0,points:o,isLocked:this.isLocked,toolsTypes:this.toolsTypes,shapeOpt:this.shapeOpt,...this.baseConsumeResult}}return{type:f.None}}consumeService(){}clearTmpPoints(){this.tmpPoints.length=0}clearSelectData(){this.selectIds=void 0,this.oldSelectRect=void 0}selectSingleTool(t,e=nt.selectorId,s=!1){if(t.length===2){const o=t[0],i=t[1];let r;const{nodeRange:n}=this.vNodes.getRectIntersectRange({x:o,y:i,w:0,h:0},!1),a=[...n.values()].sort((l,c)=>(c.opt.zIndex||0)-(l.opt.zIndex||0));for(const l of a){const c=this.fullLayer.getElementsByName(l.name);if(ae(c).find(p=>p.isPointCollision(o,i))){r=l;break}}if(r){const l=r.name;if(!Lt(this.oldSelectRect,r.rect)){const c=new Map([[l,r]]);this.getSelecteorInfo(c),this.draw(e,this.fullLayer,{intersectRect:r.rect,subNodeMap:c,selectIds:this.selectIds||[]},s)}this.selectIds=[l],this.oldSelectRect=r.rect}}}unSelectedAllIds(){let t;for(const[e,s]of this.vNodes.curNodeMap.entries())s.isSelected&&(t=E(t,s.rect),this.vNodes.unSelected(e));return t}unSelectedByIds(t){let e;for(const s of t){const o=this.vNodes.get(s);o&&o.isSelected&&(e=E(e,o.rect),this.vNodes.unSelected(s))}return e}selectedByIds(t){let e;for(const s of t){const o=this.vNodes.get(s);o&&(e=E(e,o.rect),this.vNodes.selected(s))}return e}getSelectorRect(t,e){var s;let o;const i=(s=t.parent)==null?void 0:s.getElementById(e),r=i==null?void 0:i.getBoundingClientRect();return r&&(o=E(o,{x:Math.floor(r.x),y:Math.floor(r.y),w:Math.floor(r.width+1),h:Math.floor(r.height+1)})),o}isCanFillColor(t){return t===k.Ellipse||t===k.Triangle||t===k.Rectangle||t===k.Polygon||t===k.Star||t===k.SpeechBalloon}async updateSelector(t){const{updateSelectorOpt:e,selectIds:s,vNodes:o,willSerializeData:i,worker:r,offset:n,scene:a,isMainThread:l}=t,c=this.fullLayer;if(!c)return;let p;const d=new Map,{box:h,workState:w,angle:y,translate:m}=e;let T=[0,0],b=[1,1],I=[0,0],g,P;if(h||m||Z(y)){if(w===D.Start)return o.setTarget(),{type:f.Select,dataType:W.Local,selectRect:this.oldSelectRect,rect:this.oldSelectRect};if(g=o.getLastTarget(),g&&h){let v;s==null||s.forEach(x=>{const O=g==null?void 0:g.get(x);v=E(v,O==null?void 0:O.rect)}),v&&(b=[h.w/v.w,h.h/v.h],T=[h.x+h.w/2-(v.x+v.w/2),h.y+h.h/2-(v.y+v.h/2)],I=[v.x+v.w/2,v.y+v.h/2]),P=v}}if(s)for(const v of s){const x=o.get(v);if(x){const{toolsType:O}=x;let $=(c==null?void 0:c.getElementsByName(v))[0];if($){const B={...e};let G;if(O){if(G=g==null?void 0:g.get(v),G&&h){B.boxScale=b;const F=[G.rect.x+G.rect.w/2,G.rect.y+G.rect.h/2],Y=[F[0]-I[0],F[1]-I[1]];B.boxTranslate=[Y[0]*(b[0]-1)+T[0]+(n&&n[0]||0),Y[1]*(b[1]-1)+T[1]+(n&&n[1]||0)]}const gt=ne(O);if(gt==null||gt.updateNodeOpt({node:$,opt:B,vNodes:o,willSerializeData:i,targetNode:G}),x&&r&&(i&&(B.angle||B.translate)||B.box&&B.workState!==D.Start||B.pointMap&&B.pointMap.has(v)||O===k.Text&&(B.fontSize||B.translate||B.textInfos&&B.textInfos.get(v))||O===k.Image&&(B.angle||B.translate||B.boxScale)||O===B.toolsType&&B.willRefresh)){const F=r.createWorkShapeNode({workId:v,toolsType:O,toolsOpt:x.opt});F==null||F.setWorkId(v);let Y;if(O===k.Image&&a)Y=await F.consumeServiceAsync({isFullWork:!0,replaceId:v,scene:a,isMainThread:l});else if(O===k.Text)Y=await F.consumeServiceAsync({isFullWork:!0,replaceId:v});else try{Y=F==null?void 0:F.consumeService({op:x.op,isFullWork:!0,replaceId:v})}catch{continue}Y&&(x.rect=Y),$=(c==null?void 0:c.getElementsByName(v))[0]}x&&(d.set(v,x),p=E(p,x.rect))}}}}g&&w===D.Done&&(o.deleteLastTarget(),g=void 0);const N=p;if(P&&e.dir&&N&&!n){const v=[0,0];switch(e.dir){case"top":{const x=[P.x,P.y+P.h];e.reverseY?v[1]=x[1]-N.y:v[1]=x[1]-(N.y+N.h);break}case"topLeft":{const x=[P.x+P.w,P.y+P.h];e.reverseY?v[1]=x[1]-N.y:v[1]=x[1]-(N.y+N.h),e.reverseX?v[0]=x[0]-N.x:v[0]=x[0]-(N.x+N.w);break}case"topRight":{const x=[P.x,P.y+P.h];e.reverseY?v[1]=x[1]-N.y:v[1]=x[1]-(N.y+N.h),e.reverseX?v[0]=x[0]-(N.x+N.w):v[0]=x[0]-N.x;break}case"bottom":{const x=[P.x,P.y];e.reverseY?v[1]=x[1]-(N.y+N.h):v[1]=x[1]-N.y;break}case"bottomLeft":{const x=[P.x+P.w,P.y];e.reverseY?v[1]=x[1]-(N.y+N.h):v[1]=x[1]-N.y,e.reverseX?v[0]=x[0]-N.x:v[0]=x[0]-(N.x+N.w);break}case"bottomRight":{const x=[P.x,P.y];e.reverseY?v[1]=x[1]-(N.y+N.h):v[1]=x[1]-N.y,e.reverseX?v[0]=x[0]-(N.x+N.w):v[0]=x[0]-N.x;break}case"right":{const x=[P.x,P.y];e.reverseX?v[0]=x[0]-(N.x+N.w):v[0]=x[0]-N.x;break}}if(v[0]||v[1])return N.x=N.x+v[0],N.y=N.y+v[1],await this.updateSelector({...t,offset:v})}this.getSelecteorInfo(d),this.draw(nt.selectorId,c,{selectIds:s||[],subNodeMap:d,intersectRect:N});const M=E(this.oldSelectRect,N);return this.oldSelectRect=N,{type:f.Select,dataType:W.Local,selectRect:N,renderRect:p,rect:E(M,N),selectIds:s}}blurSelector(){const t=this.unSelectedAllIds();return{type:f.Select,dataType:W.Local,rect:t,selectIds:[],willSyncService:!0}}getRightServiceId(t){return t.replace(Mt,"-")}selectServiceNode(t,e,s){const{selectIds:o}=e,i=this.getRightServiceId(t),r=this.getSelectorRect(this.fullLayer,i);let n;const a=new Map;return o==null||o.forEach(l=>{const c=this.vNodes.get(l);c&&(n=E(n,c.rect),a.set(l,c))}),this.getSelecteorInfo(a),this.draw(i,this.fullLayer,{intersectRect:n,selectIds:o||[],subNodeMap:a},s),E(n,r)}reRenderSelector(){var t;let e;const s=new Map;return(t=this.selectIds)==null||t.forEach(o=>{const i=this.vNodes.get(o);i&&(e=E(e,i.rect),s.set(o,i))},this),this.getSelecteorInfo(s),this.draw(nt.selectorId,this.fullLayer,{intersectRect:e,subNodeMap:s,selectIds:this.selectIds||[]}),this.oldSelectRect=e,e}updateSelectIds(t){var e;let s;const o=(e=this.selectIds)==null?void 0:e.filter(r=>!t.includes(r));if(o!=null&&o.length&&(s=this.unSelectedByIds(o)),t.length){const r=this.selectedByIds(t);s=E(s,r)}this.selectIds=t;const i=this.reRenderSelector();return{bgRect:s,selectRect:i}}cursorHover(t){var e,s;const o=this.oldSelectRect;this.selectIds=[];const i=(e=this.workId)==null?void 0:e.toString(),r=[t[0]*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],t[1]*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[1]];if(this.selectSingleTool(r,i,!0),this.oldSelectRect&&!Lt(o,this.oldSelectRect))return{type:f.CursorHover,dataType:W.Local,rect:E(o,this.oldSelectRect),selectorColor:this.selectorColor,willSyncService:!1};if((s=this.selectIds)!=null&&s.length||(this.oldSelectRect=void 0),o&&!this.oldSelectRect)return this.cursorBlur(),{type:f.CursorHover,dataType:W.Local,rect:o,selectorColor:this.selectorColor,willSyncService:!1}}cursorBlur(){var t,e;this.selectIds=[];const s=(t=this.workId)==null?void 0:t.toString();((e=this.fullLayer)==null?void 0:e.parent).children.forEach(o=>{o.name===s&&o.remove()})}};u(Ot,"selectorId",X),u(Ot,"selectorBorderId","selector-border");let K=Ot;class Kt extends L{constructor(t){super(t),u(this,"canRotate",!1),u(this,"scaleType",U.both),u(this,"toolsType",k.Arrow),u(this,"tmpPoints",[]),u(this,"workOptions"),u(this,"oldRect"),u(this,"arrowTipWidth"),u(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.arrowTipWidth=this.workOptions.thickness*4,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){const{data:e,isFullWork:s,isSubWorker:o,isMainThread:i}=t,r=this.workId,{op:n}=e,a=n==null?void 0:n.length;if(!a||a<2)return{type:f.None};let l;if(this.tmpPoints.length===0?(this.tmpPoints=[new C(n[0],n[1])],l=!1):l=this.updateTempPoints(n),!l)return{type:f.None};let c;if(o||i){const d=s?this.fullLayer:this.drawLayer||this.fullLayer;c=this.draw({workId:r,layer:d})}if(!o){const d=Date.now();return d-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=d,{...this.baseConsumeResult,type:f.DrawWork,dataType:W.Local,op:this.tmpPoints.map(h=>[...h.XY,0]).flat(1),isSync:!0,index:0}):{type:f.None}}const p=E(c,this.oldRect);return this.oldRect=c,{rect:p,...this.baseConsumeResult,type:f.DrawWork,dataType:W.Local}}consumeAll(){var t;const e=this.workId;if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[e]};const s=this.fullLayer,o=this.draw({workId:e,layer:s});this.oldRect=o;const i=this.tmpPoints.map(n=>[...n.XY,0]).flat(1),r=Q(i);return(t=this.vNodes)==null||t.setInfo(e,{rect:o,op:i,opt:this.workOptions,toolsType:this.toolsType,canRotate:this.canRotate,scaleType:this.scaleType,centerPos:L.getCenterPos(o,s)}),{rect:o,...this.baseConsumeResult,type:f.FullWork,dataType:W.Local,ops:r,isSync:!0}}draw(t){const{workId:e,layer:s}=t,{strokeColor:o,thickness:i,zIndex:r,scale:n,rotate:a,translate:l}=this.workOptions,c=s.worldPosition,p=s.worldScaling,{points:d,rect:h}=this.computDrawPoints(i),w={pos:[h.x+h.w/2,h.y+h.h/2],name:e,id:e,close:!0,points:d,fillColor:o,strokeColor:o,lineWidth:0,normalize:!0,zIndex:r};n&&(w.scale=n),a&&(w.rotate=a),l&&(w.translate=l);const y=new at(w);if(this.replace(s,e,y),n||a||l){const m=y.getBoundingClientRect();return{x:Math.floor(m.x-L.SafeBorderPadding),y:Math.floor(m.y-L.SafeBorderPadding),w:Math.floor(m.width+L.SafeBorderPadding*2),h:Math.floor(m.height+L.SafeBorderPadding*2)}}return{x:Math.floor(h.x*p[0]+c[0]-L.SafeBorderPadding),y:Math.floor(h.y*p[1]+c[1]-L.SafeBorderPadding),w:Math.floor(h.w*p[0]+2*L.SafeBorderPadding),h:Math.floor(h.h*p[1]+2*L.SafeBorderPadding)}}computDrawPoints(t){return this.tmpPoints[1].distance(this.tmpPoints[0])>this.arrowTipWidth?this.computFullArrowPoints(t):this.computTrianglePoints()}computFullArrowPoints(t){const e=S.Sub(this.tmpPoints[1],this.tmpPoints[0]).uni(),s=S.Per(e).mul(t/2),o=C.Sub(this.tmpPoints[0],s),i=C.Add(this.tmpPoints[0],s),r=S.Mul(e,this.arrowTipWidth),n=S.Sub(this.tmpPoints[1],r),a=C.Sub(n,s),l=C.Add(n,s),c=S.Per(e).mul(t*1.5),p=C.Sub(n,c),d=C.Add(n,c),h=[o,a,p,this.tmpPoints[1],d,l,i];return{points:h.map(w=>C.Sub(w,this.tmpPoints[0]).XY).flat(1),rect:z(h),isTriangle:!1,pos:this.tmpPoints[0].XY}}computTrianglePoints(){const t=S.Sub(this.tmpPoints[1],this.tmpPoints[0]).uni(),e=this.tmpPoints[1].distance(this.tmpPoints[0]),s=S.Per(t).mul(Math.floor(e*3/8)),o=C.Sub(this.tmpPoints[0],s),i=C.Add(this.tmpPoints[0],s),r=[o,this.tmpPoints[1],i];return{points:r.map(n=>C.Sub(n,this.tmpPoints[0]).XY).flat(1),rect:z(r),isTriangle:!0,pos:this.tmpPoints[0].XY}}updateTempPoints(t){const e=t.slice(-2),s=new C(e[0],e[1]),o=this.tmpPoints[0],{thickness:i}=this.workOptions;if(o.isNear(s,i))return!1;if(this.tmpPoints.length===2){if(s.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=s}else this.tmpPoints.push(s);return!0}consumeService(t){var e,s;const{op:o,isFullWork:i}=t,r=(e=this.workId)==null?void 0:e.toString();if(!r)return;this.tmpPoints.length=0;for(let l=0;l<o.length;l+=3)this.tmpPoints.push(new C(o[l],o[l+1],o[l+2]));const n=i?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:r,layer:n});return this.oldRect=a,(s=this.vNodes)==null||s.setInfo(r,{rect:a,op:o,opt:this.workOptions,toolsType:this.toolsType,canRotate:this.canRotate,scaleType:this.scaleType,centerPos:L.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){var e;const{node:s,opt:o,vNodes:i}=t,{strokeColor:r}=o,n=i.get(s.name);return r&&(s.setAttribute("strokeColor",r),s.setAttribute("fillColor",r),(e=n==null?void 0:n.opt)!=null&&e.strokeColor&&(n.opt.strokeColor=r),n&&i.setInfo(s.name,n)),L.updateNodeOpt(t)}}class _t extends L{constructor(t){super(t),u(this,"canRotate",!1),u(this,"scaleType",U.all),u(this,"toolsType",k.Ellipse),u(this,"tmpPoints",[]),u(this,"workOptions"),u(this,"oldRect"),u(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){const{data:e,isFullWork:s,isSubWorker:o,isMainThread:i}=t,r=this.workId,{op:n}=e,a=n==null?void 0:n.length;if(!a||a<2)return{type:f.None};let l;if(this.tmpPoints.length===0?(this.tmpPoints=[new C(n[0],n[1])],l=!1):l=this.updateTempPoints(n),!l)return{type:f.None};let c;if(o||i){const d=s?this.fullLayer:this.drawLayer||this.fullLayer;c=this.draw({workId:r,layer:d,isDrawing:!0})}if(!o){const d=Date.now();return d-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=d,{type:f.DrawWork,dataType:W.Local,...this.baseConsumeResult,op:this.tmpPoints.map(h=>[...h.XY,0]).flat(1),isSync:!0,index:0}):{type:f.None}}const p=E(c,this.oldRect);return this.oldRect=c,{rect:p,type:f.DrawWork,dataType:W.Local,...this.baseConsumeResult}}consumeAll(){var t;const e=this.workId;if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[e]};const s=this.fullLayer,o=this.draw({workId:e,layer:s,isDrawing:!1});this.oldRect=o;const i=this.tmpPoints.map(n=>[...n.XY,0]).flat(1),r=Q(i);return(t=this.vNodes)==null||t.setInfo(e,{rect:o,op:i,opt:this.workOptions,toolsType:this.toolsType,canRotate:this.canRotate,scaleType:this.scaleType,centerPos:o&&L.getCenterPos(o,s)}),{rect:o,type:f.FullWork,dataType:W.Local,...this.baseConsumeResult,ops:r,isSync:!0}}draw(t){const{workId:e,layer:s,isDrawing:o}=t,{strokeColor:i,fillColor:r,thickness:n,zIndex:a,scale:l,rotate:c,translate:p}=this.workOptions,d=s.worldScaling,{radius:h,rect:w,pos:y}=this.computDrawPoints(n),m={pos:y,name:e,id:e,radius:h,lineWidth:n,fillColor:r!=="transparent"&&r||void 0,strokeColor:i,normalize:!0},T={name:e,id:e,zIndex:a,pos:y,anchor:[.5,.5],size:[w.w,w.h]};l&&(T.scale=l),c&&(T.rotate=c),p&&(T.translate=p);const b=new J(T);if(o){const P=new lt({d:"M-4,0H4M0,-4V4",normalize:!0,pos:[0,0],strokeColor:i,lineWidth:1,scale:[1/d[0],1/d[1]]});b.append(P)}const I=new Se({...m,pos:[0,0]});b.append(I),this.replace(s,e,b);const g=b.getBoundingClientRect();return{x:Math.floor(g.x-L.SafeBorderPadding),y:Math.floor(g.y-L.SafeBorderPadding),w:Math.floor(g.width+L.SafeBorderPadding*2),h:Math.floor(g.height+L.SafeBorderPadding*2)}}computDrawPoints(t){const e=z(this.tmpPoints),s=z(this.tmpPoints,t),o=[Math.floor(e.x+e.w/2),Math.floor(e.y+e.h/2)];return{rect:s,pos:o,radius:[Math.floor(e.w/2),Math.floor(e.h/2)]}}updateTempPoints(t){const e=t.slice(-2),s=new C(e[0],e[1]),o=this.tmpPoints[0],{thickness:i}=this.workOptions;if(o.isNear(s,i))return!1;if(this.tmpPoints.length===2){if(s.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=s}else this.tmpPoints.push(s);return!0}consumeService(t){var e,s;const{op:o,isFullWork:i}=t,r=(e=this.workId)==null?void 0:e.toString();if(!r)return;this.tmpPoints.length=0;for(let l=0;l<o.length;l+=3)this.tmpPoints.push(new C(o[l],o[l+1],o[l+2]));const n=i?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:r,layer:n,isDrawing:!1});return this.oldRect=a,(s=this.vNodes)==null||s.setInfo(r,{rect:a,op:o,opt:this.workOptions,toolsType:this.toolsType,canRotate:this.canRotate,scaleType:this.scaleType,centerPos:L.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){var e,s;const{node:o,opt:i,vNodes:r}=t,{strokeColor:n,fillColor:a}=i,l=r.get(o.name);let c=o;return o.tagName==="GROUP"&&(c=o.children[0]),n&&(c.setAttribute("strokeColor",n),(e=l==null?void 0:l.opt)!=null&&e.strokeColor&&(l.opt.strokeColor=n)),a&&(a==="transparent"?c.setAttribute("fillColor","rgba(0,0,0,0)"):c.setAttribute("fillColor",a),(s=l==null?void 0:l.opt)!=null&&s.fillColor&&(l.opt.fillColor=a)),l&&r.setInfo(o.name,l),L.updateNodeOpt(t)}}class te extends L{constructor(t){super(t),u(this,"canRotate",!0),u(this,"scaleType",U.all),u(this,"toolsType",k.Rectangle),u(this,"tmpPoints",[]),u(this,"workOptions"),u(this,"oldRect"),u(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}transformData(){const t=z(this.tmpPoints);return[[t.x,t.y,0],[t.x+t.w,t.y,0],[t.x+t.w,t.y+t.h,0],[t.x,t.y+t.h,0]]}computDrawPoints(t){const{thickness:e}=this.workOptions,s=[];for(const r of t)s.push(new S(...r));const o=z(s,e),i=[o.x+o.w/2,o.y+o.h/2];return{rect:o,pos:i,points:s.map(r=>r.XY).flat(1)}}consume(t){const{data:e,isFullWork:s,isSubWorker:o,isMainThread:i}=t,r=this.workId,{op:n}=e,a=n==null?void 0:n.length;if(!a||a<2)return{type:f.None};let l;if(this.tmpPoints.length===0?(this.tmpPoints=[new C(n[0],n[1])],l=!1):l=this.updateTempPoints(n),!l)return{type:f.None};const c=this.transformData();let p;if(o||i){const h=s?this.fullLayer:this.drawLayer||this.fullLayer;p=this.draw({ps:c,workId:r,layer:h,isDrawing:!0})}if(!o){const h=Date.now();return h-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=h,{type:f.DrawWork,dataType:W.Local,op:c.flat(1),isSync:!0,index:0,...this.baseConsumeResult}):{type:f.None}}const d=E(p,this.oldRect);return this.oldRect=p,{rect:d,type:f.DrawWork,dataType:W.Local,...this.baseConsumeResult}}consumeAll(){var t;const e=this.workId;if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[e]};const s=this.transformData(),o=this.fullLayer,i=this.draw({ps:s,workId:e,layer:o,isDrawing:!1});this.oldRect=i;const r=s.flat(1),n=Q(r);return(t=this.vNodes)==null||t.setInfo(e,{rect:i,op:r,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:i&&L.getCenterPos(i,o)}),{rect:i,type:f.FullWork,dataType:W.Local,ops:n,isSync:!0,...this.baseConsumeResult}}draw(t){const{workId:e,layer:s,isDrawing:o,ps:i,replaceId:r}=t,{strokeColor:n,fillColor:a,thickness:l,zIndex:c,scale:p,rotate:d,translate:h,textOpt:w}=this.workOptions,y=s.worldPosition,m=s.worldScaling,{points:T,rect:b,pos:I}=this.computDrawPoints(i),g={close:!0,normalize:!0,points:T,lineWidth:l,fillColor:a!=="transparent"&&a||void 0,strokeColor:n,lineJoin:"round"},P={x:Math.floor(b.x*m[0]+y[0]-L.SafeBorderPadding),y:Math.floor(b.y*m[1]+y[1]-L.SafeBorderPadding),w:Math.floor(b.w*m[0]+2*L.SafeBorderPadding),h:Math.floor(b.h*m[0]+2*L.SafeBorderPadding)},N=new J({name:e,id:e,zIndex:c,pos:I,anchor:[.5,.5],size:[b.w,b.h],scale:p,rotate:d,translate:h}),M=new at({...g,pos:[0,0]});if(N.appendChild(M),o){const v=new lt({d:"M-4,0H4M0,-4V4",normalize:!0,pos:[0,0],strokeColor:n,lineWidth:1,scale:[1/m[0],1/m[1]]});N.appendChild(v)}if(this.replace(s,r||e,N),p||d||h){const v=N.getBoundingClientRect();return{x:Math.floor(v.x-L.SafeBorderPadding),y:Math.floor(v.y-L.SafeBorderPadding),w:Math.floor(v.width+2*L.SafeBorderPadding),h:Math.floor(v.height+2*L.SafeBorderPadding)}}return P}updateTempPoints(t){const e=t.slice(-2),s=new C(e[0],e[1]),o=this.tmpPoints[0],{thickness:i}=this.workOptions;if(o.isNear(s,i))return!1;if(this.tmpPoints.length===2){if(s.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=s}else this.tmpPoints.push(s);return!0}consumeService(t){var e,s;const{op:o,isFullWork:i,replaceId:r}=t,n=(e=this.workId)==null?void 0:e.toString();if(!n)return;const a=[];for(let p=0;p<o.length;p+=3)a.push([o[p],o[p+1],o[p+2]]);const l=i?this.fullLayer:this.drawLayer||this.fullLayer,c=this.draw({ps:a,workId:n,layer:l,isDrawing:!1,replaceId:r});return this.oldRect=c,(s=this.vNodes)==null||s.setInfo(n,{rect:c,op:o,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:c&&L.getCenterPos(c,l)}),c}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){var e,s;const{node:o,opt:i,vNodes:r}=t,{strokeColor:n,fillColor:a,fontColor:l,fontBgColor:c,bold:p,italic:d,lineThrough:h,underline:w,fontSize:y}=i,m=r.get(o.name);let T=o;if(o.tagName==="GROUP"&&(T=o.children[0]),n&&(T.setAttribute("strokeColor",n),(e=m==null?void 0:m.opt)!=null&&e.strokeColor&&(m.opt.strokeColor=n)),a&&(a==="transparent"?T.setAttribute("fillColor","rgba(0,0,0,0)"):T.setAttribute("fillColor",a),(s=m==null?void 0:m.opt)!=null&&s.fillColor&&(m.opt.fillColor=a)),m!=null&&m.opt.textOpt){const b=m.opt.textOpt;l&&b.fontColor&&(b.fontColor=l),c&&b.fontBgColor&&(b.fontBgColor=c),p&&(b.bold=p),d&&(b.italic=d),rt(h)&&(b.lineThrough=h),rt(w)&&(b.underline=w),y&&(b.fontSize=y)}return m&&r.setInfo(o.name,m),L.updateNodeOpt(t)}}class ee extends L{constructor(t){super(t),u(this,"canRotate",!1),u(this,"scaleType",U.all),u(this,"toolsType",k.Star),u(this,"tmpPoints",[]),u(this,"workOptions"),u(this,"oldRect"),u(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){const{data:e,isFullWork:s,isSubWorker:o,isMainThread:i}=t,r=this.workId,{op:n}=e,a=n==null?void 0:n.length;if(!a||a<2)return{type:f.None};let l;if(this.tmpPoints.length===0?(this.tmpPoints=[new C(n[0],n[1])],l=!1):l=this.updateTempPoints(n),!l)return{type:f.None};let c;if(o||i){const d=s?this.fullLayer:this.drawLayer||this.fullLayer;c=this.draw({workId:r,layer:d,isDrawing:!0})}if(!o){const d=Date.now();return d-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=d,{type:f.DrawWork,dataType:W.Local,op:this.tmpPoints.map(h=>[...h.XY,0]).flat(1),isSync:!0,index:0,...this.baseConsumeResult}):{type:f.None}}const p=E(c,this.oldRect);return this.oldRect=c,{rect:p,type:f.DrawWork,dataType:W.Local,...this.baseConsumeResult}}consumeAll(){var t;const e=this.workId;if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[e]};const s=this.fullLayer,o=this.draw({workId:e,layer:s,isDrawing:!1});this.oldRect=o;const i=this.tmpPoints.map(n=>[...n.XY,0]).flat(1),r=Q(i);return(t=this.vNodes)==null||t.setInfo(e,{rect:o,op:i,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:o&&L.getCenterPos(o,s)}),{rect:o,type:f.FullWork,dataType:W.Local,ops:r,isSync:!0,...this.baseConsumeResult}}draw(t){const{workId:e,layer:s,isDrawing:o}=t,{strokeColor:i,fillColor:r,thickness:n,zIndex:a,vertices:l,innerVerticeStep:c,innerRatio:p,scale:d,rotate:h,translate:w}=this.workOptions,y=s.worldScaling,{rect:m,pos:T,points:b}=this.computDrawPoints(n,l,c,p),I={close:!0,points:b,lineWidth:n,fillColor:r!=="transparent"&&r||void 0,strokeColor:i,normalize:!0,lineJoin:"round"},g={name:e,id:e,zIndex:a,pos:T,anchor:[.5,.5],size:[m.w,m.h],className:`${T[0]},${T[1]}`};d&&(g.scale=d),h&&(g.rotate=h),w&&(g.translate=w);const P=new J(g);if(o){const v=new lt({d:"M-4,0H4M0,-4V4",normalize:!0,pos:[0,0],strokeColor:i,lineWidth:1,scale:[1/y[0],1/y[1]]});P.append(v)}const N=new at({...I,pos:[0,0]});P.append(N),this.replace(s,e,P);const M=P.getBoundingClientRect();return{x:Math.floor(M.x-L.SafeBorderPadding),y:Math.floor(M.y-L.SafeBorderPadding),w:Math.floor(M.width+L.SafeBorderPadding*2),h:Math.floor(M.height+L.SafeBorderPadding*2)}}computDrawPoints(t,e,s,o){const i=z(this.tmpPoints),r=[Math.floor(i.x+i.w/2),Math.floor(i.y+i.h/2)],n=jt(i.w,i.h),a=Math.floor(Math.min(i.w,i.h)/2),l=o*a,c=[],p=2*Math.PI/e;for(let d=0;d<e;d++){const h=d*p-.5*Math.PI;let w,y;d%s===1?(w=l*n[0]*Math.cos(h),y=l*n[1]*Math.sin(h)):(w=a*n[0]*Math.cos(h),y=a*n[1]*Math.sin(h),c.push(w,y)),c.push(w,y)}return{rect:z(this.tmpPoints,t),pos:r,points:c}}updateTempPoints(t){const e=t.slice(-2),s=new C(e[0],e[1]),o=this.tmpPoints[0],{thickness:i}=this.workOptions;if(o.isNear(s,i)||C.Sub(o,s).XY.includes(0))return!1;if(this.tmpPoints.length===2){if(s.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=s}else this.tmpPoints.push(s);return!0}consumeService(t){var e,s;const{op:o,isFullWork:i}=t,r=(e=this.workId)==null?void 0:e.toString();if(!r)return;this.tmpPoints.length=0;for(let l=0;l<o.length;l+=3)this.tmpPoints.push(new C(o[l],o[l+1],o[l+2]));const n=i?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:r,layer:n,isDrawing:!1});return this.oldRect=a,(s=this.vNodes)==null||s.setInfo(r,{rect:a,op:o,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&L.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){const{node:e,opt:s,vNodes:o}=t,{strokeColor:i,fillColor:r,toolsType:n,vertices:a,innerVerticeStep:l,innerRatio:c}=s,p=o.get(e.name),d=p==null?void 0:p.opt;let h=e;return e.tagName==="GROUP"&&(h=e.children[0]),i&&(h.setAttribute("strokeColor",i),d!=null&&d.strokeColor&&(d.strokeColor=i)),r&&(r==="transparent"?h.setAttribute("fillColor","rgba(0,0,0,0)"):h.setAttribute("fillColor",r),d!=null&&d.fillColor&&(d.fillColor=r)),n===k.Star&&(a&&(d.vertices=a),l&&(d.innerVerticeStep=l),c&&(d.innerRatio=c)),p&&o.setInfo(e.name,{...p,opt:d}),L.updateNodeOpt(t)}}class se extends L{constructor(t){super(t),u(this,"canRotate",!1),u(this,"scaleType",U.all),u(this,"toolsType",k.Polygon),u(this,"tmpPoints",[]),u(this,"workOptions"),u(this,"oldRect"),u(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){const{data:e,isFullWork:s,isSubWorker:o,isMainThread:i}=t,{op:r}=e,n=this.workId,a=r==null?void 0:r.length;if(!a||a<2)return{type:f.None};let l;if(this.tmpPoints.length===0?(this.tmpPoints=[new C(r[0],r[1])],l=!1):l=this.updateTempPoints(r),!l)return{type:f.None};let c;if(o||i){const d=s?this.fullLayer:this.drawLayer||this.fullLayer;c=this.draw({workId:n,layer:d,isDrawing:!0})}if(!o){const d=Date.now();return d-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=d,{type:f.DrawWork,dataType:W.Local,op:this.tmpPoints.map(h=>[...h.XY,0]).flat(1),isSync:!0,index:0,...this.baseConsumeResult}):{type:f.None}}const p=E(c,this.oldRect);return this.oldRect=c,{rect:p,type:f.DrawWork,dataType:W.Local,...this.baseConsumeResult}}consumeAll(){var t;const e=this.workId;if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[e]};const s=this.fullLayer,o=this.draw({workId:e,layer:s,isDrawing:!1});this.oldRect=o;const i=this.tmpPoints.map(n=>[...n.XY,0]).flat(1),r=Q(i);return(t=this.vNodes)==null||t.setInfo(e,{rect:o,op:i,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:o&&L.getCenterPos(o,s)}),{rect:o,type:f.FullWork,dataType:W.Local,ops:r,isSync:!0,...this.baseConsumeResult}}draw(t){const{workId:e,layer:s,isDrawing:o}=t,{strokeColor:i,fillColor:r,thickness:n,zIndex:a,vertices:l,scale:c,rotate:p,translate:d}=this.workOptions,h=s.worldScaling,{rect:w,pos:y,points:m}=this.computDrawPoints(n,l),T={close:!0,points:m,lineWidth:n,fillColor:r!=="transparent"&&r||void 0,strokeColor:i,normalize:!0,lineJoin:"round"},b={name:e,id:e,zIndex:a,pos:y,anchor:[.5,.5],size:[w.w,w.h]};c&&(b.scale=c),p&&(b.rotate=p),d&&(b.translate=d);const I=new J(b);if(o){const N=new lt({d:"M-4,0H4M0,-4V4",normalize:!0,pos:[0,0],strokeColor:i,lineWidth:1,scale:[1/h[0],1/h[1]]});I.append(N)}const g=new at({...T,pos:[0,0]});I.append(g),this.replace(s,e,I);const P=I.getBoundingClientRect();return{x:Math.floor(P.x-L.SafeBorderPadding),y:Math.floor(P.y-L.SafeBorderPadding),w:Math.floor(P.width+L.SafeBorderPadding*2),h:Math.floor(P.height+L.SafeBorderPadding*2)}}computDrawPoints(t,e){const s=z(this.tmpPoints),o=[Math.floor(s.x+s.w/2),Math.floor(s.y+s.h/2)],i=jt(s.w,s.h),r=Math.floor(Math.min(s.w,s.h)/2),n=[],a=2*Math.PI/e;for(let l=0;l<e;l++){const c=l*a-.5*Math.PI,p=r*i[0]*Math.cos(c),d=r*i[1]*Math.sin(c);n.push(p,d)}return{rect:z(this.tmpPoints,t),pos:o,points:n}}updateTempPoints(t){const e=t.slice(-2),s=new C(e[0],e[1]),o=this.tmpPoints[0],{thickness:i}=this.workOptions;if(o.isNear(s,i)||C.Sub(o,s).XY.includes(0))return!1;if(this.tmpPoints.length===2){if(s.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=s}else this.tmpPoints.push(s);return!0}consumeService(t){var e,s;const{op:o,isFullWork:i}=t,r=(e=this.workId)==null?void 0:e.toString();if(!r)return;this.tmpPoints.length=0;for(let l=0;l<o.length;l+=3)this.tmpPoints.push(new C(o[l],o[l+1],o[l+2]));const n=i?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:r,layer:n,isDrawing:!1});return this.oldRect=a,(s=this.vNodes)==null||s.setInfo(r,{rect:a,op:o,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&L.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){const{node:e,opt:s,vNodes:o}=t,{strokeColor:i,fillColor:r,toolsType:n,vertices:a}=s,l=o.get(e.name),c=l==null?void 0:l.opt;let p=e;return e.tagName==="GROUP"&&(p=e.children[0]),i&&(p.setAttribute("strokeColor",i),c!=null&&c.strokeColor&&(c.strokeColor=i)),r&&(r==="transparent"?p.setAttribute("fillColor","rgba(0,0,0,0)"):p.setAttribute("fillColor",r),c!=null&&c.fillColor&&(c.fillColor=r)),n===k.Polygon&&a&&(c.vertices=a),l&&o.setInfo(e.name,{...l,opt:c}),L.updateNodeOpt(t)}}class V{static bezier(t,e){const s=[];for(let o=0;o<e.length;o+=4){const i=e[o],r=e[o+1],n=e[o+2],a=e[o+3];i&&r&&n&&a?s.push(...V.getBezierPoints(t,i,r,n,a)):i&&r&&n?s.push(...V.getBezierPoints(t,i,r,n)):i&&r?s.push(...V.getBezierPoints(t,i,r)):i&&s.push(i)}return s}static getBezierPoints(t=10,e,s,o,i){let r=null;const n=[];!o&&!i?r=V.oneBezier:o&&!i?r=V.twoBezier:o&&i&&(r=V.threeBezier);for(let a=0;a<t;a++)r&&n.push(r(a/t,e,s,o,i));return i?n.push(i):o&&n.push(o),n}static oneBezier(t,e,s){const o=e.x+(s.x-e.x)*t,i=e.y+(s.y-e.y)*t;return new S(o,i)}static twoBezier(t,e,s,o){const i=(1-t)*(1-t)*e.x+2*t*(1-t)*s.x+t*t*o.x,r=(1-t)*(1-t)*e.y+2*t*(1-t)*s.y+t*t*o.y;return new S(i,r)}static threeBezier(t,e,s,o,i){const r=e.x*(1-t)*(1-t)*(1-t)+3*s.x*t*(1-t)*(1-t)+3*o.x*t*t*(1-t)+i.x*t*t*t,n=e.y*(1-t)*(1-t)*(1-t)+3*s.y*t*(1-t)*(1-t)+3*o.y*t*t*(1-t)+i.y*t*t*t;return new S(r,n)}}class oe extends L{constructor(t){super(t),u(this,"canRotate",!1),u(this,"scaleType",U.all),u(this,"toolsType",k.SpeechBalloon),u(this,"ratio",.8),u(this,"tmpPoints",[]),u(this,"workOptions"),u(this,"oldRect"),u(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){var e;const{data:s,isFullWork:o,isSubWorker:i,isMainThread:r}=t,n=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a}=s,l=a==null?void 0:a.length;if(!l||l<2)return{type:f.None};let c;if(this.tmpPoints.length===0?(this.tmpPoints=[new C(a[0],a[1])],c=!1):c=this.updateTempPoints(a),!c)return{type:f.None};let p;if(i||r){const h=o?this.fullLayer:this.drawLayer||this.fullLayer;p=this.draw({workId:n,layer:h,isDrawing:!0})}if(!i){const h=Date.now();return h-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=h,{type:f.DrawWork,dataType:W.Local,op:this.tmpPoints.map(w=>[...w.XY,0]).flat(1),isSync:!0,index:0,...this.baseConsumeResult}):{type:f.None}}const d=E(p,this.oldRect);return this.oldRect=p,{rect:d,type:f.DrawWork,dataType:W.Local,...this.baseConsumeResult}}consumeAll(){var t;const e=this.workId;if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[e]};const s=this.fullLayer,o=this.draw({workId:e,layer:s,isDrawing:!1});this.oldRect=o;const i=this.tmpPoints.map(n=>[...n.XY,0]).flat(1),r=Q(i);return(t=this.vNodes)==null||t.setInfo(e,{rect:o,op:i,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:o&&L.getCenterPos(o,s)}),{rect:o,type:f.FullWork,dataType:W.Local,ops:r,isSync:!0,...this.baseConsumeResult}}draw(t){const{workId:e,layer:s}=t,{strokeColor:o,fillColor:i,thickness:r,zIndex:n,placement:a,scale:l,rotate:c,translate:p}=this.workOptions,{rect:d,pos:h,points:w}=this.computDrawPoints(r,a),y={points:w.map(g=>g.XY),lineWidth:r,fillColor:i!=="transparent"&&i||void 0,strokeColor:o,normalize:!0,className:`${h[0]},${h[1]}`,lineJoin:"round",close:!0},m={name:e,id:e,zIndex:n,pos:h,anchor:[.5,.5],size:[d.w,d.h]};l&&(m.scale=l),c&&(m.rotate=c),p&&(m.translate=p);const T=new J(m),b=new at({...y,pos:[0,0]});T.append(b),this.replace(s,e,T);const I=T.getBoundingClientRect();return{x:Math.floor(I.x-L.SafeBorderPadding),y:Math.floor(I.y-L.SafeBorderPadding),w:Math.floor(I.width+L.SafeBorderPadding*2),h:Math.floor(I.height+L.SafeBorderPadding*2)}}transformControlPoints(t){const e=z(this.tmpPoints);switch(t){case"bottom":case"bottomLeft":case"bottomRight":{const s=e.y+e.h*this.ratio;return[new S(e.x,e.y,0),new S(e.x+e.w,e.y,0),new S(e.x+e.w,s,0),new S(e.x,s,0)]}case"top":case"topLeft":case"topRight":{const s=e.y+e.h*(1-this.ratio);return[new S(e.x,s,0),new S(e.x+e.w,s,0),new S(e.x+e.w,e.y+e.h,0),new S(e.x,e.y+e.h,0)]}case"left":case"leftBottom":case"leftTop":{const s=e.x+e.w*(1-this.ratio);return[new S(s,e.y,0),new S(e.x+e.w,e.y,0),new S(e.x+e.w,e.y+e.h,0),new S(s,e.y+e.h,0)]}case"right":case"rightBottom":case"rightTop":{const s=e.x+e.w*this.ratio;return[new S(e.x,e.y,0),new S(s,e.y,0),new S(s,e.y+e.h,0),new S(e.x,e.y+e.h,0)]}}}computDrawPoints(t,e){const s=z(this.tmpPoints),o=this.transformControlPoints(e),i=Math.floor(s.w*.1),r=Math.floor(s.h*.1),n=[],a=S.Add(o[0],new S(0,r,0)),l=S.Add(o[0],new S(i,0,0)),c=V.getBezierPoints(10,a,o[0],l),p=S.Sub(o[1],new S(i,0,0)),d=S.Add(o[1],new S(0,r,0)),h=V.getBezierPoints(10,p,o[1],d),w=S.Sub(o[2],new S(0,r,0)),y=S.Sub(o[2],new S(i,0,0)),m=V.getBezierPoints(10,w,o[2],y),T=S.Add(o[3],new S(i,0,0)),b=S.Sub(o[3],new S(0,r,0)),I=V.getBezierPoints(10,T,o[3],b),g=i*(1-this.ratio)*10,P=r*(1-this.ratio)*10;switch(e){case"bottom":{const v=S.Sub(o[2],new S(i*5-g/2,0,0)),x=S.Sub(o[2],new S(i*5,-P,0)),O=S.Sub(o[2],new S(i*5+g/2,0,0));n.push(x,O,...I,...c,...h,...m,v);break}case"bottomRight":{const v=S.Sub(o[2],new S(i*1.1,0,0)),x=S.Sub(o[2],new S(i*1.1+g/2,-P,0)),O=S.Sub(o[2],new S(i*1.1+g,0,0));n.push(x,O,...I,...c,...h,...m,v);break}case"bottomLeft":{const v=S.Add(o[3],new S(i*1.1+g,0,0)),x=S.Add(o[3],new S(i*1.1+g/2,P,0)),O=S.Add(o[3],new S(i*1.1,0,0));n.push(x,O,...I,...c,...h,...m,v);break}case"top":{const v=S.Sub(o[1],new S(i*5-g/2,0,0)),x=S.Sub(o[1],new S(i*5,P,0)),O=S.Sub(o[1],new S(i*5+g/2,0,0));n.push(x,v,...h,...m,...I,...c,O);break}case"topRight":{const v=S.Sub(o[1],new S(i*1.1,0,0)),x=S.Sub(o[1],new S(i*1.1+g/2,P,0)),O=S.Sub(o[1],new S(i*1.1+g,0,0));n.push(x,v,...h,...m,...I,...c,O);break}case"topLeft":{const v=S.Add(o[0],new S(i*1.1+g,0,0)),x=S.Add(o[0],new S(i*1.1+g/2,-P,0)),O=S.Add(o[0],new S(i*1.1,0,0));n.push(x,v,...h,...m,...I,...c,O);break}case"left":{const v=S.Add(o[0],new S(0,r*5-P/2,0)),x=S.Add(o[0],new S(-g,r*5,0)),O=S.Add(o[0],new S(0,r*5+P/2,0));n.push(x,v,...c,...h,...m,...I,O);break}case"leftTop":{const v=S.Add(o[0],new S(0,r*1.1,0)),x=S.Add(o[0],new S(-g,r*1.1+P/2,0)),O=S.Add(o[0],new S(0,r*1.1+P,0));n.push(x,v,...c,...h,...m,...I,O);break}case"leftBottom":{const v=S.Sub(o[3],new S(0,r*1.1+P,0)),x=S.Sub(o[3],new S(g,r*1.1+P/2,0)),O=S.Sub(o[3],new S(0,r*1.1,0));n.push(x,v,...c,...h,...m,...I,O);break}case"right":{const v=S.Add(o[1],new S(0,r*5-P/2,0)),x=S.Add(o[1],new S(g,r*5,0)),O=S.Add(o[1],new S(0,r*5+P/2,0));n.push(x,O,...m,...I,...c,...h,v);break}case"rightTop":{const v=S.Add(o[1],new S(0,r*1.1,0)),x=S.Add(o[1],new S(g,r*1.1+P/2,0)),O=S.Add(o[1],new S(0,r*1.1+P,0));n.push(x,O,...m,...I,...c,...h,v);break}case"rightBottom":{const v=S.Sub(o[2],new S(0,r*1.1+P,0)),x=S.Sub(o[2],new S(-g,r*1.1+P/2,0)),O=S.Sub(o[2],new S(0,r*1.1,0));n.push(x,O,...m,...I,...c,...h,v);break}}const N=z(this.tmpPoints,t),M=[Math.floor(N.x+N.w/2),Math.floor(N.y+N.h/2)];return{rect:N,pos:M,points:n}}updateTempPoints(t){const e=t.slice(-2),s=new C(e[0],e[1]),o=this.tmpPoints[0],{thickness:i}=this.workOptions;if(o.isNear(s,i)||C.Sub(o,s).XY.includes(0))return!1;if(this.tmpPoints.length===2){if(s.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=s}else this.tmpPoints.push(s);return!0}consumeService(t){var e,s;const{op:o,isFullWork:i}=t,r=(e=this.workId)==null?void 0:e.toString();if(!r)return;this.tmpPoints.length=0;for(let l=0;l<o.length;l+=3)this.tmpPoints.push(new C(o[l],o[l+1],o[l+2]));const n=i?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:r,layer:n,isDrawing:!1});return this.oldRect=a,(s=this.vNodes)==null||s.setInfo(r,{rect:a,op:o,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&L.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){const{node:e,opt:s,vNodes:o}=t,{strokeColor:i,fillColor:r,toolsType:n,placement:a}=s,l=o.get(e.name),c=l==null?void 0:l.opt;let p=e;return e.tagName==="GROUP"&&(p=e.children[0]),i&&(p.setAttribute("strokeColor",i),c!=null&&c.strokeColor&&(c.strokeColor=i)),r&&(r==="transparent"?p.setAttribute("fillColor","rgba(0,0,0,0)"):p.setAttribute("fillColor",r),c!=null&&c.fillColor&&(c.fillColor=r)),n===k.SpeechBalloon&&a&&(c.placement=a),l&&o.setInfo(e.name,{...l,opt:c}),L.updateNodeOpt(t)}}class kt extends L{constructor(t){super(t),u(this,"canRotate",!0),u(this,"scaleType",U.all),u(this,"toolsType",k.Image),u(this,"tmpPoints",[]),u(this,"workOptions"),u(this,"oldRect"),this.workOptions=t.toolsOpt,this.scaleType=kt.getScaleType(this.workOptions)}consume(){return{type:f.None}}consumeAll(){return{type:f.None}}draw(t){const{layer:e,workId:s,replaceId:o,imageBitmap:i,isMainThread:r}=t,{centerX:n,centerY:a,width:l,height:c,rotate:p,zIndex:d}=this.workOptions,h=!!e.parent.gl,w={anchor:[.5,.5],pos:[n,a],name:s,size:[l,c],zIndex:d,rotate:!r&&!h&&180+(p||0)||p,texture:i},y=new ke(w);this.replace(e,o||s,y);const m=y.getBoundingClientRect();if(m)return{x:Math.floor(m.x-L.SafeBorderPadding),y:Math.floor(m.y-L.SafeBorderPadding),w:Math.floor(m.width+L.SafeBorderPadding*2),h:Math.floor(m.height+L.SafeBorderPadding*2)}}consumeService(){}async consumeServiceAsync(t){var e,s,o,i;const{isFullWork:r,replaceId:n,scene:a,isMainThread:l}=t,{src:c,uuid:p}=this.workOptions,d=((e=this.workId)==null?void 0:e.toString())||p,h=r?this.fullLayer:this.drawLayer||this.fullLayer;if(c){const w=await a.preload({id:p,src:this.workOptions.src}),y=this.draw({workId:d,layer:h,replaceId:n,imageBitmap:w[0],isMainThread:l});return this.oldRect=d&&((o=(s=this.vNodes)==null?void 0:s.get(d))==null?void 0:o.rect)||void 0,(i=this.vNodes)==null||i.setInfo(d,{rect:y,op:[],opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:y&&L.getCenterPos(y,h)}),y}}clearTmpPoints(){this.tmpPoints.length=0}static getScaleType(t){const{uniformScale:e,rotate:s}=t;return e!==!1?U.proportional:s&&Math.abs(s)%90>0?U.proportional:U.all}static updateNodeOpt(t){const{node:e,opt:s,vNodes:o,targetNode:i}=t,{translate:r,box:n,boxScale:a,boxTranslate:l,angle:c,isLocked:p,zIndex:d}=s,h=i&&et(i)||o.get(e.name);if(!h)return;const w=e.parent;if(w){if(Z(d)&&(e.setAttribute("zIndex",d),h.opt.zIndex=d),rt(p)&&(h.opt.locked=p),n&&l&&a){const{centerX:y,centerY:m,width:T,height:b,uniformScale:I,rotate:g}=h.opt,P=Math.min(a[0],a[1]),N=I!==!1?[P,P]:a,M=ge({x:y-T/2,y:m-b/2,w:T,h:b},g||0),v=ve(M,new S(y,m),N),x=Te(v,new S(y,m),-(g||0)),O=z(x);h.opt.width=Math.round(O.w),h.opt.height=Math.round(O.h);const $=[l[0]/w.worldScaling[0],l[1]/w.worldScaling[1]];h.opt.centerX=y+$[0],h.opt.centerY=m+$[1];const B=[h.centerPos[0]+$[0],h.centerPos[1]+$[1]];if(h.centerPos=B,i){let G=Gt(h.rect,a);G=St(G,$),h.rect=G}else{const G=L.getRectFromLayer(w,e.name);h.rect=G||h.rect}}else if(r)if(h.opt.centerX=h.opt.centerX+r[0],h.opt.centerY=h.opt.centerY+r[1],h.centerPos=[h.centerPos[0]+r[0],h.centerPos[1]+r[1]],i){const y=[r[0]*w.worldScaling[0],r[1]*w.worldScaling[1]],m=St(h.rect,y);h.rect=m}else{const y=L.getRectFromLayer(w,e.name);h.rect=y||h.rect}else if(Z(c))if(h.opt.rotate=c,h.scaleType=kt.getScaleType(h.opt),i){const y=Ht(h.rect,c);h.rect=y}else{const y=L.getRectFromLayer(w,e.name);h.rect=y||h.rect}return h&&o.setInfo(e.name,h),h==null?void 0:h.rect}}}class ie extends L{constructor(t){super(t),u(this,"canRotate",!1),u(this,"scaleType",U.both),u(this,"toolsType",k.Straight),u(this,"tmpPoints",[]),u(this,"workOptions"),u(this,"oldRect"),u(this,"straightTipWidth"),u(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.straightTipWidth=this.workOptions.thickness/2,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){const{data:e,isFullWork:s,isSubWorker:o,isMainThread:i}=t,r=this.workId,{op:n}=e,a=n==null?void 0:n.length;if(!a||a<2)return{type:f.None};let l;if(this.tmpPoints.length===0?(this.tmpPoints=[new C(n[0],n[1])],l=!1):l=this.updateTempPoints(n),!l)return{type:f.None};let c;if(o||i){const d=s?this.fullLayer:this.drawLayer||this.fullLayer;c=this.draw({workId:r,layer:d})}if(!o){const d=Date.now();return d-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=d,{type:f.DrawWork,dataType:W.Local,op:this.tmpPoints.map(h=>[...h.XY,0]).flat(1),isSync:!0,index:0,...this.baseConsumeResult}):{type:f.None}}const p=E(c,this.oldRect);return this.oldRect=c,{rect:p,type:f.DrawWork,dataType:W.Local,...this.baseConsumeResult}}consumeAll(){var t;const e=this.workId;if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[e]};const s=this.fullLayer,o=this.draw({workId:e,layer:s});this.oldRect=o;const i=this.tmpPoints.map(n=>[...n.XY,0]).flat(1),r=Q(i);return(t=this.vNodes)==null||t.setInfo(e,{rect:o,op:i,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:o&&L.getCenterPos(o,s)}),{rect:o,type:f.FullWork,dataType:W.Local,ops:r,isSync:!0,...this.baseConsumeResult}}draw(t){const{workId:e,layer:s}=t,{strokeColor:o,thickness:i,zIndex:r,scale:n,rotate:a,translate:l}=this.workOptions,c=s.worldPosition,p=s.worldScaling,{d,rect:h}=this.computDrawPoints(i),w=[h.x+h.w/2,h.y+h.h/2],y={pos:w,name:e,id:e,d,fillColor:o,strokeColor:o,lineWidth:0,className:`${w[0]},${w[1]}`,normalize:!0,zIndex:r};n&&(y.scale=n),a&&(y.rotate=a),l&&(y.translate=l);const m=new lt(y);if(this.replace(s,e,m),a||n||l){const T=m.getBoundingClientRect();return{x:Math.floor(T.x-L.SafeBorderPadding),y:Math.floor(T.y-L.SafeBorderPadding),w:Math.floor(T.width+L.SafeBorderPadding*2),h:Math.floor(T.height+L.SafeBorderPadding*2)}}return{x:Math.floor(h.x*p[0]+c[0]-L.SafeBorderPadding),y:Math.floor(h.y*p[1]+c[1]-L.SafeBorderPadding),w:Math.floor(h.w*p[0]+2*L.SafeBorderPadding),h:Math.floor(h.h*p[1]+2*L.SafeBorderPadding)}}computDrawPoints(t){return this.tmpPoints[1].distance(this.tmpPoints[0])>this.straightTipWidth?this.computFullPoints(t):this.computDotPoints(t)}computFullPoints(t){const e=S.Sub(this.tmpPoints[1],this.tmpPoints[0]).uni(),s=S.Per(e).mul(t/2),o=C.Sub(this.tmpPoints[0],s),i=C.Add(this.tmpPoints[0],s),r=C.Sub(this.tmpPoints[1],s),n=C.Add(this.tmpPoints[1],s),a=C.GetSemicircleStroke(this.tmpPoints[1],r,-1,8),l=C.GetSemicircleStroke(this.tmpPoints[0],i,-1,8),c=[o,r,...a,n,i,...l];return{d:yt(c,!0),rect:z(c),isDot:!1,pos:this.tmpPoints[0].XY}}computDotPoints(t){const e=C.GetDotStroke(this.tmpPoints[0],t/2,8);return{d:yt(e,!0),rect:z(e),isDot:!0,pos:this.tmpPoints[0].XY}}updateTempPoints(t){const e=t.slice(-2),s=new C(e[0],e[1]),o=this.tmpPoints[0],{thickness:i}=this.workOptions;if(o.isNear(s,i))return!1;if(this.tmpPoints.length===2){if(s.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=s}else this.tmpPoints.push(s);return!0}consumeService(t){var e,s;const{op:o,isFullWork:i}=t,r=(e=this.workId)==null?void 0:e.toString();if(!r)return;this.tmpPoints.length=0;for(let l=0;l<o.length;l+=3)this.tmpPoints.push(new C(o[l],o[l+1],o[l+2]));const n=i?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:r,layer:n});return this.oldRect=a,(s=this.vNodes)==null||s.setInfo(r,{rect:a,op:o,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&L.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){var e;const{node:s,opt:o,vNodes:i}=t,{strokeColor:r}=o,n=i.get(s.name);return r&&(s.setAttribute("strokeColor",r),s.setAttribute("fillColor",r),(e=n==null?void 0:n.opt)!=null&&e.strokeColor&&(n.opt.strokeColor=r)),n&&i.setInfo(s.name,n),L.updateNodeOpt(t)}}const Ct=class j extends L{constructor(t){super(t),u(this,"canRotate",!1),u(this,"scaleType",U.proportional),u(this,"toolsType",k.Text),u(this,"tmpPoints",[]),u(this,"workOptions"),u(this,"oldRect"),this.workOptions=t.toolsOpt}consume(){return{type:f.None}}consumeAll(){return{type:f.None}}consumeService(){}async draw(t){const{workId:e,layer:s,isDrawLabel:o}=t,{boxSize:i,boxPoint:r,zIndex:n}=this.workOptions,a=s.worldPosition,l=s.worldScaling;if(!r||!i)return;const c={name:e,id:e,pos:[r[0],r[1]],anchor:[0,0],size:i,zIndex:n},p=new J(c),d={x:r[0],y:r[1],w:i[0],h:i[1]},h={x:Math.floor(d.x*l[0]+a[0]),y:Math.floor(d.y*l[1]+a[1]),w:Math.floor(d.w*l[0])+2,h:Math.floor(d.h*l[1])+2};if(this.replace(s,e,p),o&&s&&this.workOptions.text){const w=await j.createLabels(this.workOptions,s,h),{labels:y,maxWidth:m}=w;p.append(...y),h.w=Math.ceil(Math.max(m*s.worldScaling[0],h.w))}return h}async consumeServiceAsync(t){var e,s,o,i;const r=(e=this.workId)==null?void 0:e.toString();if(!r)return;const{isFullWork:n,replaceId:a,isDrawLabel:l}=t;this.oldRect=a&&((o=(s=this.vNodes)==null?void 0:s.get(a))==null?void 0:o.rect)||void 0;const c=n?this.fullLayer:this.drawLayer||this.fullLayer,p=await this.draw({workId:r,layer:c,isDrawLabel:typeof l>"u"&&this.workOptions.workState===D.Done||l});return(i=this.vNodes)==null||i.setInfo(r,{rect:p,op:[],opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:p&&L.getCenterPos(p,c)}),p}updataOptService(){}async updataOptServiceAsync(t,e){var s,o;if(!this.workId)return;const i=this.workId.toString(),{fontColor:r,fontBgColor:n,bold:a,italic:l,lineThrough:c,underline:p,zIndex:d}=t,h=(s=this.vNodes)==null?void 0:s.get(i);if(!h)return;r&&(h.opt.fontColor=r),n&&(h.opt.fontBgColor=n),a&&(h.opt.bold=a),l&&(h.opt.italic=l),rt(c)&&(h.opt.lineThrough=c),rt(p)&&(h.opt.underline=p),Z(d)&&(h.opt.zIndex=d),this.oldRect=h.rect;const w=await this.draw({workId:i,layer:this.fullLayer,isDrawLabel:typeof e>"u"&&this.workOptions.workState===D.Done||e});return(o=this.vNodes)==null||o.setInfo(i,{rect:w,op:[],opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:w&&L.getCenterPos(w,this.fullLayer)}),w}clearTmpPoints(){this.tmpPoints.length=0}static getSafetySnippetRatio(t){const e=(t==null?void 0:t.parent).displayRatio||1,s=Math.ceil(t.worldScaling[0]*10)/10;let o=s;return s>=.2&&s<1?o=s*e:s<=2&&s>=1?o=s*e*1.6:s>2&&s<=3?o=s*e*1.4:s>3&&s<=4?o=s*e*.8:s>4&&(o=s*e*.6),Math.floor(o*1e3)/1e3}static getSafetySnippetFontLength(t){return Math.floor(j.textImageSnippetSize*3/4/t)||1}static async createLabels(t,e,s){var o;const i=[],{x:r,y:n}=s,{width:a,height:l}=(o=e.parent)==null?void 0:o.parent,c=ut(t.text),p=c.length,{fontSize:d,lineHeight:h,bold:w,textAlign:y,italic:m,fontFamily:T,verticalAlign:b,fontColor:I,fontBgColor:g,underline:P,lineThrough:N}=t,M=j.getSafetySnippetRatio(e)||1,v=Math.floor(d*M),x=j.getSafetySnippetFontLength(v);let O=0;for(let $=0;$<p;$++){const B=c[$],G=h||v*1.5;if(B){const gt=ye(B),F=[0,0],Y=[0,d*1.2];b==="middle"&&(F[1]=$*d*1.2+5);const st=[0,-d*.15];F[0]=5;const vt=Math.sin(Math.PI/180*20);let ot=0;const Tt=[];let mt=0;for(;mt<gt;){y==="left"&&(st[0]=ot),mt===0&&m==="italic"&&(st[0]=st[0]-vt/2*d);const xt=B.slice(mt,mt+x),Pt={anchor:[0,0],pos:st,text:xt,fontFamily:T,fontSize:v,lineHeight:G,strokeColor:I,fontWeight:w,fillColor:I,textAlign:y,fontStyle:m,scale:[1/M,1/M]},it=new me(Pt),tt=await it.textImageReady;let It=!0;if(tt){const At=tt.rect&&tt.rect[2],Et=tt.rect&&tt.rect[3];if(At&&Et){const Bt=At/M,le=Et/M;ot=Bt+ot,m==="italic"&&(w==="bold"?ot=ot-vt*d*1.2:ot=ot-vt*d),((st[0]+F[0]+Bt)*e.worldScaling[0]+r<=0||(st[0]+F[0])*e.worldScaling[0]+r>=a||(st[1]+F[1]+le)*e.worldScaling[1]+n<=0||(st[1]+F[1])*e.worldScaling[1]+n>=l)&&(it.disconnect(),It=!1),It&&Tt.push(it)}}mt+=x}Y[0]=ot,m==="italic"&&(Y[0]=Y[0]+vt*d),O=Math.max(O,Y[0]);let Dt=!0;if(((F[0]+Y[0])*e.worldScaling[0]+r<=0||F[0]*e.worldScaling[0]+r>=a||(F[1]+Y[1])*e.worldScaling[0]+n<=0||F[1]*e.worldScaling[1]+n>=l)&&(Dt=!1),Dt){if(P){const it=Math.floor(d/10),tt={normalize:!1,pos:[0,d*1.1+it/2],lineWidth:it,points:[0,0,Math.ceil(Y[0]),0],strokeColor:I,className:"underline"},It=new at(tt);Tt.push(It)}if(N){const it={normalize:!1,pos:[0,d*1.2/2],lineWidth:Math.floor(d/10),points:[0,0,Math.ceil(Y[0]),0],strokeColor:I,className:"lineThrough"},tt=new at(it);Tt.push(tt)}const xt={pos:F,anchor:[0,0],size:Y,bgcolor:g},Pt=new J(xt);Pt.append(...Tt),i.push(Pt)}}}return{labels:i,maxWidth:O}}static updateNodeOpt(t){const{node:e,opt:s,vNodes:o,targetNode:i}=t,{fontBgColor:r,fontColor:n,translate:a,box:l,boxScale:c,boxTranslate:p,bold:d,italic:h,lineThrough:w,underline:y,fontSize:m,textInfos:T,zIndex:b}=s,I=i&&et(i)||o.get(e.name);if(!I)return;const g=e.parent;if(!g)return;const P=I.opt;if(Z(b)&&(e.setAttribute("zIndex",b),I.opt.zIndex=b),n&&P.fontColor&&(P.fontColor=n,e.children.forEach(N=>{N.tagName==="GROUP"&&N.children.forEach(M=>{M.tagName==="LABEL"?(M.setAttribute("fillColor",n),M.setAttribute("strokeColor",n)):M.tagName==="POLYLINE"&&M.setAttribute("strokeColor",n)})})),r&&P.fontBgColor&&(P.fontBgColor=r,e.children.forEach(N=>{N.tagName==="GROUP"&&N.setAttribute("bgcolor",r)})),d&&(P.bold=d),h&&(P.italic=h),rt(w)&&(P.lineThrough=w),rt(y)&&(P.underline=y),m&&(P.fontSize=m),l&&p&&c){const N=T==null?void 0:T.get(e.name);if(N){const{fontSize:x,boxSize:O}=N;P.boxSize=O||P.boxSize,P.fontSize=x||P.fontSize}const M=I.rect,v=St(Gt(M,c),p);P.boxPoint=v&&[(v.x-g.worldPosition[0])/g.worldScaling[0],(v.y-g.worldPosition[1])/g.worldScaling[1]]}else if(a&&P.boxPoint&&(P.boxPoint=[P.boxPoint[0]+a[0],P.boxPoint[1]+a[1]],I.centerPos=[I.centerPos[0]+a[0],I.centerPos[1]+a[1]],i)){const N=[a[0]/g.worldScaling[0],a[1]/g.worldScaling[1]];I.rect=St(I.rect,N)}return I&&o.setInfo(e.name,I),I==null?void 0:I.rect}static getRectFromLayer(t,e){const s=t.getElementsByName(e)[0];if(s){const o=s.getBoundingClientRect();let i={x:Math.floor(o.x-j.SafeBorderPadding*t.worldScaling[0]),y:Math.floor(o.y-j.SafeBorderPadding*t.worldScaling[1]),w:Math.floor(o.width+j.SafeBorderPadding*t.worldScaling[0]*2),h:Math.floor(o.height+j.SafeBorderPadding*t.worldScaling[1]*2)};return s.children.forEach(r=>{if(r.tagName==="GROUP"){const n=s.getBoundingClientRect();i=E(i,{x:Math.floor(n.x-j.SafeBorderPadding*t.worldScaling[0]),y:Math.floor(n.y-j.SafeBorderPadding*t.worldScaling[1]),w:Math.floor(n.width+j.SafeBorderPadding*t.worldScaling[0]*2),h:Math.floor(n.height+j.SafeBorderPadding*t.worldScaling[1]*2)})}}),i}}};u(Ct,"textImageSnippetSize",1024*4),u(Ct,"SafeBorderPadding",30);let re=Ct;function ne(R){switch(R){case k.Arrow:return Kt;case k.Pencil:return Vt;case k.Straight:return ie;case k.Ellipse:return _t;case k.Polygon:case k.Triangle:return se;case k.Star:case k.Rhombus:return ee;case k.Rectangle:return te;case k.SpeechBalloon:return oe;case k.Text:return re;case k.LaserPen:return Zt;case k.Eraser:return Qt;case k.Selector:return K;case k.Image:return kt}}function bt(R,t){const{toolsType:e,...s}=R;switch(e){case k.Arrow:return new Kt(s);case k.Pencil:return new Vt(s);case k.Straight:return new ie(s);case k.Ellipse:return new _t(s);case k.Polygon:case k.Triangle:return new se(s);case k.Star:case k.Rhombus:return new ee(s);case k.Rectangle:return new te(s);case k.SpeechBalloon:return new oe(s);case k.Text:return new re(s);case k.LaserPen:return new Zt(s);case k.Eraser:return new Qt(s,t);case k.Selector:return s.vNodes?new K({...s,vNodes:s.vNodes,drawLayer:s.fullLayer}):void 0;case k.Image:return new kt(s);default:return}}function ae(R){const t=[],e=["PATH","SPRITE","POLYLINE","RECT","ELLIPSE","LABEL"];for(const s of R){if(s.tagName==="GROUP"&&s.children.length)return ae(s.children);s.tagName&&e.includes(s.tagName)&&t.push(s)}return t}const Ce=R=>{if(R.tagName==="GROUP"){const t=Object.getOwnPropertySymbols(R).find(e=>e.toString()==="Symbol(sealed)");if(t&&R[t])return!0}return!1},Me=R=>!R.isHid;class De{constructor(t,e){u(this,"viewId"),u(this,"scene"),u(this,"fullLayer"),u(this,"curNodeMap",new Map),u(this,"targetNodeMap",[]),u(this,"highLevelIds"),this.viewId=t,this.scene=e}init(t){this.fullLayer=t}get(t){return this.curNodeMap.get(t)}getNodesByType(t){const e=new Map;return this.curNodeMap.forEach((s,o)=>{s.toolsType===t&&e.set(o,s)}),e}hasRenderNodes(){let t=!1;for(const e of this.curNodeMap.values())Me(e)&&(t=!0);return t}has(t){return this.curNodeMap.has(t)}setInfo(t,e){const s=this.curNodeMap.get(t)||{name:t,rect:e.rect};e.rect&&(s.rect=et(e.rect)),e.op&&Xt(e.op)&&(s.op=et(e.op)),e.canRotate&&(s.canRotate=e.canRotate),e.scaleType&&(s.scaleType=e.scaleType),e.opt&&(s.opt=et(e.opt)),e.toolsType&&(s.toolsType=e.toolsType),e.centerPos&&(s.centerPos=et(e.centerPos)),rt(e.isSelected)&&(s.isSelected=e.isSelected),s.rect?this.curNodeMap.set(t,s):this.curNodeMap.delete(t)}selected(t){this.setInfo(t,{isSelected:!0})}unSelected(t){this.setInfo(t,{isSelected:!1})}delete(t){this.curNodeMap.delete(t)}clear(){this.curNodeMap.clear(),this.targetNodeMap.length=0}hasRectIntersectRange(t,e=!0){for(const s of this.curNodeMap.values())if(ft(t,s.rect)){if(e&&s.toolsType===k.Image&&s.opt.locked||e&&s.toolsType===k.Text&&(s.opt.workState===D.Doing||s.opt.workState===D.Start))continue;return!0}return!1}getRectIntersectRange(t,e=!0,s=!0){let o;const i=new Map;for(const[r,n]of this.curNodeMap.entries())if(ft(t,n.rect)){if(e&&n.toolsType===k.Image&&n.opt.locked||s&&n.toolsType===k.Text&&(n.opt.workState===D.Doing||n.opt.workState===D.Start))continue;o=E(o,n.rect),i.set(r,n)}return{rectRange:o,nodeRange:i}}getNodeRectFormShape(t,e){const s=ne(e.toolsType);return this.fullLayer&&(s==null?void 0:s.getRectFromLayer(this.fullLayer,t))}updateNodeRect(t){const e=this.curNodeMap.get(t);if(e){const s=this.getNodeRectFormShape(t,e);if(!s){this.curNodeMap.delete(t);return}e.rect=s,this.curNodeMap.set(t,e)}}updateHighLevelNodesRect(t){this.highLevelIds=t;for(const e of this.highLevelIds.keys())this.updateNodeRect(e)}updateLowLevelNodesRect(){var t;for(const e of this.curNodeMap.keys())(t=this.highLevelIds)!=null&&t.has(e)||this.updateNodeRect(e)}clearHighLevelIds(){this.highLevelIds=void 0}combineIntersectRect(t){let e=t;return this.curNodeMap.forEach(s=>{ft(e,s.rect)&&(e=E(e,s.rect))}),e}setTarget(){return this.targetNodeMap.push(et(this.curNodeMap)),this.targetNodeMap.length-1}getLastTarget(){return this.targetNodeMap[this.targetNodeMap.length-1]}deleteLastTarget(){this.targetNodeMap.length&&(this.targetNodeMap.length=this.targetNodeMap.length-1)}getTarget(t){return this.targetNodeMap[t]}deleteTarget(t){this.targetNodeMap.length=t}clearTarget(){this.targetNodeMap.length=0}}class Ae{constructor(t){u(this,"vNodes"),u(this,"thread"),u(this,"serviceWorkShapes",new Map),u(this,"localWorkShapes",new Map),u(this,"tmpOpt"),u(this,"animationId"),u(this,"syncUnitTime",dt.syncOpt.interval),this.vNodes=t.vNodes,this.thread=t.thread}createLocalWork(t){const{workId:e,opt:s,toolsType:o}=t;if(e&&s){const i=e.toString();!this.getToolsOpt()&&o&&this.setToolsOpt({toolsType:o,toolsOpt:s}),this.setWorkOptions(i,s)}}getLocalWorkShape(t){return this.localWorkShapes.get(t)}createLocalWorkShape(t,e){if(t&&this.tmpOpt){const s={toolsType:this.tmpOpt.toolsType,toolsOpt:e||this.tmpOpt.toolsOpt},o=this.createWorkShapeNode({...s,workId:t});return o&&this.localWorkShapes.set(t,{node:o,toolsType:o.toolsType,workState:D.Start}),o}}canUseTopLayer(t){return t===k.LaserPen}destroy(){this.clearAll()}clearAll(){this.thread.topLayer.children.length&&(this.thread.topLayer.parent.children.forEach(t=>{t.name!=="viewport"&&t.remove()}),this.thread.serviceLayer.removeAllChildren()),this.serviceWorkShapes.clear(),this.localWorkShapes.clear()}consumeDraw(t){const{workId:e,dataType:s}=t;if(s===W.Service)this.activeServiceWorkShape(t);else{const o=e==null?void 0:e.toString(),i=o&&this.localWorkShapes.get(o);if(!i)return;const r=i.node.consume({data:t,isFullWork:!1,isSubWorker:!0});r.rect&&(i.result=r,i.workState=D.Doing,o&&this.localWorkShapes.set(o,i))}this.runAnimation()}setToolsOpt(t){var e;this.tmpOpt=t,(e=t.toolsOpt)!=null&&e.syncUnitTime&&(this.syncUnitTime=t.toolsOpt.syncUnitTime)}getToolsOpt(){return this.tmpOpt}createWorkShapeNode(t){const{toolsType:e}=t;if(e===k.LaserPen)return bt({...t,vNodes:this.vNodes,fullLayer:this.thread.topLayer,drawLayer:this.thread.topLayer})}setNodeKey(t,e,s,o){return e.toolsType=s,e.node=this.createWorkShapeNode({workId:t,toolsType:s,toolsOpt:o}),e}activeServiceWorkShape(t){var e,s;const{workId:o,opt:i,toolsType:r,type:n,updateNodeOpt:a,ops:l,op:c}=t;if(!o)return;const p=o.toString(),d=(e=this.vNodes.get(p))==null?void 0:e.rect;if(!((s=this.serviceWorkShapes)!=null&&s.has(p))){let w={toolsType:r,animationWorkData:c||[],animationIndex:0,type:n,updateNodeOpt:a,ops:l,oldRect:d};r&&i&&(w=this.setNodeKey(p,w,r,i)),this.serviceWorkShapes.set(p,w)}const h=this.serviceWorkShapes.get(p);n&&(h.type=n),l&&(h.animationWorkData=ut(l),h.ops=l),a&&(h.updateNodeOpt=a),c&&(h.animationWorkData=c),h.node&&h.node.getWorkId()!==p&&h.node.setWorkId(p),d&&(h.oldRect=d),r&&i&&(h.toolsType!==r&&r&&i&&this.setNodeKey(p,h,r,i),h.node&&h.node.setWorkOptions(i))}computNextAnimationIndex(t,e){var s;const o=((s=t.node)==null?void 0:s.syncUnitTime)||this.syncUnitTime,i=Math.floor((t.animationWorkData||[]).slice(t.animationIndex).length*32/e/o)*e;return Math.min((t.animationIndex||0)+(i||e),(t.animationWorkData||[]).length)}animationDraw(){var t,e,s,o;this.animationId=void 0;let i=!1;const r=new Map,n=[];for(const[a,l]of this.serviceWorkShapes.entries())switch(l.toolsType){case k.LaserPen:{const c=this.computNextAnimationIndex(l,8),p=Math.max(0,l.animationIndex||0),d=(l.animationWorkData||[]).slice(p,c);if((l.animationIndex||0)<c&&((t=l.node)==null||t.consumeService({op:d,isFullWork:!1}),l.animationIndex=c,d.length&&r.set(a,{workState:p===0?D.Start:c===((e=l.animationWorkData)==null?void 0:e.length)?D.Done:D.Doing,op:d.slice(-2)})),l.isDel){(s=l.node)==null||s.clearTmpPoints(),this.serviceWorkShapes.delete(a);break}l.ops&&l.animationIndex===((o=l.animationWorkData)==null?void 0:o.length)&&!l.isDel&&(this.thread.topLayer.getElementsByName(a.toString())[0]||(l.isDel=!0,this.serviceWorkShapes.set(a,l))),i=!0;break}}for(const[a,l]of this.localWorkShapes.entries()){const{result:c,toolsType:p,isDel:d,workState:h}=l;switch(p){case k.LaserPen:{if(d){l.node.clearTmpPoints(),this.localWorkShapes.delete(a),n.push({removeIds:[a.toString()],type:f.RemoveNode});break}c&&((c.op||c.ops)&&n.push(c),l.result=void 0),!this.thread.topLayer.getElementsByName(a.toString())[0]&&h===D.Done&&(l.isDel=!0,this.localWorkShapes.set(a,l)),i=!0;break}}}i&&this.runAnimation(),r.size&&r.forEach((a,l)=>{n.push({type:f.Cursor,uid:l.split(Mt)[0],op:a.op,workState:a.workState,viewId:this.thread.viewId})}),n.length&&this.thread.post({sp:n})}runAnimation(){this.animationId||(this.animationId=requestAnimationFrame(this.animationDraw.bind(this)))}setWorkOptions(t,e){var s;let o=(s=this.localWorkShapes.get(t))==null?void 0:s.node;if(!o&&this.tmpOpt){const{toolsType:i}=this.tmpOpt;this.tmpOpt.toolsOpt=e,o=this.createWorkShapeNode({workId:t,toolsType:i,toolsOpt:e}),o&&this.localWorkShapes.set(t,{node:o,toolsType:i,workState:D.Start}),this.setToolsOpt(this.tmpOpt)}e!=null&&e.syncUnitTime||(e.syncUnitTime=this.syncUnitTime),o&&o.setWorkOptions(e)}consumeDrawAll(t){const{workId:e,dataType:s}=t;if(s===W.Service)this.activeServiceWorkShape(t);else{const o=e==null?void 0:e.toString(),i=o&&this.localWorkShapes.get(o);if(!i)return;const r=i.node.consumeAll({data:t});i.result=r,i.workState=D.Done,o&&this.localWorkShapes.set(o,i)}this.runAnimation()}}class Ee{constructor(t){u(this,"vNodes"),u(this,"thread"),u(this,"workShapes",new Map),u(this,"effectSelectNodeData",new Set),u(this,"batchEraserRemoveNodes",new Set),u(this,"batchEraserWorks",new Set),u(this,"tmpOpt"),u(this,"syncUnitTime",dt.syncOpt.interval),u(this,"drawCount",0),u(this,"drawWorkActiveId"),u(this,"batchEraserCombine",we(()=>{this.updateBatchEraserCombineNode(this.batchEraserWorks,this.batchEraserRemoveNodes),this.batchEraserWorks.clear(),this.batchEraserRemoveNodes.clear()},100,{leading:!1})),this.vNodes=t.vNodes,this.thread=t.thread}createLocalWork(t){const{workId:e,opt:s,toolsType:o}=t;if(e&&s){const i=e.toString();!this.getToolsOpt()&&o&&this.setToolsOpt({toolsType:o,toolsOpt:s}),this.setWorkOptions(i,s)}}workShapesDone(t,e){for(const s of this.workShapes.keys())this.consumeDrawAll({workId:s,scenePath:t,viewId:this.thread.viewId,msgType:f.DrawWork,dataType:W.Local},e)}async updateSelector(t){var e;const s=this.workShapes.get(X);if(!((e=s==null?void 0:s.selectIds)!=null&&e.length))return;const{callback:o,...i}=t,{updateSelectorOpt:r,willSerializeData:n,scene:a}=i,l=await(s==null?void 0:s.updateSelector({updateSelectorOpt:r,selectIds:pt.cloneDeep(s.selectIds),vNodes:this.vNodes,willSerializeData:n,worker:this,scene:a,isMainThread:!0})),c=new Map;let p;l!=null&&l.selectIds&&(p=pt.xor(s.selectIds,l.selectIds),l.selectIds.forEach(w=>{const y=this.vNodes.get(w);if(y){const{toolsType:m,op:T,opt:b}=y;c.set(w,{opt:b,toolsType:m,ops:(T==null?void 0:T.length)&&Q(T)||void 0})}}),s.selectIds=l.selectIds,console.log("removeIds",p));const d=[],h=o&&o({res:l,workShapeNode:s,param:i,postData:{sp:d},newServiceStore:c})||{sp:d};p&&h.sp.push({type:f.RemoveNode,removeIds:p,viewId:this.thread.viewId}),h.sp.length&&this.thread.post(h)}destroy(){this.clearAll()}clearAll(){if(this.thread.localLayer.children.length&&(this.thread.topLayer.parent.children.forEach(t=>{t.name!=="viewport"&&t.remove()}),this.thread.localLayer.removeAllChildren()),this.workShapes.get(X)){const t=[];t.push({type:f.Select,dataType:W.Local,selectIds:[],willSyncService:!1}),this.thread.post({sp:t})}this.workShapes.clear(),this.effectSelectNodeData.clear(),this.batchEraserWorks.clear(),this.batchEraserRemoveNodes.clear()}async checkTextActive(t){const{op:e,viewId:s,dataType:o}=t;if(e!=null&&e.length){let i;for(const r of this.vNodes.curNodeMap.values()){const{rect:n,name:a,toolsType:l,opt:c}=r,p=e[0]*this.thread.fullLayer.worldScaling[0]+this.thread.fullLayer.worldPosition[0],d=e[1]*this.thread.fullLayer.worldScaling[1]+this.thread.fullLayer.worldPosition[1];if(l===k.Text&&fe([p,d],n)&&c.workState===D.Done){i=a;break}}i&&(await this.blurSelector({viewId:s,msgType:f.Select,dataType:o,isSync:!0}),this.thread.post({sp:[{type:f.GetTextActive,toolsType:k.Text,workId:i}]}))}}cursorHover(t){const{opt:e,toolsType:s,point:o}=t,i=this.setFullWork({workId:Wt,toolsType:s,opt:e});i&&o&&i.cursorHover(o)}updateFullSelectWork(t){var e,s,o,i,r;const n=this.workShapes.get(X),{selectIds:a}=t;if(!(a!=null&&a.length)){this.blurSelector(t);return}if(!n){const l=this.setFullWork(t);!l&&t.workId&&this.tmpOpt&&((e=this.tmpOpt)==null?void 0:e.toolsType)===k.Selector&&this.setWorkOptions(t.workId.toString(),t.opt||this.tmpOpt.toolsOpt),l&&this.updateFullSelectWork(t);return}if(n&&a!=null&&a.length){const{selectRect:l}=n.updateSelectIds(a),c=[{...t,selectorColor:((s=t.opt)==null?void 0:s.strokeColor)||n.selectorColor,strokeColor:((o=t.opt)==null?void 0:o.strokeColor)||n.strokeColor,fillColor:((i=t.opt)==null?void 0:i.fillColor)||n.fillColor,textOpt:((r=t.opt)==null?void 0:r.textOpt)||n.textOpt,canTextEdit:n.canTextEdit,canRotate:n.canRotate,scaleType:n.scaleType,type:f.Select,selectRect:l,points:n.getChildrenPoints(),willSyncService:(t==null?void 0:t.willSyncService)||!1,opt:(t==null?void 0:t.willSyncService)&&n.getWorkOptions()||void 0,canLock:n.canLock,isLocked:n.isLocked,toolsTypes:n.toolsTypes,shapeOpt:n.shapeOpt}];this.thread.post({sp:c})}}commandDeleteText(t){const e=this.vNodes.get(t);if(e&&e.toolsType===k.Text)return{type:f.TextUpdate,toolsType:k.Text,workId:t,dataType:W.Local}}async removeSelector(t){const{willSyncService:e}=t,s=[],o=[],i=this.workShapes.get(X);if(!i)return;const r=i.selectIds&&[...i.selectIds]||[];for(const n of r){if(this.vNodes.get(n)){const a=this.commandDeleteText(n);a&&s.push(a)}this.removeNode(n),o.push(n)}o.length&&s.push({type:f.RemoveNode,removeIds:o}),s.push({type:f.Select,selectIds:[],willSyncService:e}),await this.blurSelector(),s.length&&this.thread.post({sp:s})}removeWork(t){const{workId:e}=t,s=e==null?void 0:e.toString();s&&this.removeNode(s)}removeNode(t){var e;this.vNodes.get(t)&&((e=this.thread.fullLayer)==null||e.getElementsByName(t).forEach(s=>{s.remove()}),this.vNodes.delete(t)),this.workShapes.has(t)&&(this.thread.localLayer.getElementsByName(t).forEach(s=>{s.remove()}),this.clearWorkShapeNodeCache(t))}setFullWork(t){const{workId:e,opt:s,toolsType:o}=t;if(e&&s&&o){const i=e.toString();let r;return e&&this.workShapes.has(i)?(r=this.workShapes.get(i),r==null||r.setWorkOptions(s)):r=this.createWorkShapeNode({toolsOpt:s,toolsType:o,workId:i}),r?(this.workShapes.set(i,r),r):void 0}}async consumeFull(t,e){var s;const o=this.setFullWork(t),i=t.ops&&ut(t.ops);if(o){const r=(s=t.workId)==null?void 0:s.toString();o.toolsType===k.Image&&e?await o.consumeServiceAsync({scene:e,isFullWork:!0,replaceId:r,isMainThread:!0}):o.toolsType===k.Text?await o.consumeServiceAsync({isFullWork:!0,replaceId:r}):o.consumeService({op:i,isFullWork:!0,replaceId:r}),t!=null&&t.updateNodeOpt&&o.updataOptService(t.updateNodeOpt);const n=[];t.workId&&this.workShapes.delete(t.workId.toString()),t.willSyncService&&n.push({opt:t.opt,toolsType:t.toolsType,type:f.FullWork,workId:t.workId,ops:t.ops,updateNodeOpt:t.updateNodeOpt,viewId:this.thread.viewId}),n.length&&this.thread.post({sp:n})}}async colloctEffectSelectWork(t){const e=this.workShapes.get(X),{workId:s,msgType:o}=t;if(e&&s&&e.selectIds&&e.selectIds.includes(s.toString())){o===f.RemoveNode?e.selectIds=e.selectIds.filter(i=>i!==s.toString()):this.effectSelectNodeData.add(t),await new Promise(i=>{setTimeout(()=>{i(!0)},0)}),await this.runEffectSelectWork(!0).then(()=>{var i;(i=this.effectSelectNodeData)==null||i.clear()});return}return t}async runEffectSelectWork(t){var e,s,o;for(const i of this.effectSelectNodeData.values()){const r=this.setFullWork(i);if(r){const n=(e=i.workId)==null?void 0:e.toString();if(r.toolsType===k.Image)await r.consumeServiceAsync({scene:(o=(s=this.thread.localLayer)==null?void 0:s.parent)==null?void 0:o.parent,isFullWork:!0,replaceId:n,isMainThread:!0});else if(r.toolsType===k.Text)await r.consumeServiceAsync({isFullWork:!0,replaceId:n});else{const a=i.ops&&ut(i.ops);r.consumeService({op:a,isFullWork:!0,replaceId:n}),i!=null&&i.updateNodeOpt&&r.updataOptService(i.updateNodeOpt)}i.workId&&this.workShapes.delete(i.workId.toString())}}this.reRenderSelector(t)}hasSelector(){return this.workShapes.has(X)}getSelector(){return this.workShapes.get(X)}reRenderSelector(t=!1){var e;const s=this.workShapes.get(X);if(!s)return;if(s&&!((e=s.selectIds)!=null&&e.length))return this.blurSelector();const o=s.reRenderSelector();o&&this.thread.post({sp:[{type:f.Select,selectIds:s.selectIds,selectRect:o,willSyncService:t,viewId:this.thread.viewId,points:s.getChildrenPoints(),textOpt:s.textOpt,selectorColor:s.selectorColor,strokeColor:s.strokeColor,fillColor:s.fillColor,canTextEdit:s.canTextEdit,canRotate:s.canRotate,scaleType:s.scaleType,opt:s.getWorkOptions()||void 0,canLock:s.canLock,isLocked:s.isLocked,toolsTypes:s.toolsTypes,shapeOpt:s.shapeOpt}]})}async blurSelector(t){var e;const s=this.workShapes.get(X),o=s==null?void 0:s.blurSelector();if(this.clearWorkShapeNodeCache(X),((e=this.thread.fullLayer)==null?void 0:e.parent).children.forEach(i=>{i.name===X&&i.remove()}),o){const i=[];i.push({...o,isSync:t==null?void 0:t.isSync}),this.thread.post({sp:i})}}clearWorkShapeNodeCache(t){var e;(e=this.getWorkShape(t))==null||e.clearTmpPoints(),this.workShapes.delete(t)}drawEraser(t){var e,s;const o=[];if((e=t.newWorkDatas)!=null&&e.size){for(const i of t.newWorkDatas.values()){const r=i.workId.toString();this.batchEraserWorks.add(r),o.push({type:f.FullWork,workId:r,ops:Q(i.op),opt:i.opt,toolsType:i.toolsType,updateNodeOpt:{useAnimation:!1}})}delete t.newWorkDatas}(s=t.removeIds)==null||s.forEach(i=>{this.batchEraserRemoveNodes.add(i)}),o.push(t),this.thread.post({sp:o}),this.batchEraserCombine()}updateBatchEraserCombineNode(t,e){for(const s of e.keys())this.thread.fullLayer.getElementsByName(s).forEach(o=>{o.remove()});t.forEach(s=>{const o=this.vNodes.get(s);if(o&&o.toolsType===k.Pencil&&!this.thread.fullLayer.getElementsByName(s)[0]){const i=this.setFullWork({...o,workId:s});i&&i.consumeService({op:o.op,isFullWork:!0})}})}getWorkShape(t){return this.workShapes.get(t)}getWorkShapes(){return this.workShapes}consumeDraw(t,e){const{op:s,workId:o,scenePath:i}=t;if(s!=null&&s.length&&o){const r=o.toString(),n=this.workShapes.get(r);if(!n)return;const a=n.toolsType;if(a===k.LaserPen)return;switch(this.drawWorkActiveId&&this.drawWorkActiveId!==r&&(this.consumeDrawAll({workId:this.drawWorkActiveId,scenePath:i,viewId:this.thread.viewId,msgType:f.DrawWork,dataType:W.Local},e),this.drawWorkActiveId=void 0),!this.drawWorkActiveId&&r!==X&&(this.drawWorkActiveId=r),a){case k.Selector:{const l=n.consume({data:t,isFullWork:!0});l.type===f.Select&&(l.selectIds&&e.runReverseSelectWork(l.selectIds),this.thread.post({sp:[l]}))}break;case k.Eraser:{const l=n.consume({data:t,isFullWork:!0});l!=null&&l.rect&&this.drawEraser(l)}break;case k.Arrow:case k.Straight:case k.Ellipse:case k.Rectangle:case k.Star:case k.Polygon:case k.SpeechBalloon:case k.Pencil:{const l=n.consume({data:t,isFullWork:!1,isMainThread:!0});l&&(this.drawCount++,this.thread.post({drawCount:this.drawCount,sp:l.op&&[{...l,scenePath:i}]||void 0}))}break}}}consumeDrawAll(t,e){var s,o,i;const{workId:r,scenePath:n}=t;if(r){const a=r.toString();this.drawWorkActiveId===a&&(this.drawWorkActiveId=void 0);const l=this.workShapes.get(a);if(!l)return;const c=l.toolsType;if(c===k.LaserPen)return;const p=this.workShapes.get(Wt),d=(s=p==null?void 0:p.selectIds)==null?void 0:s[0],h=l.consumeAll({data:t});switch(c){case k.Selector:h.selectIds&&d&&(o=h.selectIds)!=null&&o.includes(d)&&p.cursorBlur(),h.type===f.Select&&(h.selectIds&&e.runReverseSelectWork(h.selectIds),this.thread.post({sp:[{...h,scenePath:n}]})),(i=l.selectIds)!=null&&i.length?l.clearTmpPoints():this.clearWorkShapeNodeCache(a);break;case k.Eraser:h!=null&&h.rect&&this.drawEraser({...h,scenePath:n}),l.clearTmpPoints();break;case k.Arrow:case k.Straight:case k.Ellipse:case k.Rectangle:case k.Star:case k.Polygon:case k.SpeechBalloon:case k.Pencil:h&&(this.drawCount=0,this.thread.post({drawCount:this.drawCount,sp:[h]})),this.clearWorkShapeNodeCache(a);break}}}getToolsOpt(){return this.tmpOpt}setToolsOpt(t){var e;this.tmpOpt=t,(e=t.toolsOpt)!=null&&e.syncUnitTime&&(this.syncUnitTime=t.toolsOpt.syncUnitTime)}setWorkOptions(t,e){let s=this.workShapes.get(t);if(!s&&this.tmpOpt){const{toolsType:o}=this.tmpOpt;this.tmpOpt.toolsOpt=e,s=this.createWorkShapeNode({workId:t,toolsType:o,toolsOpt:e}),s&&this.workShapes.set(t,s),this.setToolsOpt(this.tmpOpt)}e.syncUnitTime||(e.syncUnitTime=this.syncUnitTime),s==null||s.setWorkOptions(e)}createWorkShapeNode(t){return bt({...t,vNodes:this.vNodes,fullLayer:this.thread.fullLayer,drawLayer:this.thread.localLayer},this.thread.serviceWork)}}class Be{constructor(t){u(this,"vNodes"),u(this,"thread"),u(this,"workShapes",new Map),u(this,"selectorWorkShapes",new Map),u(this,"willRunEffectSelectorIds",new Set),u(this,"runEffectId"),u(this,"animationId"),u(this,"syncUnitTime",dt.syncOpt.interval),this.vNodes=t.vNodes,this.thread=t.thread}destroy(){this.clearAll()}clearAll(){this.thread.serviceLayer.children.length&&(this.thread.serviceLayer.parent.children.forEach(t=>{t.name!=="viewport"&&t.remove()}),this.thread.serviceLayer.removeAllChildren()),this.workShapes.clear(),this.selectorWorkShapes.clear(),this.willRunEffectSelectorIds.clear()}runEffect(){this.runEffectId||(this.runEffectId=setTimeout(this.effectRunSelector.bind(this),0))}effectRunSelector(){this.runEffectId=void 0,this.willRunEffectSelectorIds.forEach(t=>{var e,s;const o=this.selectorWorkShapes.get(t);o&&o.selectIds&&((e=o.node)==null||e.selectServiceNode(t,o,!0)),(s=o==null?void 0:o.selectIds)!=null&&s.length||this.selectorWorkShapes.delete(t)}),this.willRunEffectSelectorIds.clear()}runSelectWork(t){this.activeSelectorShape(t);const{workId:e}=t,s=e==null?void 0:e.toString();s&&this.willRunEffectSelectorIds.add(s),this.runEffect()}removeWork(t){const{workId:e}=t,s=e==null?void 0:e.toString();if(s){if(this.workShapes.get(s)){this.workShapes.delete(s),this.removeNode(s,t);return}this.removeNode(s,t)}}consumeFull(t){this.activeWorkShape(t),this.runAnimation()}runReverseSelectWork(t){t.forEach(e=>{this.selectorWorkShapes.forEach((s,o)=>{var i;if((i=s.selectIds)!=null&&i.length){const r=s.selectIds.indexOf(e);r>-1&&(s.selectIds.splice(r,1),this.willRunEffectSelectorIds.add(o))}})}),this.willRunEffectSelectorIds.size&&this.runEffect()}consumeDraw(t){this.activeWorkShape(t),this.runAnimation()}computNextAnimationIndex(t,e){const s=Math.floor((t.animationWorkData||[]).slice(t.animationIndex).length*32/e/this.syncUnitTime)*e;return Math.min((t.animationIndex||0)+(s||e),(t.animationWorkData||[]).length)}async animationDraw(){var t,e,s,o,i,r,n,a,l,c,p,d,h,w,y,m;this.animationId=void 0;let T=!1;const b=new Map;for(const[I,g]of this.workShapes.entries())switch(g.toolsType){case k.Image:{await((e=g.node)==null?void 0:e.consumeServiceAsync({isFullWork:!0,scene:(t=this.thread.fullLayer.parent)==null?void 0:t.parent,isMainThread:!0})),this.selectorWorkShapes.forEach((P,N)=>{var M;(M=P.selectIds)!=null&&M.includes(I)&&(this.willRunEffectSelectorIds.add(N),this.runEffect())}),this.workShapes.delete(I);break}case k.Text:{g.node&&(await((s=g.node)==null?void 0:s.consumeServiceAsync({isFullWork:!0,replaceId:I})),this.selectorWorkShapes.forEach((P,N)=>{var M;(M=P.selectIds)!=null&&M.includes(I)&&(this.willRunEffectSelectorIds.add(N),this.runEffect())}),(o=g.node)==null||o.clearTmpPoints(),this.workShapes.delete(I));break}case k.Arrow:case k.Straight:case k.Rectangle:case k.Ellipse:case k.Star:case k.Polygon:case k.SpeechBalloon:{const P=!!g.ops;if((i=g.animationWorkData)!=null&&i.length){const N=g.oldRect;(r=g.node)==null||r.consumeService({op:g.animationWorkData,isFullWork:P}),P&&(this.selectorWorkShapes.forEach((M,v)=>{var x;(x=M.selectIds)!=null&&x.includes(I)&&(this.willRunEffectSelectorIds.add(v),this.runEffect())}),(n=g.node)==null||n.clearTmpPoints(),this.workShapes.delete(I)),b.set(I,{workState:N?g.ops?D.Done:D.Doing:D.Start,op:g.animationWorkData.filter((M,v)=>{if(v%3!==2)return!0}).slice(-2)}),g.animationWorkData.length=0}break}case k.Pencil:{if(!g.useAnimation&&g.ops)(a=g.node)==null||a.consumeService({op:g.animationWorkData||[],isFullWork:!0,replaceId:I}),(l=g.node)==null||l.updataOptService(g.updateNodeOpt),this.selectorWorkShapes.forEach((P,N)=>{var M;(M=P.selectIds)!=null&&M.includes(I)&&(this.willRunEffectSelectorIds.add(N),this.runEffect())}),(c=g.node)==null||c.clearTmpPoints(),this.workShapes.delete(I);else if(g.useAnimation){if(g.isDel){(p=g.node)==null||p.clearTmpPoints(),this.workShapes.delete(I);break}const P=3,N=this.computNextAnimationIndex(g,P),M=g.isDiff?0:Math.max(0,(g.animationIndex||0)-P),v=(g.animationWorkData||[]).slice(M,N),x=(h=(d=g.node)==null?void 0:d.getWorkId())==null?void 0:h.toString();if((g.animationIndex||0)<N||g.isDiff){if((w=g.node)==null||w.consumeService({op:v,isFullWork:!1}),g.animationIndex=N,g.isDiff&&(g.isDiff=!1),v.length){const O=v.filter(($,B)=>{if(B%P!==P-1)return!0}).slice(-2);b.set(I,{workState:M===0?D.Start:N===((y=g.animationWorkData)==null?void 0:y.length)?D.Done:D.Doing,op:O})}}else g.ops&&((m=g.node)==null||m.consumeService({op:g.animationWorkData||[],isFullWork:!0,replaceId:x}),g.isDel=!0,b.set(I,{workState:D.Done,op:v.filter((O,$)=>{if($%P!==P-1)return!0}).slice(-2)}));T=!0;break}break}}if(T&&this.runAnimation(),b.size){const I=[];b.forEach((g,P)=>{I.push({type:f.Cursor,uid:P.split(Mt)[0],op:g.op,workState:g.workState,viewId:this.thread.viewId})}),this.thread.post({sp:I})}}runAnimation(){this.animationId||(this.animationId=requestAnimationFrame(this.animationDraw.bind(this)))}hasDiffData(t,e,s){const o=t.length;if(e.length<o)return!0;switch(s){case k.Pencil:{for(let i=0;i<o;i+=3)if(e[i]!==t[i]||e[i+1]!==t[i+1])return!0;break}case k.LaserPen:{for(let i=0;i<o;i+=2)if(e[i]!==t[i]||e[i+1]!==t[i+1])return!0;break}}return!1}activeWorkShape(t){var e,s,o,i;const{workId:r,opt:n,toolsType:a,type:l,updateNodeOpt:c,ops:p,op:d,useAnimation:h}=t;if(!r)return;const w=r.toString(),y=(e=this.vNodes.get(w))==null?void 0:e.rect;if(!((s=this.workShapes)!=null&&s.has(w))){let T={toolsType:a,animationWorkData:d||[],animationIndex:0,type:l,updateNodeOpt:c,ops:p,useAnimation:typeof h<"u"?h:typeof(c==null?void 0:c.useAnimation)<"u"?c==null?void 0:c.useAnimation:!0,oldRect:y,isDiff:!1};a&&n&&(T=this.setNodeKey(w,T,a,n)),(o=this.workShapes)==null||o.set(w,T)}const m=(i=this.workShapes)==null?void 0:i.get(w);l&&(m.type=l),p&&(m.animationWorkData=ut(p),m.ops=p),c&&(m.updateNodeOpt=c),d&&(m.isDiff=this.hasDiffData(m.animationWorkData||[],d,m.toolsType),m.animationWorkData=d),m.node&&m.node.getWorkId()!==w&&m.node.setWorkId(w),y&&(m.oldRect=y),a&&n&&(n.syncUnitTime&&(this.syncUnitTime=n.syncUnitTime),m.toolsType!==a&&a&&n&&this.setNodeKey(w,m,a,n),m.node&&m.node.setWorkOptions(n))}removeNode(t,e){t.indexOf(X)>-1&&this.removeSelectWork(e),this.thread.fullLayer.getElementsByName(t).forEach(s=>{s.remove()}),this.thread.serviceLayer.getElementsByName(t).forEach(s=>{s.remove()}),this.vNodes.delete(t)}removeSelectWork(t){const{workId:e}=t,s=e==null?void 0:e.toString();s&&(this.activeSelectorShape(t),this.willRunEffectSelectorIds.add(s)),this.runEffect()}activeSelectorShape(t){var e,s,o;const{workId:i,opt:r,toolsType:n,type:a,selectIds:l}=t;if(!i)return;const c=i.toString();if(!((e=this.selectorWorkShapes)!=null&&e.has(c))){let d={toolsType:n,selectIds:l,type:a,opt:r};n&&r&&(d=this.setNodeKey(c,d,n,r)),(s=this.selectorWorkShapes)==null||s.set(c,d)}const p=(o=this.selectorWorkShapes)==null?void 0:o.get(c);a&&(p.type=a),p.node&&p.node.getWorkId()!==c&&p.node.setWorkId(c),p.selectIds=l||[]}setNodeKey(t,e,s,o){return e.toolsType=s,e.node=bt({toolsType:s,toolsOpt:o,vNodes:this.vNodes,fullLayer:this.thread.fullLayer,drawLayer:this.thread.serviceLayer,workId:t},this),e}}class _{constructor(){u(this,"localWork"),u(this,"serviceWork"),u(this,"scene")}registerMainThread(t,e,s){return this.localWork=t,this.serviceWork=e,this.scene=s,this}}class ze extends _{constructor(){super(...arguments),u(this,"emitEventType",A.CopyNode)}async consume(t){const{msgType:e,dataType:s,emitEventType:o}=t;if(e===f.FullWork&&s===W.Local&&o===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:s}=t;s&&await((e=this.localWork)==null?void 0:e.consumeFull(t,this.scene))}}class Fe extends _{constructor(){super(...arguments),u(this,"emitEventType",A.SetColorNode)}async consume(t){const{msgType:e,dataType:s,emitEventType:o}=t;if(e===f.UpdateNode&&s===W.Local&&o===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:s,updateNodeOpt:o,willRefreshSelector:i,willSyncService:r,willSerializeData:n,textUpdateForWoker:a}=t;s===K.selectorId&&o&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:o,willRefreshSelector:i,willSyncService:r,willSerializeData:n,textUpdateForWoker:a,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:s,newServiceStore:o}=t,{willSyncService:i,isSync:r,textUpdateForWoker:n}=e,a=s.sp||[];if(i)for(const[l,c]of o.entries())n&&c.toolsType===k.Text?a.push({...c,workId:l,type:f.TextUpdate,dataType:W.Local,willSyncService:!0}):a.push({...c,workId:l,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:r});return{sp:a}}}class Ue extends _{constructor(){super(...arguments),u(this,"emitEventType",A.ZIndexNode)}async consume(t){const{msgType:e,dataType:s,emitEventType:o}=t;if(e===f.UpdateNode&&s===W.Local&&o===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:s,updateNodeOpt:o,willRefreshSelector:i,willSyncService:r,willSerializeData:n}=t;s===K.selectorId&&o&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:o,willRefreshSelector:i,willSyncService:r,willSerializeData:n,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:s,newServiceStore:o}=t,{willSyncService:i,isSync:r}=e,n=s.sp||[];if(i&&n)for(const[a,l]of o.entries())n.push({...l,workId:a,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:r});return{sp:n}}}class $e extends _{constructor(){super(...arguments),u(this,"emitEventType",A.TranslateNode)}async consume(t){const{msgType:e,dataType:s,emitEventType:o}=t;if(e===f.UpdateNode&&s===W.Local&&o===this.emitEventType)return await this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e,s;const{workId:o,updateNodeOpt:i,willRefreshSelector:r,willSyncService:n,willSerializeData:a,textUpdateForWoker:l,emitEventType:c}=t;o===K.selectorId&&i&&(i.workState===D.Done&&i!=null&&i.translate&&(i.translate[0]||i.translate[1])||i.workState!==D.Done?await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:i,willRefreshSelector:r,willSyncService:n,willSerializeData:a,isSync:!0,textUpdateForWoker:l,emitEventType:c,scene:this.scene,callback:this.updateSelectorCallback})):i.workState===D.Done&&((s=this.localWork)==null||s.vNodes.deleteLastTarget()))}updateSelectorCallback(t){const{param:e,postData:s,newServiceStore:o,workShapeNode:i,res:r}=t,{willSyncService:n,isSync:a,updateSelectorOpt:l,textUpdateForWoker:c}=e,p=l.workState,d=s.sp||[];if(p===D.Start)return{sp:[],render:[]};const h=r==null?void 0:r.selectRect;if(n){p===D.Doing&&d.push({type:f.Select,selectIds:i.selectIds,selectRect:h,willSyncService:!0,isSync:!0,points:i.getChildrenPoints(),textOpt:i.textOpt});for(const[w,y]of o.entries())c&&y.toolsType===k.Text?d.push({...y,workId:w,type:f.TextUpdate,dataType:W.Local,willSyncService:!0}):d.push({...y,workId:w,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:a})}return{sp:d}}}class Ye extends _{constructor(){super(...arguments),u(this,"emitEventType",A.DeleteNode)}async consume(){return!1}}class Xe extends _{constructor(){super(...arguments),u(this,"emitEventType",A.ScaleNode)}async consume(t){const{msgType:e,dataType:s,emitEventType:o}=t;if(e===f.UpdateNode&&s===W.Local&&o===this.emitEventType)return await this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:s,updateNodeOpt:o,willSyncService:i,willSerializeData:r}=t;s===K.selectorId&&o&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:o,willSyncService:i,willSerializeData:r,isSync:!0,scene:this.scene,callback:this.updateSelectorCallback.bind(this)}))}updateSelectorCallback(t){const{param:e,postData:s,workShapeNode:o,res:i,newServiceStore:r}=t,{updateSelectorOpt:n,willSyncService:a,willSerializeData:l}=e,c=n.workState,p=s.sp||[],d=i==null?void 0:i.selectRect;if(c===D.Start)return{sp:[],render:[]};if(a){c===D.Doing&&p.push({type:f.Select,selectIds:o.selectIds,selectRect:d,willSyncService:!0,isSync:!0,points:o.getChildrenPoints(),textOpt:o.textOpt}),l&&c===D.Done&&p.push({type:f.Select,selectIds:o.selectIds,selectRect:d,willSyncService:!1,isSync:!0,points:o.getChildrenPoints(),textOpt:o.textOpt});for(const[h,w]of r.entries())w.toolsType===k.Text?p.push({...w,workId:h,type:f.TextUpdate,dataType:W.Local,willSyncService:!0}):p.push({...w,workId:h,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:!0})}return{sp:p}}}class He extends _{constructor(){super(...arguments),u(this,"emitEventType",A.RotateNode)}async consume(t){const{msgType:e,dataType:s,emitEventType:o}=t;if(e===f.UpdateNode&&s===W.Local&&o===this.emitEventType)return await this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:s,updateNodeOpt:o,willRefreshSelector:i,willSyncService:r,willSerializeData:n,emitEventType:a}=t;s===K.selectorId&&o&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:o,willRefreshSelector:i,willSyncService:r,willSerializeData:n,emitEventType:a,isSync:!0,scene:this.scene,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:s,workShapeNode:o,res:i,newServiceStore:r}=t,{updateSelectorOpt:n,willSyncService:a,willSerializeData:l,isSync:c}=e,p=n.workState,d=s.sp||[],h=i==null?void 0:i.selectRect;if(a){l&&p===D.Done&&d.push({type:f.Select,selectIds:o.selectIds,selectRect:h,willSyncService:!0,isSync:c,points:o.getChildrenPoints()});for(const[w,y]of r.entries())d.push({...y,workId:w,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:c})}return{sp:d}}}class Ge extends _{constructor(){super(...arguments),u(this,"emitEventType",A.SetFontStyle)}async consume(t){const{msgType:e,dataType:s,emitEventType:o}=t;if(e===f.UpdateNode&&s===W.Local&&o===this.emitEventType)return await this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:s,updateNodeOpt:o,willRefreshSelector:i,willSyncService:r,willSerializeData:n,textUpdateForWoker:a}=t;s===K.selectorId&&o&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:o,willRefreshSelector:i,willSyncService:r,willSerializeData:n,textUpdateForWoker:a,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:s,newServiceStore:o,workShapeNode:i,res:r}=t,{willSyncService:n,isSync:a,updateSelectorOpt:l,textUpdateForWoker:c}=e,p=s.sp||[],d=r==null?void 0:r.selectRect;if(n&&p){l.fontSize&&p.push({type:f.Select,selectIds:i.selectIds,selectRect:d,willSyncService:n,isSync:a,points:i.getChildrenPoints()});for(const[h,w]of o.entries())c&&w.toolsType===k.Text?p.push({...w,workId:h,type:f.TextUpdate,dataType:W.Local,willSyncService:!0}):p.push({...w,workId:h,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:a})}return{sp:p}}}class je extends _{constructor(){super(...arguments),u(this,"emitEventType",A.SetPoint)}async consume(t){const{msgType:e,dataType:s,emitEventType:o}=t;if(e===f.UpdateNode&&s===W.Local&&o===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:s,updateNodeOpt:o,willRefreshSelector:i,willSyncService:r,willSerializeData:n,textUpdateForWoker:a}=t;s===K.selectorId&&o&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:o,willRefreshSelector:i,willSyncService:r,emitEventType:this.emitEventType,willSerializeData:n,isSync:!0,textUpdateForWoker:a,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:s,newServiceStore:o,workShapeNode:i,res:r}=t,{willSyncService:n,isSync:a}=e,l=s.sp||[],c=r==null?void 0:r.selectRect;if(n&&l){for(const[p,d]of o.entries())l.push({...d,workId:p,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:a});l.push({type:f.Select,selectIds:i.selectIds,selectRect:c,willSyncService:n,isSync:a,points:i.getChildrenPoints()})}return{sp:l}}}class qe extends _{constructor(){super(...arguments),u(this,"emitEventType",A.SetLock)}async consume(t){const{msgType:e,dataType:s,emitEventType:o}=t;if(e===f.UpdateNode&&s===W.Local&&o===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:s,updateNodeOpt:o,willRefreshSelector:i,willSyncService:r,willSerializeData:n}=t;s===K.selectorId&&o&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:o,willRefreshSelector:i,willSyncService:r,willSerializeData:n,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:s,newServiceStore:o,workShapeNode:i,res:r}=t,{willSyncService:n,isSync:a,updateSelectorOpt:l}=e,c=s.sp||[],p=r==null?void 0:r.selectRect;if(n&&c){for(const[d,h]of o.entries())c.push({...h,workId:d,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:a});c.push({isLocked:l.isLocked,selectorColor:i.selectorColor,scaleType:i.scaleType,canRotate:i.canRotate,type:f.Select,selectIds:i.selectIds,selectRect:p,willSyncService:n,isSync:a})}return{sp:c}}}class Ve extends _{constructor(){super(...arguments),u(this,"emitEventType",A.SetShapeOpt)}async consume(t){const{msgType:e,dataType:s,emitEventType:o}=t;if(e===f.UpdateNode&&s===W.Local&&o===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:s,updateNodeOpt:o,willRefreshSelector:i,willSyncService:r,willSerializeData:n}=t;s===K.selectorId&&o&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:o,willRefreshSelector:i,willSyncService:r,willSerializeData:n,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:s,newServiceStore:o}=t,{willSyncService:i,isSync:r}=e,n=s.sp||[];if(i&&n)for(const[a,l]of o.entries())n.push({...l,workId:a,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:r});return{sp:n}}}class Ze{constructor(t){u(this,"builders",new Map),this.builders=new Map(t.map(e=>[e,this.build(e)]))}build(t){switch(t){case A.TranslateNode:return new $e;case A.ZIndexNode:return new Ue;case A.CopyNode:return new ze;case A.SetColorNode:return new Fe;case A.DeleteNode:return new Ye;case A.ScaleNode:return new Xe;case A.RotateNode:return new He;case A.SetFontStyle:return new Ge;case A.SetPoint:return new je;case A.SetLock:return new qe;case A.SetShapeOpt:return new Ve}}registerForMainThread(t,e,s){return this.builders.forEach(o=>{o&&o.registerMainThread(t,e,s)}),this}async consumeForMainThread(t){for(const e of this.builders.values())if(await(e==null?void 0:e.consume(t)))return!0;return!1}}class Je{constructor(t,e){u(this,"viewId"),u(this,"fullLayer"),u(this,"topLayer"),u(this,"localLayer"),u(this,"serviceLayer"),u(this,"snapshotFullLayer"),u(this,"vNodes"),u(this,"master"),u(this,"opt"),u(this,"cameraOpt"),u(this,"scene"),u(this,"localWork"),u(this,"serviceWork"),u(this,"topWork"),u(this,"taskUpdateCameraId"),u(this,"debounceUpdateCameraId"),u(this,"debounceUpdateCache",new Set),u(this,"mainThreadPostId"),u(this,"combinePostMsg",new Set),u(this,"methodBuilder"),this.viewId=t,this.opt=e,this.scene=this.createScene({...e.canvasOpt,container:e.container}),this.master=e.master;const s=dt.bufferSize.full,o=dt.bufferSize.sub;this.fullLayer=this.createLayer("fullLayer",this.scene,{...e.layerOpt,bufferSize:this.viewId===wt?s:o}),this.topLayer=this.createLayer("topLayer",this.scene,{...e.layerOpt,bufferSize:(this.viewId,wt,o)}),this.localLayer=this.createLayer("localLayer",this.scene,{...e.layerOpt,bufferSize:(this.viewId,wt,o)}),this.serviceLayer=this.createLayer("serviceLayer",this.scene,{...e.layerOpt,bufferSize:(this.viewId,wt,o)}),this.vNodes=new De(t,this.scene);const i={thread:this,vNodes:this.vNodes};this.localWork=new Ee(i),this.serviceWork=new Be(i),this.topWork=new Ae(i),this.vNodes.init(this.fullLayer),this.methodBuilder=new Ze([A.CopyNode,A.SetColorNode,A.DeleteNode,A.RotateNode,A.ScaleNode,A.TranslateNode,A.ZIndexNode,A.SetFontStyle,A.SetPoint,A.SetLock,A.SetShapeOpt]).registerForMainThread(this.localWork,this.serviceWork,this.scene)}post(t){this.combinePostMsg.add(t),this.runBatchPostData()}async on(t){if(!await this.methodBuilder.consumeForMainThread(t)){const{msgType:e,toolsType:s,opt:o,dataType:i,workId:r,workState:n}=t,a=r==null?void 0:r.toString();switch(e){case f.Destroy:this.destroy();break;case f.Clear:this.clearAll();break;case f.UpdateCamera:await this.updateCamera(t);break;case f.UpdateTools:if(s&&o){const l={toolsType:s,toolsOpt:o};this.topWork.canUseTopLayer(s)?this.topWork.setToolsOpt(l):this.localWork.setToolsOpt(l)}break;case f.CreateWork:if(a&&o&&s){if(this.topWork.canUseTopLayer(s)){this.topWork.getToolsOpt()||this.topWork.setToolsOpt({toolsType:s,toolsOpt:o}),this.topWork.setWorkOptions(a,o);break}this.localWork.getToolsOpt()||this.localWork.setToolsOpt({toolsType:s,toolsOpt:o}),this.localWork.setWorkOptions(a,o)}break;case f.DrawWork:n===D.Done&&i===W.Local?this.consumeDrawAll(i,t):this.consumeDraw(i,t);break;case f.UpdateNode:case f.FullWork:if(s&&this.topWork.canUseTopLayer(s)){this.consumeDrawAll(i,t);break}this.consumeFull(i,t);break;case f.RemoveNode:await this.removeNode(t);return;case f.Select:i===W.Service&&(r===X?this.localWork.updateFullSelectWork(t):this.serviceWork.runSelectWork(t));break;case f.CursorHover:this.localWork.cursorHover(t);break;case f.GetTextActive:i===W.Local&&this.localWork.checkTextActive(t);break}}}async removeNode(t){const{dataType:e,workId:s,removeIds:o}=t,i=o||[];if(s&&i.push(s.toString()),i.length)for(const r of i){if(r===X){await this.localWork.removeSelector(t);continue}e===W.Local?this.localWork.removeWork(t):e===W.Service&&this.serviceWork.removeWork(t),await this.localWork.colloctEffectSelectWork(t)}}async consumeFull(t,e){const s=await this.localWork.colloctEffectSelectWork(e);s&&t===W.Local&&await this.localWork.consumeFull(s,this.scene),s&&t===W.Service&&this.serviceWork.consumeFull(s)}setCameraOpt(t){this.cameraOpt=t;const{scale:e,centerX:s,centerY:o,width:i,height:r}=t;(i!==this.scene.width||r!==this.scene.height)&&this.updateScene({width:i,height:r}),this.fullLayer.setAttribute("scale",[e,e]),this.fullLayer.setAttribute("translate",[-s,-o]),this.topLayer.setAttribute("scale",[e,e]),this.topLayer.setAttribute("translate",[-s,-o]),this.localLayer.setAttribute("scale",[e,e]),this.localLayer.setAttribute("translate",[-s,-o]),this.serviceLayer.setAttribute("scale",[e,e]),this.serviceLayer.setAttribute("translate",[-s,-o])}runBatchPostData(){this.mainThreadPostId||(this.mainThreadPostId=requestAnimationFrame(this.combinePost.bind(this)))}combinePostData(){var t;this.mainThreadPostId=void 0;const e=[];let s;for(const o of this.combinePostMsg.values()){if((t=o.sp)!=null&&t.length)for(const i of o.sp){let r=!1;for(const n of e)if(pt.isEqual(i,n)){r=!0;break}r||e.push(i)}pt.isNumber(o.drawCount)&&(s=o.drawCount)}return this.combinePostMsg.clear(),{sp:e,drawCount:s}}combinePost(){var t,e;const s=this.combinePostData(),o=(t=s.sp)==null?void 0:t.filter(i=>i.type!==f.None);o!=null&&o.length?s.sp=o.map(i=>i.viewId?i:{...i,viewId:this.viewId}):delete s.sp,s.drawCount===void 0&&delete s.drawCount,(s!=null&&s.drawCount||(e=s.sp)!=null&&e.length)&&this.opt.post(s)}clearAll(){this.fullLayer.children.length&&(this.fullLayer.parent.children.forEach(t=>{t.name!=="viewport"&&t.remove()}),this.fullLayer.removeAllChildren()),this.localWork.clearAll(),this.topWork.clearAll(),this.serviceWork.clearAll(),this.vNodes.clear(),this.post({sp:[{type:f.Clear}]})}consumeDrawAll(t,e){const{toolsType:s,workId:o}=e;if(o){const i=o.toString();if(s&&this.topWork.canUseTopLayer(s)){t===W.Local&&(this.topWork.getLocalWorkShape(o.toString())||this.topWork.createLocalWork(e)),this.topWork.consumeDrawAll(e);return}t===W.Local&&(this.localWork.getWorkShape(i)||this.localWork.createLocalWork(e),this.localWork.consumeDrawAll(e,this.serviceWork))}}consumeDraw(t,e){const{opt:s,workId:o,toolsType:i}=e;if(o&&i&&s){const r=o.toString();if(this.topWork.canUseTopLayer(i)){t===W.Local&&(this.topWork.getLocalWorkShape(r)||this.topWork.createLocalWork(e)),this.topWork.consumeDraw(e);return}t===W.Local?(this.localWork.getWorkShape(r)||this.localWork.createLocalWork(e),this.localWork.consumeDraw(e,this.serviceWork)):t===W.Service&&this.serviceWork.consumeDraw(e);return}}async updateCamera(t){var e;const{cameraOpt:s,scenePath:o}=t;if(s&&!pt.isEqual(this.cameraOpt,s)){if(this.taskUpdateCameraId&&(clearTimeout(this.taskUpdateCameraId),this.taskUpdateCameraId=void 0),o){let l=!1;for(const[c,p]of this.localWork.getWorkShapes().entries())if(p.toolsType!==k.Text&&p.toolsType!==k.Eraser&&p.toolsType!==k.Selector&&p.toolsType!==k.LaserPen&&c!==Wt&&c!==X){l=!0;break}if(l){this.taskUpdateCameraId=setTimeout(()=>{this.taskUpdateCameraId=void 0,this.updateCamera(t)},Ft);return}}const i=new Map;for(const[l,c]of this.vNodes.getNodesByType(k.Text).entries()){const p=c.rect;i.set(l,pt.cloneDeep(p))}const r=new Set(i.keys());let n=!1;if(this.localWork.hasSelector()){const l=(e=this.localWork.getSelector())==null?void 0:e.selectIds;if(l){n=!0;for(const c of l)r.add(c)}}let a=!1;if(this.serviceWork.selectorWorkShapes.size)for(const l of this.serviceWork.selectorWorkShapes.values()){const c=l.selectIds;if(c){a=!0;for(const p of c)r.add(p)}}if(this.setCameraOpt(s),this.vNodes.curNodeMap.size){this.vNodes.clearTarget(),this.vNodes.updateHighLevelNodesRect(r),this.debounceUpdateCameraId&&clearTimeout(this.debounceUpdateCameraId);for(const[l,c]of i.entries()){const p=this.vNodes.get(l);if(p){const d=c,h=p.rect,w=this.getSceneRect(),y=Rt(d,w),m=Rt(h,w);let T=!1;if((y!==m||d.w!==h.w||d.h!==h.h||m===Ut.intersect)&&(T=!0),T){const{toolsType:b,opt:I}=p;b===k.Text&&I.workState===D.Done&&this.debounceUpdateCache.add(l)}}}if(n&&this.localWork.reRenderSelector(),a)for(const[l,c]of this.serviceWork.selectorWorkShapes.entries())this.serviceWork.runSelectWork({workId:l,selectIds:c.selectIds,msgType:f.Select,dataType:W.Service,viewId:this.viewId});this.debounceUpdateCameraId=setTimeout(()=>{var l;this.debounceUpdateCameraId=void 0;const c=[];for(const p of this.debounceUpdateCache.values()){if((l=this.fullLayer)!=null&&l.getElementsByName(p)[0]){const d=this.vNodes.get(p);if(d){const{toolsType:h,opt:w,rect:y}=d,m=this.localWork.setFullWork({toolsType:h,opt:w,workId:p});if(m){const T=this.getSceneRect(),b=Rt(y,T);c.push(m.consumeServiceAsync({isFullWork:!0,replaceId:p,isDrawLabel:b!==Ut.outside}))}}}this.debounceUpdateCache.delete(p)}this.vNodes.updateLowLevelNodesRect(),this.vNodes.clearHighLevelIds()},Ft)}}}getSceneRect(){const{width:t,height:e}=this.scene;return{x:0,y:0,w:Math.floor(t),h:Math.floor(e)}}createScene(t){return new Yt({displayRatio:this.opt.displayer.dpr,depth:!1,desynchronized:!0,...t,autoRender:!0,id:this.viewId})}createLayer(t,e,s){const{width:o,height:i}=s,r=`canvas-${t}`,n=e.layer(r,{...s,offscreen:!1}),a=new J({anchor:[.5,.5],pos:[o*.5,i*.5],size:[o,i],name:"viewport",id:t});return n.append(a),a}updateScene(t){this.scene.attr({...t});const{width:e,height:s}=t;this.scene.width=e,this.scene.height=s,this.updateLayer({width:e,height:s})}updateLayer(t){const{width:e,height:s}=t;this.fullLayer.parent.setAttribute("width",e),this.fullLayer.parent.setAttribute("height",s),this.fullLayer.setAttribute("size",[e,s]),this.fullLayer.setAttribute("pos",[e*.5,s*.5]),this.topLayer.parent.setAttribute("width",e),this.topLayer.parent.setAttribute("height",s),this.topLayer.setAttribute("size",[e,s]),this.topLayer.setAttribute("pos",[e*.5,s*.5]),this.localLayer.parent.setAttribute("width",e),this.localLayer.parent.setAttribute("height",s),this.localLayer.setAttribute("size",[e,s]),this.localLayer.setAttribute("pos",[e*.5,s*.5]),this.serviceLayer.parent.setAttribute("width",e),this.serviceLayer.parent.setAttribute("height",s),this.serviceLayer.setAttribute("size",[e,s]),this.serviceLayer.setAttribute("pos",[e*.5,s*.5])}destroy(){this.vNodes.clear(),this.fullLayer.remove(),this.topLayer.remove(),this.localLayer.remove(),this.serviceLayer.remove(),this.scene.remove(),this.localWork.destroy(),this.serviceWork.destroy(),this.topWork.destroy()}}class Qe{constructor(t,e){u(this,"viewId"),u(this,"fullLayer"),u(this,"master"),u(this,"opt"),u(this,"scene"),u(this,"mainThreadPostId"),u(this,"combinePostMsg",new Set),u(this,"workShapes",new Map),this.viewId=t,this.opt=e,this.scene=this.createScene({...e.canvasOpt,container:e.container}),this.master=e.master,this.fullLayer=this.createLayer("fullLayer",this.scene,{...e.layerOpt,bufferSize:this.viewId===wt?6e3:3e3})}post(t){this.combinePostMsg.add(t),this.runBatchPostData()}async on(t){const{msgType:e}=t;switch(e){case f.Snapshot:await this.getSnapshot(t),this.destroy();return;case f.BoundingBox:await this.getBoundingRect(t),this.destroy();return}}createWorkShapeNode(t){return bt({...t,fullLayer:this.fullLayer,drawLayer:void 0})}setFullWork(t){const{workId:e,opt:s,toolsType:o}=t;if(e&&s&&o){const i=e.toString();let r;return e&&this.workShapes.has(i)?(r=this.workShapes.get(i),r==null||r.setWorkOptions(s)):r=this.createWorkShapeNode({toolsOpt:s,toolsType:o,workId:i}),r?(this.workShapes.set(i,r),r):void 0}}async runFullWork(t){var e,s;const o=this.setFullWork(t),i=t.ops&&ut(t.ops);if(o){let r,n;const a=(e=o.getWorkId())==null?void 0:e.toString();return o.toolsType===k.Image?r=await o.consumeServiceAsync({isFullWork:!0,scene:(s=this.fullLayer.parent)==null?void 0:s.parent,isMainThread:!0}):o.toolsType===k.Text?r=await o.consumeServiceAsync({isFullWork:!0,replaceId:a,isDrawLabel:!0}):(r=o.consumeService({op:i,isFullWork:!0,replaceId:a}),n=(t==null?void 0:t.updateNodeOpt)&&o.updataOptService(t.updateNodeOpt)),E(r,n)}}async getSnapshot(t){const{scenePath:e,scenes:s,cameraOpt:o,w:i,h:r}=t;if(e&&s&&o){this.setCameraOpt(o);let n;for(const[l,c]of Object.entries(s))if(c!=null&&c.type)switch(c==null?void 0:c.type){case f.UpdateNode:case f.FullWork:{const{opt:p}=c,d=await this.runFullWork({...c,opt:p,workId:l,msgType:f.FullWork,dataType:W.Service,viewId:this.viewId});n=E(n,d);break}}let a;i&&r&&(a={resizeWidth:i,resizeHeight:r}),await this.getSnapshotRender({scenePath:e,options:a})}}getSceneRect(){const{width:t,height:e}=this.scene;return{x:0,y:0,w:Math.floor(t),h:Math.floor(e)}}getRectImageBitmap(t,e){const s=Math.floor(t.x*this.opt.displayer.dpr),o=Math.floor(t.y*this.opt.displayer.dpr),i=t.w>0&&Math.floor(t.w*this.opt.displayer.dpr||1)||1,r=t.h>0&&Math.floor(t.h*this.opt.displayer.dpr||1)||1;return createImageBitmap(this.fullLayer.parent.canvas,s,o,i,r,e)}async getSnapshotRender(t){var e,s;const{scenePath:o,options:i}=t;((e=this.fullLayer)==null?void 0:e.parent).render();const r=await this.getRectImageBitmap(this.getSceneRect(),i);r&&(this.post({sp:[{type:f.Snapshot,scenePath:o,imageBitmap:r,viewId:this.viewId}]}),(s=this.fullLayer)==null||s.removeAllChildren())}async getBoundingRect(t){const{scenePath:e,scenes:s,cameraOpt:o}=t;if(e&&s&&o){this.setCameraOpt(o);let i;for(const[r,n]of Object.entries(s))if(n!=null&&n.type)switch(n==null?void 0:n.type){case f.UpdateNode:case f.FullWork:{const a=await this.runFullWork({...n,workId:r,msgType:f.FullWork,dataType:W.Service,viewId:this.viewId});i=E(i,a);break}}i&&this.post({sp:[{type:f.BoundingBox,scenePath:e,rect:i}]})}}setCameraOpt(t){const{scale:e,centerX:s,centerY:o,width:i,height:r}=t;this.updateScene({width:i,height:r}),this.fullLayer.setAttribute("scale",[e,e]),this.fullLayer.setAttribute("translate",[-s,-o])}runBatchPostData(){this.mainThreadPostId||(this.mainThreadPostId=requestAnimationFrame(this.combinePost.bind(this)))}combinePostData(){var t;this.mainThreadPostId=void 0;const e=[];for(const s of this.combinePostMsg.values())if((t=s.sp)!=null&&t.length)for(const o of s.sp){let i=!1;for(const r of e)if(Lt(o,r)){i=!0;break}i||e.push(o)}return this.combinePostMsg.clear(),{sp:e}}combinePost(){var t,e;const s=this.combinePostData(),o=(t=s.sp)==null?void 0:t.filter(i=>i.type!==f.None);o!=null&&o.length?s.sp=o.map(i=>i.viewId?i:{...i,viewId:this.viewId}):delete s.sp,(s!=null&&s.drawCount||(e=s.sp)!=null&&e.length)&&this.opt.post(s)}createScene(t){return new Yt({displayRatio:this.opt.displayer.dpr,depth:!1,desynchronized:!0,...t,autoRender:!1})}createLayer(t,e,s){const{width:o,height:i}=s,r=`canvas-${t}`,n=e.layer(r,s),a=new J({anchor:[.5,.5],pos:[o*.5,i*.5],size:[o,i],name:"viewport",id:t});return n.append(a),a}updateScene(t){this.scene.attr({...t});const{width:e,height:s}=t;this.scene.width=e,this.scene.height=s,this.updateLayer({width:e,height:s})}updateLayer(t){const{width:e,height:s}=t;this.fullLayer.parent.setAttribute("width",e),this.fullLayer.parent.setAttribute("height",s),this.fullLayer.setAttribute("size",[e,s]),this.fullLayer.setAttribute("pos",[e*.5,s*.5])}destroy(){this.fullLayer.remove(),this.scene.remove()}}class _e{constructor(t){u(this,"mainThreadMap",new Map),u(this,"snapshotThread"),u(this,"master"),this.master=t}post(t){const{drawCount:e,sp:s,workerTasksqueueCount:o}=t;this.master.isBusy&&Z(o)&&this.master.setWorkerTasksqueueCount(o),Z(e)&&this.master.setMaxDrawCount(e),s&&this.master.collectorSyncData(s)}destroy(){this.mainThreadMap.clear()}createMainThread(t,e){return new Je(t,e)}createSnapshotThread(t,e){return new Qe(t,e)}async consume(t){var e,s,o,i;for(const r of t.values()){const{msgType:n,viewId:a,tasksqueue:l,mainTasksqueueCount:c,layerOpt:p,offscreenCanvasOpt:d,cameraOpt:h}=r;if(n===f.Console){console.log(this);continue}if(n===f.Init){const y=(e=this.master.control.viewContainerManager.getView(a))==null?void 0:e.displayer,m=y==null?void 0:y.canvasContainerRef.current;if(y&&m&&p&&d){const T=this.createMainThread(a,{displayer:y,container:m,layerOpt:p,master:this.master,canvasOpt:d,post:this.post.bind(this)});this.mainThreadMap.set(a,T),T&&h&&T.setCameraOpt(h)}continue}if((n===f.Snapshot||n===f.BoundingBox)&&a===((s=this.master.control.viewContainerManager.mainView)==null?void 0:s.id)){const y=(o=this.master.control.viewContainerManager.getView(a))==null?void 0:o.displayer,m=(i=y.snapshotContainerRef)==null?void 0:i.current;if(y&&m&&h){m.style.width=`${h.width}px`,m.style.height=`${h.height}px`;const T={...zt.defaultLayerOpt,offscreen:!1,width:h.width,height:h.height},b={...zt.defaultScreenCanvasOpt,width:h.width,height:h.height};this.snapshotThread=this.createSnapshotThread(a,{displayer:y,container:m,layerOpt:T,master:this.master,canvasOpt:b,post:this.post.bind(this)}),this.snapshotThread.on(r).then(()=>{this.snapshotThread=void 0,m.innerHTML="",m.style.width="",m.style.height=""});continue}}if(n===f.TasksQueue&&l!=null&&l.size){for(const[y,m]of this.mainThreadMap.entries()){const T=l.get(y);T&&(await m.on(T),c&&this.post({workerTasksqueueCount:c}))}continue}if(a===ce){for(const y of this.mainThreadMap.values())y.on(r),n===f.Destroy&&this.mainThreadMap.delete(a);continue}const w=this.mainThreadMap.get(a);w&&(w.on(r),n===f.Destroy&&this.mainThreadMap.delete(a))}}}export{_e as MainThreadManagerImpl};
