import{d as q,D as f,u as St,U as Ut,E as X,S as E,G as C,N as v,j as D,g as nt,_ as vt,a as G,R as ct,m as B,b as Z,o as b,Q as F,c as $t,z as ht,C as Tt,x as Xt,e as U,f as k,T as lt,h as Yt,i as yt,k as wt,l as _,n as qt,W as V,p as jt,B as $,q as st,r as ot,s as gt,t as Pt,v as Vt,w as It,y as Gt,L as it,A as rt}from"./index-VRBR4zxZ.js";var Ht=Object.defineProperty,Kt=(R,t,e)=>t in R?Ht(R,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):R[t]=e,m=(R,t,e)=>(Kt(R,typeof t!="symbol"?t+"":t,e),e);const Nt=class Q{constructor(t){m(this,"syncUnitTime",1e3),m(this,"vNodes"),m(this,"drawLayer"),m(this,"fullLayer"),m(this,"workId");const{vNodes:e,fullLayer:o,drawLayer:s}=t;this.vNodes=e,this.fullLayer=o,this.drawLayer=s}setWorkId(t){this.workId=t}getWorkId(){return this.workId}getWorkOptions(){return this.workOptions}setWorkOptions(t){var e,o,s;this.workOptions=t,this.syncUnitTime=t.syncUnitTime||this.syncUnitTime;const i=(e=this.workId)==null?void 0:e.toString(),r=i&&((o=this.vNodes)==null?void 0:o.get(i))||void 0;i&&r&&(r.opt=t,(s=this.vNodes)==null||s.setInfo(i,r))}updataOptService(t){var e,o;let s;const i=(e=this.workId)==null?void 0:e.toString();if(i&&t){const r=this.fullLayer.getElementsByName(i)||this.drawLayer&&this.drawLayer.getElementsByName(i)||[];if(r.length!==1)return;const n=r[0],{pos:a,zIndex:l,scale:c,angle:p,translate:h}=t,d={};q(l)&&(d.zIndex=l),a&&(d.pos=[a[0],a[1]]),c&&(d.scale=c),p&&(d.rotate=p),h&&(d.translate=h),n.attr(d);const u=n==null?void 0:n.getBoundingClientRect();return u&&(s=B(s,{x:Math.floor(u.x-Q.SafeBorderPadding),y:Math.floor(u.y-Q.SafeBorderPadding),w:Math.floor(u.width+Q.SafeBorderPadding*2),h:Math.floor(u.height+Q.SafeBorderPadding*2)})),(o=this.vNodes)==null||o.setInfo(i,{rect:s,centerPos:a}),s}}static updateNodeOpt(t){const{node:e,opt:o,vNodes:s,willSerializeData:i,targetNode:r}=t,{zIndex:n,translate:a,angle:l,box:c,boxScale:p,boxTranslate:h,pointMap:d}=o;let u;const y=r&&Z(r)||s.get(e.name);if(!y)return;q(n)&&(e.setAttribute("zIndex",n),y.opt.zIndex=n);const w=e.parent;if(w){if(c&&h&&p){const{rect:T}=y,N=[];for(let z=0;z<y.op.length;z+=3)N.push(new b(y.op[z],y.op[z+1],y.op[z+2]));const I=F(N),S=[I.w*w.worldScaling[0],I.h*w.worldScaling[0]],g=[T.w-S[0],T.h-S[1]],x=[(T.w*p[0]-g[0])/S[0],(T.h*p[1]-g[1])/S[1]],M=[h[0]/w.worldScaling[0],h[1]/w.worldScaling[1]],W=y.op.map((z,A)=>{const Y=A%3;return Y===0?z+M[0]:Y===1?z+M[1]:z}),L=[y.centerPos[0]+M[0],y.centerPos[1]+M[1]];$t(W,L,x);const O=[];for(let z=0;z<W.length;z+=3)O.push(new b(W[z],W[z+1],W[z+2]));y.op=W,y.centerPos=L}else if(a){const T=[a[0]/w.worldScaling[0],a[1]/w.worldScaling[1]];e.setAttribute("translate",T),y.opt.translate=T,r&&(u=ht(y.rect,a),y.rect=u)}else q(l)&&(e.setAttribute("rotate",l),y.opt.rotate=l,r&&(u=Tt(y.rect,l),y.rect=u));if(d){const T=d.get(e.name);if(T)for(let N=0,I=0;N<y.op.length;N+=3,I++)y.op[N]=T[I][0],y.op[N+1]=T[I][1]}if(i){if(a){const T=[a[0]/w.worldScaling[0],a[1]/w.worldScaling[1]],N=y.op.map((I,S)=>{const g=S%3;return g===0?I+T[0]:g===1?I+T[1]:I});y.op=N,y.centerPos=[y.centerPos[0]+T[0],y.centerPos[1]+T[1]],y!=null&&y.opt&&(y.opt.translate=void 0)}else if(q(l)){const T=y.op;Xt(T,y.centerPos,l),y.op=T,y!=null&&y.opt&&(y.opt.rotate=void 0)}}y&&s.setInfo(e.name,y)}}static getCenterPos(t,e){const{worldPosition:o,worldScaling:s}=e;return[(t.x+t.w/2-o[0])/s[0],(t.y+t.h/2-o[1])/s[1]]}static getRectFromLayer(t,e){const o=t.getElementsByName(e)[0];if(o){const s=o.getBoundingClientRect();return{x:Math.floor(s.x-Q.SafeBorderPadding),y:Math.floor(s.y-Q.SafeBorderPadding),w:Math.floor(s.width+Q.SafeBorderPadding*2),h:Math.floor(s.height+Q.SafeBorderPadding*2)}}}};m(Nt,"SafeBorderPadding",10);let P=Nt;function at(R,t=!0){const e=R.length;if(e<2)return"";let o=R[0],s=R[1];if(e===2)return`M${it(o)}L${it(s)}`;let i="";for(let r=2,n=e-1;r<n;r++)o=R[r],s=R[r+1],i+=rt(o,s);return t?`M${rt(R[0],R[1])}Q${it(R[1])}${rt(R[1],R[2])}T${i}${rt(R[e-1],R[0])}${rt(R[0],R[1])}Z`:`M${it(R[0])}Q${it(R[1])}${rt(R[1],R[2])}${R.length>3?"T":""}${i}L${it(R[e-1])}`}class Wt extends P{constructor(t){super(t),m(this,"canRotate",!0),m(this,"scaleType",U.all),m(this,"toolsType",v.Pencil),m(this,"syncTimestamp"),m(this,"syncIndex",0),m(this,"tmpPoints",[]),m(this,"MAX_REPEAR",10),m(this,"uniThickness"),m(this,"workOptions"),m(this,"centerPos",[0,0]),this.workOptions=t.toolsOpt,this.uniThickness=this.MAX_REPEAR/this.workOptions.thickness/10,this.syncTimestamp=0}combineConsume(){var t;const e=(t=this.workId)==null?void 0:t.toString(),o=this.transformDataAll(!0),s={name:e};let i;const r=this.drawLayer||this.fullLayer;return o.length&&(i=this.draw({attrs:s,tasks:o,replaceId:e,layer:r,isClearAll:!0})),{rect:i,type:f.DrawWork,dataType:C.Local}}setWorkOptions(t){super.setWorkOptions(t),this.syncTimestamp=Date.now()}consume(t){var e;const{data:o,isFullWork:s,isClearAll:i,isSubWorker:r,isMainThread:n}=t;if(((e=o.op)==null?void 0:e.length)===0)return{type:f.None};const{workId:a}=o,{tasks:l,effects:c,consumeIndex:p}=this.transformData(o,!1);this.syncIndex=Math.min(this.syncIndex,p,Math.max(0,this.tmpPoints.length-2));const h={name:a==null?void 0:a.toString()};let d,u=!1;const y=this.syncIndex;if(this.syncTimestamp===0&&(this.syncTimestamp=Date.now()),l.length&&(l[0].taskId-this.syncTimestamp>this.syncUnitTime&&(u=!0,this.syncTimestamp=l[0].taskId,this.syncIndex=this.tmpPoints.length),r||n)){const T=s?this.fullLayer:this.drawLayer||this.fullLayer;d=this.draw({attrs:h,tasks:l,effects:c,layer:T,isClearAll:i})}if(r)return p>10&&this.tmpPoints.splice(0,p-10),{rect:d,type:f.DrawWork,dataType:C.Local};const w=[];return this.tmpPoints.slice(y).forEach(T=>{w.push(T.x,T.y,this.computRadius(T.z,this.workOptions.thickness))}),{rect:d,type:f.DrawWork,dataType:C.Local,workId:u?a:void 0,op:u?w:void 0,index:u?y*3:void 0}}consumeAll(t){var e,o,s;if(t.data){const{op:h,workState:d}=t.data;h!=null&&h.length&&d===D.Done&&this.workOptions.strokeType===$.Stroke&&this.updateTempPointsWithPressureWhenDone(h)}const i=(e=this.workId)==null?void 0:e.toString();if(!i)return{type:f.None};const r=this.transformDataAll(!0),n={name:i};let a;const l=this.fullLayer;r.length&&(a=this.draw({attrs:n,tasks:r,replaceId:i,layer:l,isClearAll:!1}));const c=[];this.tmpPoints.map(h=>{c.push(h.x,h.y,this.computRadius(h.z,this.workOptions.thickness))}),this.syncTimestamp=0,delete this.workOptions.syncUnitTime;const p=V(c);return(o=this.vNodes)==null||o.setInfo(i,{rect:a,op:c,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&P.getCenterPos(a,l)}),{rect:a,type:f.FullWork,dataType:C.Local,workId:i,ops:p,updateNodeOpt:{pos:this.centerPos,useAnimation:!0},opt:this.workOptions,undoTickerId:(s=t.data)==null?void 0:s.undoTickerId}}clearTmpPoints(){this.tmpPoints.length=0,this.syncTimestamp=0,this.syncIndex=0}consumeService(t){var e,o;const{op:s,isFullWork:i,replaceId:r,isClearAll:n}=t;this.tmpPoints.length=0;for(let h=0;h<s.length;h+=3){const d=new b(s[h],s[h+1],s[h+2]);if(this.tmpPoints.length>0){const u=this.tmpPoints[this.tmpPoints.length-1],y=k.Sub(d,u).uni();d.setv(y)}this.tmpPoints.push(d)}const a=this.transformDataAll(!1),l=(e=this.workId)==null?void 0:e.toString(),c={name:l};let p;if(l&&a.length){const h=i?this.fullLayer:this.drawLayer||this.fullLayer;p=this.draw({attrs:c,tasks:a,replaceId:r,layer:h,isClearAll:n}),(o=this.vNodes)==null||o.setInfo(l,{rect:p,op:s,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:p&&P.getCenterPos(p,h)})}return p}transformDataAll(t=!0){return this.getTaskPoints(this.tmpPoints,t&&this.workOptions.thickness||void 0)}draw(t){var e;const{attrs:o,tasks:s,replaceId:i,effects:r,layer:n,isClearAll:a}=t,{strokeColor:l,strokeType:c,thickness:p,zIndex:h,scale:d,rotate:u,translate:y}=this.workOptions;a&&n.removeAllChildren(),i&&(this.fullLayer.getElementsByName(i+"").map(g=>g.remove()),(e=this.drawLayer)==null||e.getElementsByName(i+"").map(g=>g.remove())),r!=null&&r.size&&(r.forEach(g=>{var x;(x=n.getElementById(g+""))==null||x.remove()}),r.clear());let w;const T=[],N=n.worldPosition,I=n.worldScaling;for(let g=0;g<s.length;g++){const{pos:x,points:M,taskId:W}=s[g];o.id=W.toString();const{ps:L,rect:O}=this.computDrawPoints(M);let z;const A=M.length===1;c===$.Stroke||A?z=at(L,!0):z=at(L,!1);const Y={pos:x,d:z,fillColor:c===$.Stroke||A?l:void 0,lineDash:c===$.Dotted&&!A?[1,p*2]:c===$.LongDotted&&!A?[p,p*2]:void 0,strokeColor:l,lineCap:c===$.Stroke||A?void 0:"round",lineWidth:c===$.Stroke||A?0:p};w=B(w,{x:Math.floor((O.x+x[0])*I[0]+N[0]-P.SafeBorderPadding),y:Math.floor((O.y+x[1])*I[1]+N[1]-P.SafeBorderPadding),w:Math.floor(O.w*I[0]+2*P.SafeBorderPadding),h:Math.floor(O.h*I[1]+2*P.SafeBorderPadding)}),T.push(Y)}d&&(o.scale=d),u&&(o.rotate=u),y&&(o.translate=y);const S=new G;if(w){this.centerPos=P.getCenterPos(w,n),S.attr({...o,normalize:!0,id:o.name,anchor:[.5,.5],bgcolor:c===$.Stroke?l:void 0,pos:this.centerPos,size:[(w.w-2*P.SafeBorderPadding)/I[0],(w.h-2*P.SafeBorderPadding)/I[1]],zIndex:h});const g=T.map(x=>(x.pos=[x.pos[0]-this.centerPos[0],x.pos[1]-this.centerPos[1]],new st(x)));S.append(...g),c===$.Stroke&&S.seal(),n.append(S)}if(d||u||y){const g=S==null?void 0:S.getBoundingClientRect();if(g)return{x:Math.floor(g.x-P.SafeBorderPadding),y:Math.floor(g.y-P.SafeBorderPadding),w:Math.floor(g.width+P.SafeBorderPadding*2),h:Math.floor(g.height+P.SafeBorderPadding*2)}}return w}computDrawPoints(t){return this.workOptions.strokeType===$.Stroke||t.length===1?this.computStroke(t):this.computNomal(t)}computNomal(t){let e=this.workOptions.thickness;const o=t.map(s=>(e=Math.max(e,s.radius),s.point));return{ps:o,rect:F(o,e)}}computStroke(t){return t.length===1?this.computDotStroke(t[0]):this.computLineStroke(t)}computLineStroke(t){const e=[],o=[];for(let a=0;a<t.length;a++){const{point:l,radius:c}=t[a];let p=l.v;a===0&&t.length>1&&(p=t[a+1].point.v);const h=k.Per(p).mul(c);e.push(b.Sub(l,h)),o.push(b.Add(l,h))}const s=t[t.length-1],i=b.GetSemicircleStroke(s.point,e[e.length-1],-1,8),r=b.GetSemicircleStroke(t[0].point,o[0],-1,8),n=e.concat(i,o.reverse(),r);return{ps:n,rect:F(n)}}computDotStroke(t){const{point:e,radius:o}=t,s={x:e.x-o,y:e.y-o,w:o*2,h:o*2};return{ps:b.GetDotStroke(e,o,8),rect:s}}transformData(t,e){const{op:o,workState:s}=t;let i=this.tmpPoints.length-1,r=[];if(o!=null&&o.length&&s){const{strokeType:n,thickness:a}=this.workOptions,l=new Set;i=n===$.Stroke?this.updateTempPointsWithPressure(o,a,l):this.updateTempPoints(o,a,l);const c=e?this.tmpPoints:this.tmpPoints.slice(i);return r=this.getTaskPoints(c,a),{tasks:r,effects:l,consumeIndex:i}}return{tasks:r,consumeIndex:i}}computRadius(t,e){return t*.03*e+e*.5}getMinZ(t,e){return((e||Math.max(1,Math.floor(t*.3)))-t*.5)*100/t/3}getTaskPoints(t,e){var o;const s=[];if(t.length===0)return[];let i=0,r=t[0].x,n=t[0].y,a=[r,n],l=[],c=t[0].t;for(;i<t.length;){const p=t[i],h=p.x-r,d=p.y-n,u=p.z,y=e?this.computRadius(u,e):u;if(l.push({point:new b(h,d,u,t[i].v),radius:y}),i>0&&i<t.length-1){const w=t[i].getAngleByPoints(t[i-1],t[i+1]);if(w<90||w>270){const T=(o=l.pop())==null?void 0:o.point.clone();T&&s.push({taskId:c,pos:a,points:[...l,{point:T,radius:y}]}),r=t[i].x,n=t[i].y,a=[r,n];const N=p.x-r,I=p.y-n;l=[{point:new b(N,I,u),radius:y}],c=Date.now()}}i++}return s.push({taskId:c,pos:a,points:l}),s}updateTempPointsWithPressure(t,e,o){const s=Date.now(),i=this.tmpPoints.length;let r=i;for(let a=0;a<t.length;a+=2){r=Math.min(r,i);const l=this.tmpPoints.length,c=new b(t[a],t[a+1]);if(l===0){this.tmpPoints.push(c);continue}const p=l-1,h=this.tmpPoints[p],d=k.Sub(c,h).uni();if(c.isNear(h,e)){if(h.z<this.MAX_REPEAR){if(h.setz(Math.min(h.z+1,this.MAX_REPEAR)),r=Math.min(r,p),l>1){let w=l-1;for(;w>0;){const T=this.tmpPoints[w].distance(this.tmpPoints[w-1]),N=Math.max(this.tmpPoints[w].z-this.uniThickness*T,0);if(this.tmpPoints[w-1].z>=N)break;this.tmpPoints[w-1].setz(N),r=Math.min(r,w-1),w--}}}else r=1/0;continue}c.setv(d);const u=c.distance(h),y=Math.max(h.z-this.uniThickness*u,0);l>1&&k.Equals(d,h.v,.02)&&(y>0||h.z<=0)&&(o&&h.t&&o.add(h.t),this.tmpPoints.pop(),r=Math.min(p,r)),c.setz(y),this.tmpPoints.push(c)}if(r===1/0)return this.tmpPoints.length;let n=i;if(r===i){n=Math.max(n-1,0);const a=this.tmpPoints[n].t;a&&(o==null||o.add(a))}else{let a=i-1;for(n=r;a>=0;){const l=this.tmpPoints[a].t;if(l&&(o==null||o.add(l),a<=r)){n=a,a=-1;break}a--}}return this.tmpPoints[n].setT(s),n}updateTempPoints(t,e,o){var s;const i=Date.now(),r=this.tmpPoints.length;let n=r;for(let l=0;l<t.length;l+=2){const c=this.tmpPoints.length,p=new b(t[l],t[l+1]);if(c===0){this.tmpPoints.push(p);continue}const h=c-1,d=this.tmpPoints[h],u=k.Sub(p,d).uni();if(p.isNear(d,e/2)){n=Math.min(h,n);continue}k.Equals(u,d.v,.02)&&(o&&d.t&&o.add(d.t),this.tmpPoints.pop(),n=Math.min(h,n)),p.setv(u),this.tmpPoints.push(p)}let a=r;if(n===r){a=Math.max(a-1,0);const l=this.tmpPoints[a].t;l&&(o==null||o.add(l))}else{let l=Math.min(r-1,n);for(a=n;l>=0;){const c=(s=this.tmpPoints[l])==null?void 0:s.t;if(c&&(o==null||o.add(c),l<=n)){a=l,l=-1;break}l--}}return this.tmpPoints[a].setT(i),a}updateTempPointsWithPressureWhenDone(t){const{thickness:e}=this.workOptions,o=t.length,s=this.getMinZ(e);for(let i=0;i<o;i+=2){const r=this.tmpPoints.length,n=new b(t[i],t[i+1]);if(r===0){this.tmpPoints.push(n);continue}const a=r-1,l=this.tmpPoints[a],c=k.Sub(n,l).uni(),p=n.distance(l);if(r>1&&l.z===s)break;if(n.isNear(l,e/2)){if(o<3&&l.z<this.MAX_REPEAR&&(l.setz(Math.min(l.z+1,this.MAX_REPEAR)),r>1)){let d=r-1;for(;d>0;){const u=this.tmpPoints[d].distance(this.tmpPoints[d-1]),y=Math.max(this.tmpPoints[d].z-this.uniThickness*u,-e/4);if(this.tmpPoints[d-1].z>=y)break;this.tmpPoints[d-1].setz(y),d--}}continue}n.setv(c);const h=Math.max(l.z-this.uniThickness*p,s);r>1&&k.Equals(c,l.v,.02)&&l.z<=0&&this.tmpPoints.pop(),n.setz(h),this.tmpPoints.push(n)}}static updateNodeOpt(t){var e;const{node:o,opt:s,vNodes:i}=t,{strokeColor:r}=s,n=i.get(o.name);return r&&(o.tagName==="GROUP"?Qt(o)?o.setAttribute("bgcolor",r):o.children.forEach(a=>{a.setAttribute("strokeColor",r),a.getAttribute("fillColor")&&a.setAttribute("fillColor",r)}):(o.setAttribute("strokeColor",r),o.setAttribute("fillColor",r)),(e=n==null?void 0:n.opt)!=null&&e.strokeColor&&(n.opt.strokeColor=r)),n&&i.setInfo(o.name,n),P.updateNodeOpt(t)}}class Lt extends P{constructor(t){super(t),m(this,"toolsType",v.LaserPen),m(this,"canRotate",!1),m(this,"scaleType",U.none),m(this,"syncTimestamp"),m(this,"syncIndex",0),m(this,"tmpPoints",[]),m(this,"workOptions"),m(this,"consumeIndex",0),this.workOptions=t.toolsOpt,this.syncTimestamp=0}combineConsume(){}setWorkOptions(t){super.setWorkOptions(t),this.syncTimestamp=Date.now()}consume(t){const{data:e,isSubWorker:o}=t,{workId:s,op:i}=e;if((i==null?void 0:i.length)===0)return{type:f.None};if(this.updateTempPoints(i||[]),this.consumeIndex>this.tmpPoints.length-4)return{type:f.None};const{strokeColor:r,thickness:n,strokeType:a}=this.workOptions,l=F(this.tmpPoints,n);let c=!1;const p=this.syncIndex,h=this.tmpPoints.slice(this.consumeIndex);this.consumeIndex=this.tmpPoints.length-1,this.syncTimestamp===0&&(this.syncTimestamp=Date.now());const d={name:s==null?void 0:s.toString(),opacity:1,lineDash:a===$.Dotted?[1,n*2]:a===$.LongDotted?[n,n*2]:void 0,strokeColor:r,lineCap:"round",lineWidth:n,anchor:[.5,.5]},u=this.getTaskPoints(h);if(u.length){const w=Date.now();w-this.syncTimestamp>this.syncUnitTime&&(c=!0,this.syncTimestamp=w,this.syncIndex=this.tmpPoints.length),o&&this.draw({attrs:d,tasks:u,isDot:!1,layer:this.drawLayer||this.fullLayer})}const y=[];return this.tmpPoints.slice(p).forEach(w=>{y.push(w.x,w.y)}),{rect:{x:l.x*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],y:l.y*this.fullLayer.worldScaling[1]+this.fullLayer.worldPosition[1],w:l.w*this.fullLayer.worldScaling[0],h:l.h*this.fullLayer.worldScaling[1]},type:f.DrawWork,dataType:C.Local,workId:c?s:void 0,op:c?y:void 0,index:c?p*2:void 0}}consumeAll(){var t;const e=(t=this.workId)==null?void 0:t.toString();let o;if(this.tmpPoints.length-1>this.consumeIndex){let r=this.tmpPoints.slice(this.consumeIndex);const n=r.length===1,{strokeColor:a,thickness:l,strokeType:c}=this.workOptions;if(n){const d=this.computDotStroke({point:r[0],radius:l/2});r=d.ps,o=d.rect}else o=F(this.tmpPoints,l);const p={name:e==null?void 0:e.toString(),fillColor:n?a:void 0,opacity:1,lineDash:c===$.Dotted&&!n?[1,l*2]:c===$.LongDotted&&!n?[l,l*2]:void 0,strokeColor:a,lineCap:n?void 0:"round",lineWidth:n?0:l,anchor:[.5,.5]},h=this.getTaskPoints(r);h.length&&this.draw({attrs:p,tasks:h,isDot:n,layer:this.drawLayer||this.fullLayer})}const s=[];this.tmpPoints.forEach(r=>{s.push(r.x,r.y)});const i=V(s);return{rect:o&&{x:o.x*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],y:o.y*this.fullLayer.worldScaling[1]+this.fullLayer.worldPosition[1],w:o.w*this.fullLayer.worldScaling[0],h:o.h*this.fullLayer.worldScaling[1]},type:f.FullWork,dataType:C.Local,workId:e,ops:i,index:this.syncIndex*2}}clearTmpPoints(){this.tmpPoints.length=0,this.syncTimestamp=0,this.syncIndex=0}consumeService(t){var e;const{op:o,replaceId:s,isFullWork:i}=t,{strokeColor:r,thickness:n,strokeType:a}=this.workOptions;if(!o.length){const y=F(this.tmpPoints,n);return{x:y.x*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],y:y.y*this.fullLayer.worldScaling[1]+this.fullLayer.worldPosition[1],w:y.w*this.fullLayer.worldScaling[0],h:y.h*this.fullLayer.worldScaling[1]}}const l=Math.max(0,this.tmpPoints.length-1);this.updateTempPoints(o||[]);let c,p=this.tmpPoints.slice(l);const h=p.length===1;if(h){const y=this.computDotStroke({point:p[0],radius:n/2});p=y.ps,c=y.rect}else c=F(this.tmpPoints,n);const d={name:(e=this.workId)==null?void 0:e.toString(),fillColor:h?r:void 0,opacity:1,lineDash:a===$.Dotted&&!h?[1,n*2]:a===$.LongDotted&&!h?[n,n*2]:void 0,strokeColor:r,lineCap:h?void 0:"round",lineWidth:h?0:n,anchor:[.5,.5]},u=this.getTaskPoints(p);if(u.length){const y=i?this.fullLayer:this.drawLayer||this.fullLayer;this.draw({attrs:d,tasks:u,isDot:h,replaceId:s,layer:y})}return{x:c.x*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],y:c.y*this.fullLayer.worldScaling[1]+this.fullLayer.worldPosition[1],w:c.w*this.fullLayer.worldScaling[0],h:c.h*this.fullLayer.worldScaling[1]}}computDotStroke(t){const{point:e,radius:o}=t,s={x:e.x-o,y:e.y-o,w:o*2,h:o*2};return{ps:b.GetDotStroke(e,o,8),rect:s}}updateTempPoints(t){const e=this.tmpPoints.length;for(let o=0;o<t.length;o+=2){if(e){const s=this.tmpPoints.slice(-1)[0];s&&s.x===t[o]&&s.y===t[o+1]&&this.tmpPoints.pop()}this.tmpPoints.push(new b(t[o],t[o+1]))}}async draw(t){const{attrs:e,tasks:o,isDot:s,layer:i}=t,{duration:r}=this.workOptions;for(const n of o){const a=new st,{pos:l,points:c}=n;let p;s?p=at(c,!0):p=at(c,!1),a.attr({...e,pos:l,d:p});const{vertex:h,fragment:d}=this.workOptions;if(h&&d){const u=i.renderer.createProgram({vertex:h,fragment:d}),{width:y,height:w}=i.getResolution();a.setUniforms({u_time:0,u_resolution:[y,w]}),a.setProgram(u)}i.appendChild(a),a.transition(r).attr({scale:s?[.1,.1]:[1,1],lineWidth:s?0:1}).then(()=>{a.remove()})}}getTaskPoints(t){var e;const o=[];if(t.length===0)return[];let s=0,i=t[0].x,r=t[0].y,n=[i,r],a=[];for(;s<t.length;){const l=t[s],c=l.x-i,p=l.y-r;if(a.push(new b(c,p)),s>0&&s<t.length-1){const h=t[s].getAngleByPoints(t[s-1],t[s+1]);if(h<90||h>270){const d=(e=a.pop())==null?void 0:e.clone();d&&o.push({pos:n,points:[...a,d]}),i=t[s].x,r=t[s].y,n=[i,r];const u=l.x-i,y=l.y-r;a=[new b(u,y)]}}s++}return o.push({pos:n,points:a}),o}removeLocal(){}removeService(t){let e;const o=[];return this.fullLayer.getElementsByName(t).forEach(s=>{if(s.name===t){const i=s.getBoundingClientRect();e=B(e,{x:i.x,y:i.y,w:i.width,h:i.height}),o.push(s)}}),o.length&&o.forEach(s=>s.remove()),e}}const xt=class dt extends P{constructor(t,e){super(t),m(this,"canRotate",!1),m(this,"scaleType",U.none),m(this,"toolsType",v.Eraser),m(this,"serviceWork"),m(this,"tmpPoints",[]),m(this,"workOptions"),m(this,"worldPosition"),m(this,"worldScaling"),m(this,"eraserRect"),m(this,"eraserPolyline"),this.serviceWork=e,this.workOptions=t.toolsOpt,this.worldPosition=this.fullLayer.worldPosition,this.worldScaling=this.fullLayer.worldScaling}combineConsume(){}consumeService(){}setWorkOptions(t){super.setWorkOptions(t)}createEraserRect(t){const e=t[0]*this.worldScaling[0]+this.worldPosition[0],o=t[1]*this.worldScaling[1]+this.worldPosition[1],{width:s,height:i}=dt.eraserSizes[this.workOptions.thickness];this.eraserRect={x:e-s*.5,y:o-i*.5,w:s,h:i},this.eraserPolyline=[this.eraserRect.x,this.eraserRect.y,this.eraserRect.x+this.eraserRect.w,this.eraserRect.y+this.eraserRect.h]}computRectCenterPoints(){const t=this.tmpPoints.slice(-2);if(this.tmpPoints.length===4){const e=new k(this.tmpPoints[0],this.tmpPoints[1]),o=new k(this.tmpPoints[2],this.tmpPoints[3]),s=k.Sub(o,e).uni(),i=k.Dist(e,o),{width:r,height:n}=dt.eraserSizes[this.workOptions.thickness],a=Math.min(r,n),l=Math.round(i/a);if(l>1){const c=[];for(let p=0;p<l;p++){const h=k.Mul(s,p*a);c.push(this.tmpPoints[0]+h.x,this.tmpPoints[1]+h.y)}return c.concat(t)}}return t}isNear(t,e){const o=new k(t[0],t[1]),s=new k(e[0],e[1]),{width:i,height:r}=dt.eraserSizes[this.workOptions.thickness];return k.Dist(o,s)<Math.hypot(i,r)*.5}cutPolyline(t,e){let o=[e],s=0;for(;s<t.length;){const n=t[s];if(n.length<2)break;o=i(o,n),s++}return o;function i(n,a){const l=n;for(let c=0;c<n.length;c++){const p=n[c],h=p.findIndex((d,u)=>u<p.length-1?r([d,p[u+1]],[a[0],a[1]]):!1);if(h!==-1&&h>-1){const d=[],u=p.slice(0,h+1);if(k.Equals(p[h],a[0])||u.push(a[0].clone().setz(p[h].z)),u.length>1&&d.push(u),h+a.length-1<p.length-1){const y=h+a.length-1,w=p.slice(y),T=a[a.length-1];k.Equals(p[y],T)||w.unshift(T.clone().setz(p[y].z)),w.length>1&&d.push(w)}return l.splice(c,1,...d),l}}return l}function r(n,a){const l=k.Sub(n[1],n[0]),c=k.Sub(a[1],a[0]),p=k.Sub(a[0],n[0]);return Math.abs(k.Cpr(l,c))<.1&&Math.abs(k.Cpr(l,p))<.1}}isSamePoint(t,e){return t[0]===e[0]&&t[1]===e[1]}translateIntersect(t){const e=[];for(let o=0;o<t.length;o++){const s=t[o].filter((n,a,l)=>!(a>0&&this.isSamePoint(n,l[a-1]))),i=[];let r=0;for(;r<s.length;){const n=s[r],a=new k(n[0],n[1]);i.push(a),r++}e.push(i)}return e}isLineEraser(t,e){return!(t===v.Pencil&&!e)}remove(t){const{curNodeMap:e,removeIds:o,newWorkDatas:s}=t,{isLine:i}=this.workOptions;let r;for(const[n,a]of e.entries())if(a.rect&&this.eraserRect&&this.eraserPolyline&&lt(this.eraserRect,a.rect)){const{op:l,toolsType:c}=a,p=this.isLineEraser(c,i),h=[],d=[];for(let y=0;y<l.length;y+=3){const w=new k(l[y]*this.worldScaling[0]+this.worldPosition[0],l[y+1]*this.worldScaling[1]+this.worldPosition[1],l[y+2]);d.push(w),h.push(new b(w.x,w.y))}const u=h.length&&F(h)||a.rect;if(lt(u,this.eraserRect)){if(d.length>1){const y=Yt.polyline(d.map(w=>w.XY),this.eraserPolyline);if(y.length&&(o.add(a.name),!p)){const w=this.translateIntersect(y),T=this.cutPolyline(w,d);for(let N=0;N<T.length;N++){const I=`${n}_s_${N}`,S=[];T[N].forEach(g=>{S.push((g.x-this.worldPosition[0])/this.worldScaling[0],(g.y-this.worldPosition[1])/this.worldScaling[1],g.z)}),a.opt&&a.toolsType&&this.vNodes&&(this.vNodes.setInfo(I,{rect:u,op:S,opt:a.opt,canRotate:a.canRotate,scaleType:a.scaleType,toolsType:a.toolsType}),s.set(I,{workId:I,op:S,opt:a.opt,toolsType:a.toolsType}))}}}else o.add(a.name);r=B(r,u)}}return o.forEach(n=>{var a;return(a=this.vNodes)==null?void 0:a.delete(n)}),r&&(r.x-=P.SafeBorderPadding,r.y-=P.SafeBorderPadding,r.w+=P.SafeBorderPadding*2,r.h+=P.SafeBorderPadding*2),r}consume(t){const{op:e}=t.data;if(!e||e.length===0)return{type:f.None};const o=this.tmpPoints.length;if(o>1&&this.isNear([e[0],e[1]],[this.tmpPoints[o-2],this.tmpPoints[o-1]]))return{type:f.None};o===4&&(this.tmpPoints.shift(),this.tmpPoints.shift()),this.tmpPoints.push(e[0],e[1]);const s=this.computRectCenterPoints();let i;const r=new Set,n=new Map;if(!this.vNodes)return{type:f.None};this.vNodes.setTarget();const a=this.getUnLockNodeMap(this.vNodes.getLastTarget());for(let l=0;l<s.length-1;l+=2){this.createEraserRect(s.slice(l,l+2));const c=this.remove({curNodeMap:a,removeIds:r,newWorkDatas:n});i=B(i,c)}if(this.vNodes.deleteLastTarget(),i&&r.size){for(const l of n.keys())r.has(l)&&n.delete(l);return{type:f.RemoveNode,dataType:C.Local,rect:i,removeIds:[...r],newWorkDatas:n}}return{type:f.None}}consumeAll(t){return this.consume(t)}clearTmpPoints(){this.tmpPoints.length=0}getUnLockNodeMap(t){var e;if(this.serviceWork){const o=Z(t),s=this.serviceWork.selectorWorkShapes,i=this.serviceWork.workShapes;for(const r of s.values())if((e=r.selectIds)!=null&&e.length)for(const n of r.selectIds)o.delete(n);for(const r of i.keys())o.delete(r);return o}return t}};m(xt,"eraserSizes",Object.freeze([Object.freeze({width:18,height:26}),Object.freeze({width:26,height:34}),Object.freeze({width:34,height:50})]));let Rt=xt;const mt=class et extends P{constructor(t){super(t),m(this,"toolsType",v.Selector),m(this,"tmpPoints",[]),m(this,"workOptions"),m(this,"vNodes"),m(this,"selectIds"),m(this,"selectorColor"),m(this,"strokeColor"),m(this,"fillColor"),m(this,"oldSelectRect"),m(this,"canRotate",!1),m(this,"canTextEdit",!1),m(this,"canLock",!1),m(this,"scaleType",U.all),m(this,"toolsTypes"),m(this,"shapeOpt"),m(this,"textOpt"),m(this,"isLocked"),this.workOptions=t.toolsOpt,this.vNodes=t.vNodes}computSelector(t=!0){const e=F(this.tmpPoints);if(e.w===0||e.h===0)return{selectIds:[],intersectRect:void 0,subNodeMap:new Map};const{rectRange:o,nodeRange:s}=this.vNodes.getRectIntersectRange(e,t);return{selectIds:[...s.keys()],intersectRect:o,subNodeMap:s}}updateTempPoints(t){const e=this.tmpPoints.length,o=t.length;if(o>1){const s=new b(t[o-2]*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],t[o-1]*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[1]);e===2?this.tmpPoints.splice(1,1,s):this.tmpPoints.push(s)}}drawSelector(t){const{drawRect:e,subNodeMap:o,selectorId:s,layer:i,isService:r}=t,n=new G({pos:[e.x,e.y],anchor:[0,0],size:[e.w,e.h],id:s,name:s,zIndex:1e3}),a=[];if(r){const l=new yt({normalize:!0,pos:[e.w/2,e.h/2],lineWidth:1,strokeColor:this.selectorColor||this.workOptions.strokeColor,width:e.w,height:e.h,name:et.selectorBorderId});a.push(l)}o.forEach((l,c)=>{const p=[l.rect.x+l.rect.w/2-e.x,l.rect.y+l.rect.h/2-e.y],h=new yt({normalize:!0,pos:p,lineWidth:1,strokeColor:o.size>1?this.selectorColor||this.workOptions.strokeColor:void 0,width:l.rect.w,height:l.rect.h,id:`selector-${c}`,name:`selector-${c}`});a.push(h)}),a&&n.append(...a),(i==null?void 0:i.parent).appendChild(n)}draw(t,e,o,s=!1){var i,r;const{intersectRect:n,subNodeMap:a}=o;(r=(i=e.parent)==null?void 0:i.getElementById(t))==null||r.remove(),n&&this.drawSelector({drawRect:n,subNodeMap:a,selectorId:t,layer:e,isService:s})}getSelecteorInfo(t){this.scaleType=U.all,this.canRotate=!1,this.textOpt=void 0,this.strokeColor=void 0,this.fillColor=void 0,this.canTextEdit=!1,this.canLock=!1,this.isLocked=!1,this.toolsTypes=void 0,this.shapeOpt=void 0;const e=new Set;let o;for(const s of t.values()){const{opt:i,canRotate:r,scaleType:n,toolsType:a}=s;this.selectorColor=this.workOptions.strokeColor,i.strokeColor&&(this.strokeColor=i.strokeColor),i.fillColor&&(this.fillColor=i.fillColor),i.textOpt&&(this.textOpt=i.textOpt),a===v.SpeechBalloon&&(e.add(a),this.shapeOpt||(this.shapeOpt={}),this.shapeOpt.placement=i.placement),a===v.Polygon&&(e.add(a),this.shapeOpt||(this.shapeOpt={}),this.shapeOpt.vertices=i.vertices),a===v.Star&&(e.add(a),this.shapeOpt||(this.shapeOpt={}),this.shapeOpt.vertices=i.vertices,this.shapeOpt.innerRatio=i.innerRatio,this.shapeOpt.innerVerticeStep=i.innerVerticeStep),a===v.Text&&(this.textOpt=i),t.size===1&&(this.textOpt&&(this.canTextEdit=!0),this.canRotate=r,this.scaleType=n),n===U.none&&(this.scaleType=n),a===v.Image&&(o=s)}e.size&&(this.toolsTypes=[...e]),o&&(t.size===1?(this.canLock=!0,o.opt.locked&&(this.isLocked=!0,this.scaleType=U.none,this.canRotate=!1,this.textOpt=void 0,this.fillColor=void 0,this.selectorColor="rgb(177,177,177)",this.strokeColor=void 0,this.canTextEdit=!1)):t.size>1&&!o.opt.locked&&(this.canLock=!1,this.canRotate=!1))}getChildrenPoints(){var t,e;if(this.scaleType===U.both&&((t=this.selectIds)==null?void 0:t.length)===1){const o=this.selectIds[0],s=(e=this.vNodes.get(o))==null?void 0:e.op;if(s){const i=[];for(let r=0;r<s.length;r+=3)i.push([s[r],s[r+1]]);return i}}}consume(t){const{op:e,workState:o}=t.data;let s=this.oldSelectRect;if(o===D.Start&&(s=this.unSelectedAllIds()),!(e!=null&&e.length)||!this.vNodes.curNodeMap.size)return{type:f.None};this.updateTempPoints(e);const i=this.computSelector();if(this.selectIds&&nt(this.selectIds,i.selectIds))return{type:f.None};this.selectIds=i.selectIds;const r=i.intersectRect;this.getSelecteorInfo(i.subNodeMap),this.draw(et.selectorId,this.fullLayer,i),this.oldSelectRect=r;const n=this.getChildrenPoints();return{type:f.Select,dataType:C.Local,rect:B(r,s),selectIds:i.selectIds,opt:this.workOptions,selectRect:r,selectorColor:this.selectorColor,strokeColor:this.strokeColor,fillColor:this.fillColor,textOpt:this.textOpt,canTextEdit:this.canTextEdit,canRotate:this.canRotate,canLock:this.canLock,scaleType:this.scaleType,willSyncService:!0,points:n,isLocked:this.isLocked,toolsTypes:this.toolsTypes,shapeOpt:this.shapeOpt}}consumeAll(){var t,e;let o=this.oldSelectRect;if(!((t=this.selectIds)!=null&&t.length)&&this.tmpPoints[0]&&this.selectSingleTool(this.tmpPoints[0].XY,et.selectorId,!1),(e=this.selectIds)!=null&&e.length&&(o=this.selectedByIds(this.selectIds)),o){const s=this.getChildrenPoints();return{type:f.Select,dataType:C.Local,rect:this.oldSelectRect,selectIds:this.selectIds,opt:this.workOptions,selectorColor:this.selectorColor,selectRect:this.oldSelectRect,strokeColor:this.strokeColor,fillColor:this.fillColor,textOpt:this.textOpt,canTextEdit:this.canTextEdit,canRotate:this.canRotate,canLock:this.canLock,scaleType:this.scaleType,willSyncService:!0,points:s,isLocked:this.isLocked,toolsTypes:this.toolsTypes,shapeOpt:this.shapeOpt}}return{type:f.None}}consumeService(){}clearTmpPoints(){this.tmpPoints.length=0}clearSelectData(){this.selectIds=void 0,this.oldSelectRect=void 0}selectSingleTool(t,e=et.selectorId,o=!1){if(t.length===2){const s=t[0],i=t[1];let r;const{nodeRange:n}=this.vNodes.getRectIntersectRange({x:s,y:i,w:0,h:0},!1),a=[...n.values()].sort((l,c)=>(l.opt.zIndex||0)-(c.opt.zIndex||0));for(const l of a){const c=this.fullLayer.getElementsByName(l.name);if(Ft(c).find(p=>p.isPointCollision(s,i))){r=l;break}}if(r){const l=r.name;if(!nt(this.oldSelectRect,r.rect)){const c=new Map([[l,r]]);this.getSelecteorInfo(c),this.draw(e,this.fullLayer,{intersectRect:r.rect,subNodeMap:c,selectIds:this.selectIds||[]},o)}this.selectIds=[l],this.oldSelectRect=r.rect}}}unSelectedAllIds(){let t;for(const[e,o]of this.vNodes.curNodeMap.entries())o.isSelected&&(t=B(t,o.rect),this.vNodes.unSelected(e));return t}unSelectedByIds(t){let e;for(const o of t){const s=this.vNodes.get(o);s&&s.isSelected&&(e=B(e,s.rect),this.vNodes.unSelected(o))}return e}selectedByIds(t){let e;for(const o of t){const s=this.vNodes.get(o);s&&(e=B(e,s.rect),this.vNodes.selected(o))}return e}getSelectorRect(t,e){var o;let s;const i=(o=t.parent)==null?void 0:o.getElementById(e),r=i==null?void 0:i.getBoundingClientRect();return r&&(s=B(s,{x:Math.floor(r.x),y:Math.floor(r.y),w:Math.floor(r.width+1),h:Math.floor(r.height+1)})),s}isCanFillColor(t){return t===v.Ellipse||t===v.Triangle||t===v.Rectangle||t===v.Polygon||t===v.Star||t===v.SpeechBalloon}async updateSelector(t){const{updateSelectorOpt:e,selectIds:o,vNodes:s,willSerializeData:i,worker:r,offset:n,scene:a,isMainThread:l}=t,c=this.fullLayer;if(!c)return;let p;const h=new Map,{box:d,workState:u,angle:y,translate:w}=e;let T=[0,0],N=[1,1],I=[0,0],S,g;if(d||w||q(y)){if(u===D.Start)return s.setTarget(),{type:f.Select,dataType:C.Local,selectRect:this.oldSelectRect,rect:this.oldSelectRect};if(S=s.getLastTarget(),S&&d){let W;o==null||o.forEach(L=>{const O=S==null?void 0:S.get(L);W=B(W,O==null?void 0:O.rect)}),W&&(N=[d.w/W.w,d.h/W.h],T=[d.x+d.w/2-(W.x+W.w/2),d.y+d.h/2-(W.y+W.h/2)],I=[W.x+W.w/2,W.y+W.h/2]),g=W}}if(o)for(const W of o){const L=s.get(W);if(L){const{toolsType:O}=L;let z=(c==null?void 0:c.getElementsByName(W))[0];if(z){const A={...e};let Y;if(O){if(S&&(Y=S.get(W),Y&&d)){A.boxScale=N;const J=[Y.rect.x+Y.rect.w/2,Y.rect.y+Y.rect.h/2],tt=[J[0]-I[0],J[1]-I[1]];A.boxTranslate=[tt[0]*(N[0]-1)+T[0]+(n&&n[0]||0),tt[1]*(N[1]-1)+T[1]+(n&&n[1]||0)]}const kt=zt(O);if(kt==null||kt.updateNodeOpt({node:z,opt:A,vNodes:s,willSerializeData:i,targetNode:Y}),L&&r&&(i&&(A.angle||A.translate)||A.box&&A.workState!==D.Start||A.pointMap&&A.pointMap.has(W)||O===v.Text&&(A.fontSize||A.translate||A.textInfos&&A.textInfos.get(W))||O===v.Image&&(A.angle||A.translate||A.boxScale)||O===A.toolsType&&A.willRefresh)){const J=r.createWorkShapeNode({toolsType:O,toolsOpt:L.opt});J==null||J.setWorkId(W);let tt;O===v.Image&&a?tt=await J.consumeServiceAsync({isFullWork:!0,replaceId:W,scene:a,isMainThread:l}):tt=J==null?void 0:J.consumeService({op:L.op,isFullWork:!0,replaceId:W}),tt&&(L.rect=tt),z=(c==null?void 0:c.getElementsByName(W))[0]}L&&(h.set(W,L),p=B(p,L.rect))}}}}S&&u===D.Done&&s.deleteLastTarget();const x=p;if(g&&e.dir&&x){let W=[0,0];switch(e.dir){case"topLeft":case"left":{const L=[g.x+g.w,g.y+g.h];W=[L[0]-(x.x+x.w),L[1]-(x.y+x.h)];break}case"bottomLeft":case"bottom":{const L=[g.x+g.w,g.y];W=[L[0]-(x.x+x.w),L[1]-x.y];break}case"topRight":case"top":{const L=[g.x,g.y+g.h];W=[L[0]-x.x,L[1]-(x.y+x.h)];break}case"right":case"bottomRight":{const L=[g.x,g.y];W=[L[0]-x.x,L[1]-x.y];break}}if(W[0]||W[1])return x.x=x.x+W[0],x.y=x.y+W[1],await this.updateSelector({...t,offset:W})}this.getSelecteorInfo(h),this.draw(et.selectorId,c,{selectIds:o||[],subNodeMap:h,intersectRect:x});const M=B(this.oldSelectRect,x);return this.oldSelectRect=x,{type:f.Select,dataType:C.Local,selectRect:x,renderRect:p,rect:B(M,x)}}blurSelector(){const t=this.unSelectedAllIds();return{type:f.Select,dataType:C.Local,rect:t,selectIds:[],willSyncService:!0}}getRightServiceId(t){return t.replace(wt,"-")}selectServiceNode(t,e,o){const{selectIds:s}=e,i=this.getRightServiceId(t),r=this.getSelectorRect(this.fullLayer,i);let n;const a=new Map;return s==null||s.forEach(l=>{const c=this.vNodes.get(l);c&&(n=B(n,c.rect),a.set(l,c))}),this.getSelecteorInfo(a),this.draw(i,this.fullLayer,{intersectRect:n,selectIds:s||[],subNodeMap:a},o),B(n,r)}reRenderSelector(){var t;let e;const o=new Map;return(t=this.selectIds)==null||t.forEach(s=>{const i=this.vNodes.get(s);i&&(e=B(e,i.rect),o.set(s,i))},this),this.getSelecteorInfo(o),this.draw(et.selectorId,this.fullLayer,{intersectRect:e,subNodeMap:o,selectIds:this.selectIds||[]}),this.oldSelectRect=e,e}updateSelectIds(t){var e;let o;const s=(e=this.selectIds)==null?void 0:e.filter(r=>!t.includes(r));if(s!=null&&s.length&&(o=this.unSelectedByIds(s)),t.length){const r=this.selectedByIds(t);o=B(o,r)}this.selectIds=t;const i=this.reRenderSelector();return{bgRect:o,selectRect:i}}cursorHover(t){var e,o;const s=this.oldSelectRect;this.selectIds=[];const i=(e=this.workId)==null?void 0:e.toString(),r=[t[0]*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[0],t[1]*this.fullLayer.worldScaling[0]+this.fullLayer.worldPosition[1]];if(this.selectSingleTool(r,i,!0),this.oldSelectRect&&!nt(s,this.oldSelectRect))return{type:f.CursorHover,dataType:C.Local,rect:B(s,this.oldSelectRect),selectorColor:this.selectorColor,willSyncService:!1};if((o=this.selectIds)!=null&&o.length||(this.oldSelectRect=void 0),s&&!this.oldSelectRect)return this.cursorBlur(),{type:f.CursorHover,dataType:C.Local,rect:s,selectorColor:this.selectorColor,willSyncService:!1}}cursorBlur(){var t,e;this.selectIds=[];const o=(t=this.workId)==null?void 0:t.toString();((e=this.fullLayer)==null?void 0:e.parent).children.forEach(s=>{s.name===o&&s.remove()})}};m(mt,"selectorId",X),m(mt,"selectorBorderId","selector-border");let H=mt;class Ct extends P{constructor(t){super(t),m(this,"canRotate",!1),m(this,"scaleType",U.both),m(this,"toolsType",v.Arrow),m(this,"tmpPoints",[]),m(this,"workOptions"),m(this,"oldRect"),m(this,"arrowTipWidth"),m(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.arrowTipWidth=this.workOptions.thickness*4,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:i,isMainThread:r}=t,n=(e=o==null?void 0:o.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a,workState:l}=o,c=a==null?void 0:a.length;if(!c||c<2)return{type:f.None};let p;if(l===D.Start?(this.tmpPoints=[new b(a[0],a[1])],p=!1):p=this.updateTempPoints(a),!p)return{type:f.None};let h;if(i||r){const u=s?this.fullLayer:this.drawLayer||this.fullLayer;h=this.draw({workId:n,layer:u})}if(!i){const u=Date.now();return u-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=u,{type:f.DrawWork,dataType:C.Local,workId:n,op:this.tmpPoints.map(y=>[...y.XY,0]).flat(1),isSync:!0,index:0}):{type:f.None}}const d=B(h,this.oldRect);return this.oldRect=h,{rect:d,type:f.DrawWork,dataType:C.Local,workId:n}}consumeAll(t){var e,o;const{data:s}=t,i=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!i)return{type:f.None};if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[i]};const r=this.fullLayer,n=this.draw({workId:i,layer:r});this.oldRect=n;const a=this.tmpPoints.map(c=>[...c.XY,0]).flat(1),l=V(a);return(o=this.vNodes)==null||o.setInfo(i,{rect:n,op:a,opt:this.workOptions,toolsType:this.toolsType,canRotate:this.canRotate,scaleType:this.scaleType,centerPos:P.getCenterPos(n,r)}),{rect:n,type:f.FullWork,dataType:C.Local,workId:i,ops:l,isSync:!0,opt:this.workOptions}}draw(t){var e;const{workId:o,layer:s}=t;this.fullLayer.getElementsByName(o).map(T=>T.remove()),(e=this.drawLayer)==null||e.getElementsByName(o).map(T=>T.remove());const{strokeColor:i,thickness:r,zIndex:n,scale:a,rotate:l,translate:c}=this.workOptions,p=s.worldPosition,h=s.worldScaling,{points:d,rect:u}=this.computDrawPoints(r),y={pos:[u.x+u.w/2,u.y+u.h/2],name:o,id:o,close:!0,points:d,fillColor:i,strokeColor:i,lineWidth:0,normalize:!0,zIndex:n};a&&(y.scale=a),l&&(y.rotate=l),c&&(y.translate=c);const w=new ot(y);if(s.append(w),a||l||c){const T=w.getBoundingClientRect();return{x:Math.floor(T.x-P.SafeBorderPadding),y:Math.floor(T.y-P.SafeBorderPadding),w:Math.floor(T.width+P.SafeBorderPadding*2),h:Math.floor(T.height+P.SafeBorderPadding*2)}}return{x:Math.floor(u.x*h[0]+p[0]-P.SafeBorderPadding),y:Math.floor(u.y*h[1]+p[1]-P.SafeBorderPadding),w:Math.floor(u.w*h[0]+2*P.SafeBorderPadding),h:Math.floor(u.h*h[1]+2*P.SafeBorderPadding)}}computDrawPoints(t){return this.tmpPoints[1].distance(this.tmpPoints[0])>this.arrowTipWidth?this.computFullArrowPoints(t):this.computTrianglePoints()}computFullArrowPoints(t){const e=k.Sub(this.tmpPoints[1],this.tmpPoints[0]).uni(),o=k.Per(e).mul(t/2),s=b.Sub(this.tmpPoints[0],o),i=b.Add(this.tmpPoints[0],o),r=k.Mul(e,this.arrowTipWidth),n=k.Sub(this.tmpPoints[1],r),a=b.Sub(n,o),l=b.Add(n,o),c=k.Per(e).mul(t*1.5),p=b.Sub(n,c),h=b.Add(n,c),d=[s,a,p,this.tmpPoints[1],h,l,i];return{points:d.map(u=>b.Sub(u,this.tmpPoints[0]).XY).flat(1),rect:F(d),isTriangle:!1,pos:this.tmpPoints[0].XY}}computTrianglePoints(){const t=k.Sub(this.tmpPoints[1],this.tmpPoints[0]).uni(),e=this.tmpPoints[1].distance(this.tmpPoints[0]),o=k.Per(t).mul(Math.floor(e*3/8)),s=b.Sub(this.tmpPoints[0],o),i=b.Add(this.tmpPoints[0],o),r=[s,this.tmpPoints[1],i];return{points:r.map(n=>b.Sub(n,this.tmpPoints[0]).XY).flat(1),rect:F(r),isTriangle:!0,pos:this.tmpPoints[0].XY}}updateTempPoints(t){const e=t.slice(-2),o=new b(e[0],e[1]),s=this.tmpPoints[0],{thickness:i}=this.workOptions;if(s.isNear(o,i))return!1;if(this.tmpPoints.length===2){if(o.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=o}else this.tmpPoints.push(o);return!0}consumeService(t){var e,o;const{op:s,isFullWork:i}=t,r=(e=this.workId)==null?void 0:e.toString();if(!r)return;this.tmpPoints.length=0;for(let l=0;l<s.length;l+=3)this.tmpPoints.push(new b(s[l],s[l+1],s[l+2]));const n=i?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:r,layer:n});return this.oldRect=a,(o=this.vNodes)==null||o.setInfo(r,{rect:a,op:s,opt:this.workOptions,toolsType:this.toolsType,canRotate:this.canRotate,scaleType:this.scaleType,centerPos:P.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){var e;const{node:o,opt:s,vNodes:i}=t,{strokeColor:r}=s,n=i.get(o.name);return r&&(o.setAttribute("strokeColor",r),o.setAttribute("fillColor",r),(e=n==null?void 0:n.opt)!=null&&e.strokeColor&&(n.opt.strokeColor=r),n&&i.setInfo(o.name,n)),P.updateNodeOpt(t)}}class bt extends P{constructor(t){super(t),m(this,"canRotate",!1),m(this,"scaleType",U.all),m(this,"toolsType",v.Ellipse),m(this,"tmpPoints",[]),m(this,"workOptions"),m(this,"oldRect"),m(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:i,isMainThread:r}=t,n=(e=o==null?void 0:o.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a,workState:l}=o,c=a==null?void 0:a.length;if(!c||c<2)return{type:f.None};let p;if(l===D.Start?(this.tmpPoints=[new b(a[0],a[1])],p=!1):p=this.updateTempPoints(a),!p)return{type:f.None};let h;if(i||r){const u=s?this.fullLayer:this.drawLayer||this.fullLayer;h=this.draw({workId:n,layer:u,isDrawing:!0})}if(!i){const u=Date.now();return u-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=u,{type:f.DrawWork,dataType:C.Local,workId:n,op:this.tmpPoints.map(y=>[...y.XY,0]).flat(1),isSync:!0,index:0}):{type:f.None}}const d=B(h,this.oldRect);return this.oldRect=h,{rect:d,type:f.DrawWork,dataType:C.Local,workId:n}}consumeAll(t){var e,o;const{data:s}=t,i=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!i)return{type:f.None};if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[i]};const r=this.fullLayer,n=this.draw({workId:i,layer:r,isDrawing:!1});this.oldRect=n;const a=this.tmpPoints.map(c=>[...c.XY,0]).flat(1),l=V(a);return(o=this.vNodes)==null||o.setInfo(i,{rect:n,op:a,opt:this.workOptions,toolsType:this.toolsType,canRotate:this.canRotate,scaleType:this.scaleType,centerPos:n&&P.getCenterPos(n,r)}),{rect:n,type:f.FullWork,dataType:C.Local,workId:i,ops:l,isSync:!0,opt:this.workOptions}}draw(t){var e;const{workId:o,layer:s,isDrawing:i}=t;this.fullLayer.getElementsByName(o).map(g=>g.remove()),(e=this.drawLayer)==null||e.getElementsByName(o).map(g=>g.remove());const{strokeColor:r,fillColor:n,thickness:a,zIndex:l,scale:c,rotate:p,translate:h}=this.workOptions,d=s.worldPosition,u=s.worldScaling,{radius:y,rect:w,pos:T}=this.computDrawPoints(a),N={pos:T,name:o,id:o,radius:y,lineWidth:a,fillColor:n!=="transparent"&&n||void 0,strokeColor:r,normalize:!0,zIndex:l},I={x:Math.floor(w.x*u[0]+d[0]-P.SafeBorderPadding),y:Math.floor(w.y*u[1]+d[1]-P.SafeBorderPadding),w:Math.floor(w.w*u[0]+2*P.SafeBorderPadding),h:Math.floor(w.h*u[1]+2*P.SafeBorderPadding)};if(i){const{name:g,id:x,zIndex:M,strokeColor:W}=N,L=P.getCenterPos(I,s),O=new G({name:g,id:x,zIndex:M,pos:L,anchor:[.5,.5],size:[I.w,I.h]}),z=new gt({...N,pos:[0,0]}),A=new st({d:"M-4,0H4M0,-4V4",normalize:!0,pos:[0,0],strokeColor:W,lineWidth:1,scale:[1/u[0],1/u[1]]});return O.append(z,A),s.append(O),I}c&&(N.scale=c),p&&(N.rotate=p),h&&(N.translate=h);const S=new gt(N);if(s.append(S),p||c||h){const g=S.getBoundingClientRect();return{x:Math.floor(g.x-P.SafeBorderPadding),y:Math.floor(g.y-P.SafeBorderPadding),w:Math.floor(g.width+P.SafeBorderPadding*2),h:Math.floor(g.height+P.SafeBorderPadding*2)}}return I}computDrawPoints(t){const e=F(this.tmpPoints),o=F(this.tmpPoints,t),s=[Math.floor(e.x+e.w/2),Math.floor(e.y+e.h/2)];return{rect:o,pos:s,radius:[Math.floor(e.w/2),Math.floor(e.h/2)]}}updateTempPoints(t){const e=t.slice(-2),o=new b(e[0],e[1]),s=this.tmpPoints[0],{thickness:i}=this.workOptions;if(s.isNear(o,i))return!1;if(this.tmpPoints.length===2){if(o.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=o}else this.tmpPoints.push(o);return!0}consumeService(t){var e,o;const{op:s,isFullWork:i}=t,r=(e=this.workId)==null?void 0:e.toString();if(!r)return;this.tmpPoints.length=0;for(let l=0;l<s.length;l+=3)this.tmpPoints.push(new b(s[l],s[l+1],s[l+2]));const n=i?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:r,layer:n,isDrawing:!1});return this.oldRect=a,(o=this.vNodes)==null||o.setInfo(r,{rect:a,op:s,opt:this.workOptions,toolsType:this.toolsType,canRotate:this.canRotate,scaleType:this.scaleType,centerPos:P.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){var e,o;const{node:s,opt:i,vNodes:r}=t,{strokeColor:n,fillColor:a}=i,l=r.get(s.name);let c=s;return s.tagName==="GROUP"&&(c=s.children[0]),n&&(c.setAttribute("strokeColor",n),(e=l==null?void 0:l.opt)!=null&&e.strokeColor&&(l.opt.strokeColor=n)),a&&(a==="transparent"?c.setAttribute("fillColor","rgba(0,0,0,0)"):c.setAttribute("fillColor",a),(o=l==null?void 0:l.opt)!=null&&o.fillColor&&(l.opt.fillColor=a)),l&&r.setInfo(s.name,l),P.updateNodeOpt(t)}}class Ot extends P{constructor(t){super(t),m(this,"canRotate",!0),m(this,"scaleType",U.all),m(this,"toolsType",v.Rectangle),m(this,"tmpPoints",[]),m(this,"workOptions"),m(this,"oldRect"),m(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}transformData(){const t=F(this.tmpPoints);return[[t.x,t.y,0],[t.x+t.w,t.y,0],[t.x+t.w,t.y+t.h,0],[t.x,t.y+t.h,0]]}computDrawPoints(t){const{thickness:e}=this.workOptions,o=[];for(const r of t)o.push(new k(...r));const s=F(o,e),i=[s.x+s.w/2,s.y+s.h/2];return{rect:s,pos:i,points:o.map(r=>r.XY).flat(1)}}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:i,isMainThread:r}=t,n=(e=o==null?void 0:o.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a,workState:l}=o,c=a==null?void 0:a.length;if(!c||c<2)return{type:f.None};let p;if(l===D.Start?(this.tmpPoints=[new b(a[0],a[1])],p=!1):p=this.updateTempPoints(a),!p)return{type:f.None};const h=this.transformData();let d;if(i||r){const y=s?this.fullLayer:this.drawLayer||this.fullLayer;d=this.draw({ps:h,workId:n,layer:y,isDrawing:!0})}if(!i){const y=Date.now();return y-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=y,{type:f.DrawWork,dataType:C.Local,workId:n,op:h.flat(1),isSync:!0,index:0}):{type:f.None}}const u=B(d,this.oldRect);return this.oldRect=d,{rect:u,type:f.DrawWork,dataType:C.Local,workId:n}}consumeAll(t){var e,o;const{data:s}=t,i=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!i)return{type:f.None};if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[i]};const r=this.transformData(),n=this.fullLayer,a=this.draw({ps:r,workId:i,layer:n,isDrawing:!1});this.oldRect=a;const l=r.flat(1),c=V(l);return(o=this.vNodes)==null||o.setInfo(i,{rect:a,op:l,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&P.getCenterPos(a,n)}),{rect:a,type:f.FullWork,dataType:C.Local,workId:i,ops:c,opt:this.workOptions,isSync:!0}}draw(t){var e;const{workId:o,layer:s,isDrawing:i,ps:r,replaceId:n}=t;this.fullLayer.getElementsByName(n||o).map(L=>L.remove()),(e=this.drawLayer)==null||e.getElementsByName(n||o).map(L=>L.remove());const{strokeColor:a,fillColor:l,thickness:c,zIndex:p,scale:h,rotate:d,translate:u,textOpt:y}=this.workOptions,w=s.worldPosition,T=s.worldScaling,{points:N,rect:I,pos:S}=this.computDrawPoints(r),g={close:!0,normalize:!0,points:N,lineWidth:c,fillColor:l!=="transparent"&&l||void 0,strokeColor:a,lineJoin:"round"},x={x:Math.floor(I.x*T[0]+w[0]-P.SafeBorderPadding),y:Math.floor(I.y*T[1]+w[1]-P.SafeBorderPadding),w:Math.floor(I.w*T[0]+2*P.SafeBorderPadding),h:Math.floor(I.h*T[0]+2*P.SafeBorderPadding)},M=new G({name:o,id:o,zIndex:p,pos:S,anchor:[.5,.5],size:[I.w,I.h],scale:h,rotate:d,translate:u}),W=new ot({...g,pos:[0,0]});if(M.appendChild(W),i){const L=new st({d:"M-4,0H4M0,-4V4",normalize:!0,pos:[0,0],strokeColor:a,lineWidth:1,scale:[1/T[0],1/T[1]]});M.appendChild(L)}if(s.append(M),h||d||u){const L=M.getBoundingClientRect();return{x:Math.floor(L.x-P.SafeBorderPadding),y:Math.floor(L.y-P.SafeBorderPadding),w:Math.floor(L.width+2*P.SafeBorderPadding),h:Math.floor(L.height+2*P.SafeBorderPadding)}}return x}updateTempPoints(t){const e=t.slice(-2),o=new b(e[0],e[1]),s=this.tmpPoints[0],{thickness:i}=this.workOptions;if(s.isNear(o,i))return!1;if(this.tmpPoints.length===2){if(o.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=o}else this.tmpPoints.push(o);return!0}consumeService(t){var e,o;const{op:s,isFullWork:i,replaceId:r}=t,n=(e=this.workId)==null?void 0:e.toString();if(!n)return;const a=[];for(let p=0;p<s.length;p+=3)a.push([s[p],s[p+1],s[p+2]]);const l=i?this.fullLayer:this.drawLayer||this.fullLayer,c=this.draw({ps:a,workId:n,layer:l,isDrawing:!1,replaceId:r});return this.oldRect=c,(o=this.vNodes)==null||o.setInfo(n,{rect:c,op:s,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:c&&P.getCenterPos(c,l)}),c}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){var e,o;const{node:s,opt:i,vNodes:r}=t,{strokeColor:n,fillColor:a,fontColor:l,fontBgColor:c,bold:p,italic:h,lineThrough:d,underline:u,fontSize:y}=i,w=r.get(s.name);let T=s;if(s.tagName==="GROUP"&&(T=s.children[0]),n&&(T.setAttribute("strokeColor",n),(e=w==null?void 0:w.opt)!=null&&e.strokeColor&&(w.opt.strokeColor=n)),a&&(a==="transparent"?T.setAttribute("fillColor","rgba(0,0,0,0)"):T.setAttribute("fillColor",a),(o=w==null?void 0:w.opt)!=null&&o.fillColor&&(w.opt.fillColor=a)),w!=null&&w.opt.textOpt){const N=w.opt.textOpt;l&&N.fontColor&&(N.fontColor=l),c&&N.fontBgColor&&(N.fontBgColor=c),p&&(N.bold=p),h&&(N.italic=h),_(d)&&(N.lineThrough=d),_(u)&&(N.underline=u),y&&(N.fontSize=y)}return w&&r.setInfo(s.name,w),P.updateNodeOpt(t)}}class Mt extends P{constructor(t){super(t),m(this,"canRotate",!1),m(this,"scaleType",U.all),m(this,"toolsType",v.Star),m(this,"tmpPoints",[]),m(this,"workOptions"),m(this,"oldRect"),m(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:i,isMainThread:r}=t,n=(e=o==null?void 0:o.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a,workState:l}=o,c=a==null?void 0:a.length;if(!c||c<2)return{type:f.None};let p;if(l===D.Start?(this.tmpPoints=[new b(a[0],a[1])],p=!1):p=this.updateTempPoints(a),!p)return{type:f.None};let h;if(i||r){const u=s?this.fullLayer:this.drawLayer||this.fullLayer;h=this.draw({workId:n,layer:u,isDrawing:!0})}if(!i){const u=Date.now();return u-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=u,{type:f.DrawWork,dataType:C.Local,workId:n,op:this.tmpPoints.map(y=>[...y.XY,0]).flat(1),isSync:!0,index:0}):{type:f.None}}const d=B(h,this.oldRect);return this.oldRect=h,{rect:d,type:f.DrawWork,dataType:C.Local,workId:n}}consumeAll(t){var e,o;const{data:s}=t,i=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!i)return{type:f.None};if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[i]};const r=this.fullLayer,n=this.draw({workId:i,layer:r,isDrawing:!1});this.oldRect=n;const a=this.tmpPoints.map(c=>[...c.XY,0]).flat(1),l=V(a);return(o=this.vNodes)==null||o.setInfo(i,{rect:n,op:a,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:n&&P.getCenterPos(n,r)}),{rect:n,type:f.FullWork,dataType:C.Local,workId:i,ops:l,isSync:!0,opt:this.workOptions}}draw(t){var e;const{workId:o,layer:s,isDrawing:i}=t;this.fullLayer.getElementsByName(o).map(L=>L.remove()),(e=this.drawLayer)==null||e.getElementsByName(o).map(L=>L.remove());const{strokeColor:r,fillColor:n,thickness:a,zIndex:l,vertices:c,innerVerticeStep:p,innerRatio:h,scale:d,rotate:u,translate:y}=this.workOptions,w=s.worldScaling,{rect:T,pos:N,points:I}=this.computDrawPoints(a,c,p,h),S={close:!0,points:I,lineWidth:a,fillColor:n!=="transparent"&&n||void 0,strokeColor:r,normalize:!0,lineJoin:"round"},g={name:o,id:o,zIndex:l,pos:N,anchor:[.5,.5],size:[T.w,T.h],className:`${N[0]},${N[1]}`};d&&(g.scale=d),u&&(g.rotate=u),y&&(g.translate=y);const x=new G(g);if(i){const L=new st({d:"M-4,0H4M0,-4V4",normalize:!0,pos:[0,0],strokeColor:r,lineWidth:1,scale:[1/w[0],1/w[1]]});x.append(L)}const M=new ot({...S,pos:[0,0]});x.append(M),s.append(x);const W=x.getBoundingClientRect();return{x:Math.floor(W.x-P.SafeBorderPadding),y:Math.floor(W.y-P.SafeBorderPadding),w:Math.floor(W.width+P.SafeBorderPadding*2),h:Math.floor(W.height+P.SafeBorderPadding*2)}}computDrawPoints(t,e,o,s){const i=F(this.tmpPoints),r=[Math.floor(i.x+i.w/2),Math.floor(i.y+i.h/2)],n=Pt(i.w,i.h),a=Math.floor(Math.min(i.w,i.h)/2),l=s*a,c=[],p=2*Math.PI/e;for(let h=0;h<e;h++){const d=h*p-.5*Math.PI;let u,y;h%o===1?(u=l*n[0]*Math.cos(d),y=l*n[1]*Math.sin(d)):(u=a*n[0]*Math.cos(d),y=a*n[1]*Math.sin(d),c.push(u,y)),c.push(u,y)}return{rect:F(this.tmpPoints,t),pos:r,points:c}}updateTempPoints(t){const e=t.slice(-2),o=new b(e[0],e[1]),s=this.tmpPoints[0],{thickness:i}=this.workOptions;if(s.isNear(o,i)||b.Sub(s,o).XY.includes(0))return!1;if(this.tmpPoints.length===2){if(o.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=o}else this.tmpPoints.push(o);return!0}consumeService(t){var e,o;const{op:s,isFullWork:i}=t,r=(e=this.workId)==null?void 0:e.toString();if(!r)return;this.tmpPoints.length=0;for(let l=0;l<s.length;l+=3)this.tmpPoints.push(new b(s[l],s[l+1],s[l+2]));const n=i?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:r,layer:n,isDrawing:!1});return this.oldRect=a,(o=this.vNodes)==null||o.setInfo(r,{rect:a,op:s,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&P.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){const{node:e,opt:o,vNodes:s}=t,{strokeColor:i,fillColor:r,toolsType:n,vertices:a,innerVerticeStep:l,innerRatio:c}=o,p=s.get(e.name),h=p==null?void 0:p.opt;let d=e;return e.tagName==="GROUP"&&(d=e.children[0]),i&&(d.setAttribute("strokeColor",i),h!=null&&h.strokeColor&&(h.strokeColor=i)),r&&(r==="transparent"?d.setAttribute("fillColor","rgba(0,0,0,0)"):d.setAttribute("fillColor",r),h!=null&&h.fillColor&&(h.fillColor=r)),n===v.Star&&(a&&(h.vertices=a),l&&(h.innerVerticeStep=l),c&&(h.innerRatio=c)),p&&s.setInfo(e.name,{...p,opt:h}),P.updateNodeOpt(t)}}class Dt extends P{constructor(t){super(t),m(this,"canRotate",!1),m(this,"scaleType",U.all),m(this,"toolsType",v.Polygon),m(this,"tmpPoints",[]),m(this,"workOptions"),m(this,"oldRect"),m(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:i,isMainThread:r}=t,n=(e=o==null?void 0:o.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a,workState:l}=o,c=a==null?void 0:a.length;if(!c||c<2)return{type:f.None};let p;if(l===D.Start?(this.tmpPoints=[new b(a[0],a[1])],p=!1):p=this.updateTempPoints(a),!p)return{type:f.None};let h;if(i||r){const u=s?this.fullLayer:this.drawLayer||this.fullLayer;h=this.draw({workId:n,layer:u,isDrawing:!0})}if(!i){const u=Date.now();return u-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=u,{type:f.DrawWork,dataType:C.Local,workId:n,op:this.tmpPoints.map(y=>[...y.XY,0]).flat(1),isSync:!0,index:0}):{type:f.None}}const d=B(h,this.oldRect);return this.oldRect=h,{rect:d,type:f.DrawWork,dataType:C.Local,workId:n}}consumeAll(t){var e,o;const{data:s}=t,i=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!i)return{type:f.None};if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[i]};const r=this.fullLayer,n=this.draw({workId:i,layer:r,isDrawing:!1});this.oldRect=n;const a=this.tmpPoints.map(c=>[...c.XY,0]).flat(1),l=V(a);return(o=this.vNodes)==null||o.setInfo(i,{rect:n,op:a,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:n&&P.getCenterPos(n,r)}),{rect:n,type:f.FullWork,dataType:C.Local,workId:i,ops:l,isSync:!0,opt:this.workOptions}}draw(t){var e;const{workId:o,layer:s,isDrawing:i}=t;this.fullLayer.getElementsByName(o).map(M=>M.remove()),(e=this.drawLayer)==null||e.getElementsByName(o).map(M=>M.remove());const{strokeColor:r,fillColor:n,thickness:a,zIndex:l,vertices:c,scale:p,rotate:h,translate:d}=this.workOptions,u=s.worldScaling,{rect:y,pos:w,points:T}=this.computDrawPoints(a,c),N={close:!0,points:T,lineWidth:a,fillColor:n!=="transparent"&&n||void 0,strokeColor:r,normalize:!0,lineJoin:"round"},I={name:o,id:o,zIndex:l,pos:w,anchor:[.5,.5],size:[y.w,y.h]};p&&(I.scale=p),h&&(I.rotate=h),d&&(I.translate=d);const S=new G(I);if(i){const M=new st({d:"M-4,0H4M0,-4V4",normalize:!0,pos:[0,0],strokeColor:r,lineWidth:1,scale:[1/u[0],1/u[1]]});S.append(M)}const g=new ot({...N,pos:[0,0]});S.append(g),s.append(S);const x=S.getBoundingClientRect();return{x:Math.floor(x.x-P.SafeBorderPadding),y:Math.floor(x.y-P.SafeBorderPadding),w:Math.floor(x.width+P.SafeBorderPadding*2),h:Math.floor(x.height+P.SafeBorderPadding*2)}}computDrawPoints(t,e){const o=F(this.tmpPoints),s=[Math.floor(o.x+o.w/2),Math.floor(o.y+o.h/2)],i=Pt(o.w,o.h),r=Math.floor(Math.min(o.w,o.h)/2),n=[],a=2*Math.PI/e;for(let l=0;l<e;l++){const c=l*a-.5*Math.PI,p=r*i[0]*Math.cos(c),h=r*i[1]*Math.sin(c);n.push(p,h)}return{rect:F(this.tmpPoints,t),pos:s,points:n}}updateTempPoints(t){const e=t.slice(-2),o=new b(e[0],e[1]),s=this.tmpPoints[0],{thickness:i}=this.workOptions;if(s.isNear(o,i)||b.Sub(s,o).XY.includes(0))return!1;if(this.tmpPoints.length===2){if(o.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=o}else this.tmpPoints.push(o);return!0}consumeService(t){var e,o;const{op:s,isFullWork:i}=t,r=(e=this.workId)==null?void 0:e.toString();if(!r)return;this.tmpPoints.length=0;for(let l=0;l<s.length;l+=3)this.tmpPoints.push(new b(s[l],s[l+1],s[l+2]));const n=i?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:r,layer:n,isDrawing:!1});return this.oldRect=a,(o=this.vNodes)==null||o.setInfo(r,{rect:a,op:s,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&P.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){const{node:e,opt:o,vNodes:s}=t,{strokeColor:i,fillColor:r,toolsType:n,vertices:a}=o,l=s.get(e.name),c=l==null?void 0:l.opt;let p=e;return e.tagName==="GROUP"&&(p=e.children[0]),i&&(p.setAttribute("strokeColor",i),c!=null&&c.strokeColor&&(c.strokeColor=i)),r&&(r==="transparent"?p.setAttribute("fillColor","rgba(0,0,0,0)"):p.setAttribute("fillColor",r),c!=null&&c.fillColor&&(c.fillColor=r)),n===v.Polygon&&a&&(c.vertices=a),l&&s.setInfo(e.name,{...l,opt:c}),P.updateNodeOpt(t)}}class j{static bezier(t,e){const o=[];for(let s=0;s<e.length;s+=4){const i=e[s],r=e[s+1],n=e[s+2],a=e[s+3];i&&r&&n&&a?o.push(...j.getBezierPoints(t,i,r,n,a)):i&&r&&n?o.push(...j.getBezierPoints(t,i,r,n)):i&&r?o.push(...j.getBezierPoints(t,i,r)):i&&o.push(i)}return o}static getBezierPoints(t=10,e,o,s,i){let r=null;const n=[];!s&&!i?r=j.oneBezier:s&&!i?r=j.twoBezier:s&&i&&(r=j.threeBezier);for(let a=0;a<t;a++)r&&n.push(r(a/t,e,o,s,i));return i?n.push(i):s&&n.push(s),n}static oneBezier(t,e,o){const s=e.x+(o.x-e.x)*t,i=e.y+(o.y-e.y)*t;return new k(s,i)}static twoBezier(t,e,o,s){const i=(1-t)*(1-t)*e.x+2*t*(1-t)*o.x+t*t*s.x,r=(1-t)*(1-t)*e.y+2*t*(1-t)*o.y+t*t*s.y;return new k(i,r)}static threeBezier(t,e,o,s,i){const r=e.x*(1-t)*(1-t)*(1-t)+3*o.x*t*(1-t)*(1-t)+3*s.x*t*t*(1-t)+i.x*t*t*t,n=e.y*(1-t)*(1-t)*(1-t)+3*o.y*t*(1-t)*(1-t)+3*s.y*t*t*(1-t)+i.y*t*t*t;return new k(r,n)}}class Et extends P{constructor(t){super(t),m(this,"canRotate",!1),m(this,"scaleType",U.all),m(this,"toolsType",v.SpeechBalloon),m(this,"ratio",.8),m(this,"tmpPoints",[]),m(this,"workOptions"),m(this,"oldRect"),m(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:i,isMainThread:r}=t,n=(e=o==null?void 0:o.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a,workState:l}=o,c=a==null?void 0:a.length;if(!c||c<2)return{type:f.None};let p;if(l===D.Start?(this.tmpPoints=[new b(a[0],a[1])],p=!1):p=this.updateTempPoints(a),!p)return{type:f.None};let h;if(i||r){const u=s?this.fullLayer:this.drawLayer||this.fullLayer;h=this.draw({workId:n,layer:u,isDrawing:!0})}if(!i){const u=Date.now();return u-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=u,{type:f.DrawWork,dataType:C.Local,workId:n,op:this.tmpPoints.map(y=>[...y.XY,0]).flat(1),isSync:!0,index:0}):{type:f.None}}const d=B(h,this.oldRect);return this.oldRect=h,{rect:d,type:f.DrawWork,dataType:C.Local,workId:n}}consumeAll(t){var e,o;const{data:s}=t,i=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!i)return{type:f.None};if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[i]};const r=this.fullLayer,n=this.draw({workId:i,layer:r,isDrawing:!1});this.oldRect=n;const a=this.tmpPoints.map(c=>[...c.XY,0]).flat(1),l=V(a);return(o=this.vNodes)==null||o.setInfo(i,{rect:n,op:a,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:n&&P.getCenterPos(n,r)}),{rect:n,type:f.FullWork,dataType:C.Local,workId:i,ops:l,isSync:!0,opt:this.workOptions}}draw(t){var e;const{workId:o,layer:s}=t;this.fullLayer.getElementsByName(o).map(g=>g.remove()),(e=this.drawLayer)==null||e.getElementsByName(o).map(g=>g.remove());const{strokeColor:i,fillColor:r,thickness:n,zIndex:a,placement:l,scale:c,rotate:p,translate:h}=this.workOptions,{rect:d,pos:u,points:y}=this.computDrawPoints(n,l),w={points:y.map(g=>g.XY),lineWidth:n,fillColor:r!=="transparent"&&r||void 0,strokeColor:i,normalize:!0,className:`${u[0]},${u[1]}`,lineJoin:"round",close:!0},T={name:o,id:o,zIndex:a,pos:u,anchor:[.5,.5],size:[d.w,d.h]};c&&(T.scale=c),p&&(T.rotate=p),h&&(T.translate=h);const N=new G(T),I=new ot({...w,pos:[0,0]});N.append(I),s.append(N);const S=N.getBoundingClientRect();return{x:Math.floor(S.x-P.SafeBorderPadding),y:Math.floor(S.y-P.SafeBorderPadding),w:Math.floor(S.width+P.SafeBorderPadding*2),h:Math.floor(S.height+P.SafeBorderPadding*2)}}transformControlPoints(t){const e=F(this.tmpPoints);switch(t){case"bottom":case"bottomLeft":case"bottomRight":{const o=e.y+e.h*this.ratio;return[new k(e.x,e.y,0),new k(e.x+e.w,e.y,0),new k(e.x+e.w,o,0),new k(e.x,o,0)]}case"top":case"topLeft":case"topRight":{const o=e.y+e.h*(1-this.ratio);return[new k(e.x,o,0),new k(e.x+e.w,o,0),new k(e.x+e.w,e.y+e.h,0),new k(e.x,e.y+e.h,0)]}case"left":case"leftBottom":case"leftTop":{const o=e.x+e.w*(1-this.ratio);return[new k(o,e.y,0),new k(e.x+e.w,e.y,0),new k(e.x+e.w,e.y+e.h,0),new k(o,e.y+e.h,0)]}case"right":case"rightBottom":case"rightTop":{const o=e.x+e.w*this.ratio;return[new k(e.x,e.y,0),new k(o,e.y,0),new k(o,e.y+e.h,0),new k(e.x,e.y+e.h,0)]}}}computDrawPoints(t,e){const o=F(this.tmpPoints),s=this.transformControlPoints(e),i=Math.floor(o.w*.1),r=Math.floor(o.h*.1),n=[],a=k.Add(s[0],new k(0,r,0)),l=k.Add(s[0],new k(i,0,0)),c=j.getBezierPoints(10,a,s[0],l),p=k.Sub(s[1],new k(i,0,0)),h=k.Add(s[1],new k(0,r,0)),d=j.getBezierPoints(10,p,s[1],h),u=k.Sub(s[2],new k(0,r,0)),y=k.Sub(s[2],new k(i,0,0)),w=j.getBezierPoints(10,u,s[2],y),T=k.Add(s[3],new k(i,0,0)),N=k.Sub(s[3],new k(0,r,0)),I=j.getBezierPoints(10,T,s[3],N),S=i*(1-this.ratio)*10,g=r*(1-this.ratio)*10;switch(e){case"bottom":{const W=k.Sub(s[2],new k(i*5-S/2,0,0)),L=k.Sub(s[2],new k(i*5,-g,0)),O=k.Sub(s[2],new k(i*5+S/2,0,0));n.push(L,O,...I,...c,...d,...w,W);break}case"bottomRight":{const W=k.Sub(s[2],new k(i*1.1,0,0)),L=k.Sub(s[2],new k(i*1.1+S/2,-g,0)),O=k.Sub(s[2],new k(i*1.1+S,0,0));n.push(L,O,...I,...c,...d,...w,W);break}case"bottomLeft":{const W=k.Add(s[3],new k(i*1.1+S,0,0)),L=k.Add(s[3],new k(i*1.1+S/2,g,0)),O=k.Add(s[3],new k(i*1.1,0,0));n.push(L,O,...I,...c,...d,...w,W);break}case"top":{const W=k.Sub(s[1],new k(i*5-S/2,0,0)),L=k.Sub(s[1],new k(i*5,g,0)),O=k.Sub(s[1],new k(i*5+S/2,0,0));n.push(L,W,...d,...w,...I,...c,O);break}case"topRight":{const W=k.Sub(s[1],new k(i*1.1,0,0)),L=k.Sub(s[1],new k(i*1.1+S/2,g,0)),O=k.Sub(s[1],new k(i*1.1+S,0,0));n.push(L,W,...d,...w,...I,...c,O);break}case"topLeft":{const W=k.Add(s[0],new k(i*1.1+S,0,0)),L=k.Add(s[0],new k(i*1.1+S/2,-g,0)),O=k.Add(s[0],new k(i*1.1,0,0));n.push(L,W,...d,...w,...I,...c,O);break}case"left":{const W=k.Add(s[0],new k(0,r*5-g/2,0)),L=k.Add(s[0],new k(-S,r*5,0)),O=k.Add(s[0],new k(0,r*5+g/2,0));n.push(L,W,...c,...d,...w,...I,O);break}case"leftTop":{const W=k.Add(s[0],new k(0,r*1.1,0)),L=k.Add(s[0],new k(-S,r*1.1+g/2,0)),O=k.Add(s[0],new k(0,r*1.1+g,0));n.push(L,W,...c,...d,...w,...I,O);break}case"leftBottom":{const W=k.Sub(s[3],new k(0,r*1.1+g,0)),L=k.Sub(s[3],new k(S,r*1.1+g/2,0)),O=k.Sub(s[3],new k(0,r*1.1,0));n.push(L,W,...c,...d,...w,...I,O);break}case"right":{const W=k.Add(s[1],new k(0,r*5-g/2,0)),L=k.Add(s[1],new k(S,r*5,0)),O=k.Add(s[1],new k(0,r*5+g/2,0));n.push(L,O,...w,...I,...c,...d,W);break}case"rightTop":{const W=k.Add(s[1],new k(0,r*1.1,0)),L=k.Add(s[1],new k(S,r*1.1+g/2,0)),O=k.Add(s[1],new k(0,r*1.1+g,0));n.push(L,O,...w,...I,...c,...d,W);break}case"rightBottom":{const W=k.Sub(s[2],new k(0,r*1.1+g,0)),L=k.Sub(s[2],new k(-S,r*1.1+g/2,0)),O=k.Sub(s[2],new k(0,r*1.1,0));n.push(L,O,...w,...I,...c,...d,W);break}}const x=F(this.tmpPoints,t),M=[Math.floor(x.x+x.w/2),Math.floor(x.y+x.h/2)];return{rect:x,pos:M,points:n}}updateTempPoints(t){const e=t.slice(-2),o=new b(e[0],e[1]),s=this.tmpPoints[0],{thickness:i}=this.workOptions;if(s.isNear(o,i)||b.Sub(s,o).XY.includes(0))return!1;if(this.tmpPoints.length===2){if(o.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=o}else this.tmpPoints.push(o);return!0}consumeService(t){var e,o;const{op:s,isFullWork:i}=t,r=(e=this.workId)==null?void 0:e.toString();if(!r)return;this.tmpPoints.length=0;for(let l=0;l<s.length;l+=3)this.tmpPoints.push(new b(s[l],s[l+1],s[l+2]));const n=i?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:r,layer:n,isDrawing:!1});return this.oldRect=a,(o=this.vNodes)==null||o.setInfo(r,{rect:a,op:s,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&P.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){const{node:e,opt:o,vNodes:s}=t,{strokeColor:i,fillColor:r,toolsType:n,placement:a}=o,l=s.get(e.name),c=l==null?void 0:l.opt;let p=e;return e.tagName==="GROUP"&&(p=e.children[0]),i&&(p.setAttribute("strokeColor",i),c!=null&&c.strokeColor&&(c.strokeColor=i)),r&&(r==="transparent"?p.setAttribute("fillColor","rgba(0,0,0,0)"):p.setAttribute("fillColor",r),c!=null&&c.fillColor&&(c.fillColor=r)),n===v.SpeechBalloon&&a&&(c.placement=a),l&&s.setInfo(e.name,{...l,opt:c}),P.updateNodeOpt(t)}}class At extends P{constructor(t){super(t),m(this,"canRotate",!0),m(this,"scaleType",U.all),m(this,"toolsType",v.Image),m(this,"tmpPoints",[]),m(this,"workOptions"),m(this,"oldRect"),this.workOptions=t.toolsOpt,this.scaleType=this.workOptions.uniformScale?U.proportional:U.all}consume(){return{type:f.None}}consumeAll(){return{type:f.None}}draw(t){var e;const{layer:o,workId:s,replaceId:i,imageBitmap:r,isMainThread:n}=t,{centerX:a,centerY:l,width:c,height:p,scale:h,rotate:d,translate:u,zIndex:y}=this.workOptions;this.fullLayer.getElementsByName(i||s).map(S=>S.remove()),(e=this.drawLayer)==null||e.getElementsByName(i||s).map(S=>S.remove());const w={anchor:[.5,.5],pos:[a,l],name:s,size:[c,p],zIndex:y};if(h)if(this.scaleType===U.proportional){const S=Math.min(h[0],h[1]);w.scale=[S,S]}else w.scale=h;u&&(w.translate=u),d&&(w.rotate=d);const T=new G(w),N=new Vt({anchor:[.5,.5],pos:[0,0],size:[c,p],texture:r,rotate:!n&&180||void 0});T.append(N),o.append(T);const I=T.getBoundingClientRect();if(I)return{x:Math.floor(I.x-P.SafeBorderPadding),y:Math.floor(I.y-P.SafeBorderPadding),w:Math.floor(I.width+P.SafeBorderPadding*2),h:Math.floor(I.height+P.SafeBorderPadding*2)}}consumeService(){}async consumeServiceAsync(t){var e,o,s,i;const{isFullWork:r,replaceId:n,scene:a,isMainThread:l}=t,{src:c,uuid:p}=this.workOptions,h=((e=this.workId)==null?void 0:e.toString())||p,d=r?this.fullLayer:this.drawLayer||this.fullLayer;if(c){const u=await a.preload({id:p,src:this.workOptions.src}),y=this.draw({workId:h,layer:d,replaceId:n,imageBitmap:u[0],isMainThread:l});return this.oldRect=h&&((s=(o=this.vNodes)==null?void 0:o.get(h))==null?void 0:s.rect)||void 0,(i=this.vNodes)==null||i.setInfo(h,{rect:y,op:[],opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:y&&P.getCenterPos(y,d)}),y}}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){const{node:e,opt:o,vNodes:s,targetNode:i}=t,{translate:r,box:n,boxScale:a,boxTranslate:l,angle:c,isLocked:p,zIndex:h}=o,d=i&&Z(i)||s.get(e.name);if(!d)return;const u=e.parent;if(u){if(q(h)&&(e.setAttribute("zIndex",h),d.opt.zIndex=h),_(p)&&(d.opt.locked=p),n&&l&&a){const{centerX:y,centerY:w,width:T,height:N,uniformScale:I}=d.opt;if(I){const x=Math.min(a[0],a[1]);d.opt.scale=[x,x]}else d.opt.scale=a;d.opt.width=Math.floor(T*a[0]),d.opt.height=Math.floor(N*a[1]);const S=[l[0]/u.worldScaling[0],l[1]/u.worldScaling[1]];d.opt.centerX=y+S[0],d.opt.centerY=w+S[1];const g=[d.centerPos[0]+S[0],d.centerPos[1]+S[1]];if(d.centerPos=g,i){let x=It(d.rect,a);x=ht(x,S),d.rect=x}}else if(r){const y=[r[0]/u.worldScaling[0],r[1]/u.worldScaling[1]];if(d.opt.centerX=d.opt.centerX+y[0],d.opt.centerY=d.opt.centerY+y[1],d.centerPos=[d.centerPos[0]+y[0],d.centerPos[1]+y[1]],i){const w=ht(d.rect,y);d.rect=w}}else if(q(c)&&(e.setAttribute("rotate",c),d.opt.rotate=c,i)){const y=Tt(d.rect,c);d.rect=y}return d&&s.setInfo(e.name,d),d==null?void 0:d.rect}}}class Bt extends P{constructor(t){super(t),m(this,"canRotate",!1),m(this,"scaleType",U.both),m(this,"toolsType",v.Straight),m(this,"tmpPoints",[]),m(this,"workOptions"),m(this,"oldRect"),m(this,"straightTipWidth"),m(this,"syncTimestamp"),this.workOptions=t.toolsOpt,this.straightTipWidth=this.workOptions.thickness/2,this.syncTimestamp=0,this.syncUnitTime=50}consume(t){var e;const{data:o,isFullWork:s,isSubWorker:i,isMainThread:r}=t,n=(e=o==null?void 0:o.workId)==null?void 0:e.toString();if(!n)return{type:f.None};const{op:a,workState:l}=o,c=a==null?void 0:a.length;if(!c||c<2)return{type:f.None};let p;if(l===D.Start?(this.tmpPoints=[new b(a[0],a[1])],p=!1):p=this.updateTempPoints(a),!p)return{type:f.None};let h;if(i||r){const u=s?this.fullLayer:this.drawLayer||this.fullLayer;h=this.draw({workId:n,layer:u})}if(!i){const u=Date.now();return u-this.syncTimestamp>this.syncUnitTime?(this.syncTimestamp=u,{type:f.DrawWork,dataType:C.Local,workId:n,op:this.tmpPoints.map(y=>[...y.XY,0]).flat(1),isSync:!0,index:0}):{type:f.None}}const d=B(h,this.oldRect);return this.oldRect=h,{rect:d,type:f.DrawWork,dataType:C.Local,workId:n}}consumeAll(t){var e,o;const{data:s}=t,i=(e=s==null?void 0:s.workId)==null?void 0:e.toString();if(!i)return{type:f.None};if(this.tmpPoints.length<2)return{type:f.RemoveNode,removeIds:[i]};const r=this.fullLayer,n=this.draw({workId:i,layer:r});this.oldRect=n;const a=this.tmpPoints.map(c=>[...c.XY,0]).flat(1),l=V(a);return(o=this.vNodes)==null||o.setInfo(i,{rect:n,op:a,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:n&&P.getCenterPos(n,r)}),{rect:n,type:f.FullWork,dataType:C.Local,workId:i,ops:l,isSync:!0,opt:this.workOptions}}draw(t){var e;const{workId:o,layer:s}=t;this.fullLayer.getElementsByName(o).map(N=>N.remove()),(e=this.drawLayer)==null||e.getElementsByName(o).map(N=>N.remove());const{strokeColor:i,thickness:r,zIndex:n,scale:a,rotate:l,translate:c}=this.workOptions,p=s.worldPosition,h=s.worldScaling,{d,rect:u}=this.computDrawPoints(r),y=[u.x+u.w/2,u.y+u.h/2],w={pos:y,name:o,id:o,d,fillColor:i,strokeColor:i,lineWidth:0,className:`${y[0]},${y[1]}`,normalize:!0,zIndex:n};a&&(w.scale=a),l&&(w.rotate=l),c&&(w.translate=c);const T=new st(w);if(s.append(T),l||a||c){const N=T.getBoundingClientRect();return{x:Math.floor(N.x-P.SafeBorderPadding),y:Math.floor(N.y-P.SafeBorderPadding),w:Math.floor(N.width+P.SafeBorderPadding*2),h:Math.floor(N.height+P.SafeBorderPadding*2)}}return{x:Math.floor(u.x*h[0]+p[0]-P.SafeBorderPadding),y:Math.floor(u.y*h[1]+p[1]-P.SafeBorderPadding),w:Math.floor(u.w*h[0]+2*P.SafeBorderPadding),h:Math.floor(u.h*h[1]+2*P.SafeBorderPadding)}}computDrawPoints(t){return this.tmpPoints[1].distance(this.tmpPoints[0])>this.straightTipWidth?this.computFullPoints(t):this.computDotPoints(t)}computFullPoints(t){const e=k.Sub(this.tmpPoints[1],this.tmpPoints[0]).uni(),o=k.Per(e).mul(t/2),s=b.Sub(this.tmpPoints[0],o),i=b.Add(this.tmpPoints[0],o),r=b.Sub(this.tmpPoints[1],o),n=b.Add(this.tmpPoints[1],o),a=b.GetSemicircleStroke(this.tmpPoints[1],r,-1,8),l=b.GetSemicircleStroke(this.tmpPoints[0],i,-1,8),c=[s,r,...a,n,i,...l];return{d:at(c,!0),rect:F(c),isDot:!1,pos:this.tmpPoints[0].XY}}computDotPoints(t){const e=b.GetDotStroke(this.tmpPoints[0],t/2,8);return{d:at(e,!0),rect:F(e),isDot:!0,pos:this.tmpPoints[0].XY}}updateTempPoints(t){const e=t.slice(-2),o=new b(e[0],e[1]),s=this.tmpPoints[0],{thickness:i}=this.workOptions;if(s.isNear(o,i))return!1;if(this.tmpPoints.length===2){if(o.isNear(this.tmpPoints[1],1))return!1;this.tmpPoints[1]=o}else this.tmpPoints.push(o);return!0}consumeService(t){var e,o;const{op:s,isFullWork:i}=t,r=(e=this.workId)==null?void 0:e.toString();if(!r)return;this.tmpPoints.length=0;for(let l=0;l<s.length;l+=3)this.tmpPoints.push(new b(s[l],s[l+1],s[l+2]));const n=i?this.fullLayer:this.drawLayer||this.fullLayer,a=this.draw({workId:r,layer:n});return this.oldRect=a,(o=this.vNodes)==null||o.setInfo(r,{rect:a,op:s,opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:a&&P.getCenterPos(a,n)}),a}clearTmpPoints(){this.tmpPoints.length=0}static updateNodeOpt(t){var e;const{node:o,opt:s,vNodes:i}=t,{strokeColor:r}=s,n=i.get(o.name);return r&&(o.setAttribute("strokeColor",r),o.setAttribute("fillColor",r),(e=n==null?void 0:n.opt)!=null&&e.strokeColor&&(n.opt.strokeColor=r)),n&&i.setInfo(o.name,n),P.updateNodeOpt(t)}}class pt extends P{constructor(t){super(t),m(this,"canRotate",!1),m(this,"scaleType",U.all),m(this,"toolsType",v.Text),m(this,"tmpPoints",[]),m(this,"workOptions"),m(this,"oldRect"),this.workOptions=t.toolsOpt}consume(){return{type:f.None}}consumeAll(){return{type:f.None}}draw(t){var e;const{workId:o,layer:s,isDrawLabel:i}=t;this.fullLayer.getElementsByName(o).map(y=>y.remove()),(e=this.drawLayer)==null||e.getElementsByName(o).map(y=>y.remove());const{boxSize:r,boxPoint:n,zIndex:a}=this.workOptions,l=s.worldPosition,c=s.worldScaling;if(!n||!r)return;const p=new G({name:o,id:o,pos:[n[0]+r[0]/2,n[1]+r[1]/2],anchor:[.5,.5],size:r,zIndex:a}),h={x:n[0],y:n[1],w:r[0],h:r[1]},d=new yt({normalize:!0,pos:[0,0],size:r}),u=i&&pt.createLabels(this.workOptions,s)||[];return p.append(...u,d),s.append(p),{x:Math.floor(h.x*c[0]+l[0]),y:Math.floor(h.y*c[1]+l[1]),w:Math.floor(h.w*c[0]),h:Math.floor(h.h*c[1])}}consumeService(t){var e,o,s,i;const r=(e=this.workId)==null?void 0:e.toString();if(!r)return;const{isFullWork:n,replaceId:a,isDrawLabel:l}=t;this.oldRect=a&&((s=(o=this.vNodes)==null?void 0:o.get(a))==null?void 0:s.rect)||void 0;const c=n?this.fullLayer:this.drawLayer||this.fullLayer,p=this.draw({workId:r,layer:c,isDrawLabel:l});return(i=this.vNodes)==null||i.setInfo(r,{rect:p,op:[],opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:p&&P.getCenterPos(p,c)}),p}updataOptService(t){var e,o;if(!this.workId)return;const s=this.workId.toString(),{fontColor:i,fontBgColor:r,bold:n,italic:a,lineThrough:l,underline:c,zIndex:p}=t,h=(e=this.vNodes)==null?void 0:e.get(s);if(!h)return;i&&(h.opt.fontColor=i),r&&(h.opt.fontBgColor=r),n&&(h.opt.bold=n),a&&(h.opt.italic=a),_(l)&&(h.opt.lineThrough=l),_(c)&&(h.opt.underline=c),r&&(h.opt.fontBgColor=r),q(p)&&(h.opt.zIndex=p),this.oldRect=h.rect;const d=this.draw({workId:s,layer:this.fullLayer,isDrawLabel:!1});return(o=this.vNodes)==null||o.setInfo(s,{rect:d,op:[],opt:this.workOptions,toolsType:this.toolsType,scaleType:this.scaleType,canRotate:this.canRotate,centerPos:d&&P.getCenterPos(d,this.fullLayer)}),d}clearTmpPoints(){this.tmpPoints.length=0}static getFontWidth(t){const{ctx:e,opt:o,text:s}=t,{bold:i,italic:r,fontSize:n,fontFamily:a}=o;return e.font=`${i} ${r} ${n}px ${a}`,e.measureText(s).width}static createLabels(t,e){const o=[],s=t.text.split(","),i=s.length;for(let r=0;r<i;r++){const n=s[r],{fontSize:a,lineHeight:l,bold:c,textAlign:p,italic:h,boxSize:d,fontFamily:u,verticalAlign:y,fontColor:w,underline:T,lineThrough:N}=t,I=l||a*1.2,S=e&&e.parent.canvas.getContext("2d"),g=S&&pt.getFontWidth({text:n,opt:t,ctx:S,worldScaling:e.worldScaling});if(g){const x={anchor:[0,.5],text:n,fontSize:a,lineHeight:I,fontFamily:u,fontWeight:c,fillColor:w,textAlign:p,fontStyle:h,name:r.toString(),className:"label"},M=[0,0];if(y==="middle"){const L=(i-1)/2;M[1]=(r-L)*I}p==="left"&&(M[0]=d&&-d[0]/2+5||0),x.pos=M;const W=new Gt(x);if(o.push(W),T){const L={normalize:!1,pos:[x.pos[0],x.pos[1]+a/2],lineWidth:2*e.worldScaling[0],points:[0,0,g,0],strokeColor:w,name:`${r}_underline`,className:"underline"},O=new ot(L);o.push(O)}if(N){const L={normalize:!1,pos:x.pos,lineWidth:2*e.worldScaling[0],points:[0,0,g,0],strokeColor:w,name:`${r}_lineThrough`,className:"lineThrough"},O=new ot(L);o.push(O)}}}return o}static updateNodeOpt(t){const{node:e,opt:o,vNodes:s,targetNode:i}=t,{fontBgColor:r,fontColor:n,translate:a,box:l,boxScale:c,boxTranslate:p,bold:h,italic:d,lineThrough:u,underline:y,fontSize:w,textInfos:T}=o,N=i&&Z(i)||s.get(e.name);if(!N)return;const I=e.parent;if(!I)return;const S=N.opt;if(n&&S.fontColor&&(S.fontColor=n),r&&S.fontBgColor&&(S.fontBgColor=r),h&&(S.bold=h),d&&(S.italic=d),_(u)&&(S.lineThrough=u),_(y)&&(S.underline=y),w&&(S.fontSize=w),l&&p&&c){const g=T==null?void 0:T.get(e.name);if(g){const{fontSize:W,boxSize:L}=g;S.boxSize=L||S.boxSize,S.fontSize=W||S.fontSize}const x=N.rect,M=ht(It(x,c),p);S.boxPoint=M&&[(M.x-I.worldPosition[0])/I.worldScaling[0],(M.y-I.worldPosition[1])/I.worldScaling[1]]}else if(a&&S.boxPoint){const g=[a[0]/I.worldScaling[0],a[1]/I.worldScaling[1]];S.boxPoint=[S.boxPoint[0]+g[0],S.boxPoint[1]+g[1]],N.centerPos=[N.centerPos[0]+g[0],N.centerPos[1]+g[1]],N.rect=ht(N.rect,g)}return N&&s.setInfo(e.name,N),N==null?void 0:N.rect}static getRectFromLayer(t,e){const o=t.getElementsByName(e)[0];if(o){const s=o.getBoundingClientRect();return{x:Math.floor(s.x),y:Math.floor(s.y),w:Math.floor(s.width),h:Math.floor(s.height)}}}}function zt(R){switch(R){case v.Arrow:return Ct;case v.Pencil:return Wt;case v.Straight:return Bt;case v.Ellipse:return bt;case v.Polygon:case v.Triangle:return Dt;case v.Star:case v.Rhombus:return Mt;case v.Rectangle:return Ot;case v.SpeechBalloon:return Et;case v.Text:return pt;case v.LaserPen:return Lt;case v.Eraser:return Rt;case v.Selector:return H;case v.Image:return At}}function ut(R,t){const{toolsType:e,...o}=R;switch(e){case v.Arrow:return new Ct(o);case v.Pencil:return new Wt(o);case v.Straight:return new Bt(o);case v.Ellipse:return new bt(o);case v.Polygon:case v.Triangle:return new Dt(o);case v.Star:case v.Rhombus:return new Mt(o);case v.Rectangle:return new Ot(o);case v.SpeechBalloon:return new Et(o);case v.Text:return new pt(o);case v.LaserPen:return new Lt(o);case v.Eraser:return new Rt(o,t);case v.Selector:return o.vNodes?new H({...o,vNodes:o.vNodes,drawLayer:o.fullLayer}):void 0;case v.Image:return new At(o);default:return}}function Ft(R){const t=[],e=["PATH","SPRITE","POLYLINE","RECT","ELLIPSE"];for(const o of R){if(o.tagName==="GROUP"&&o.children.length)return Ft(o.children);o.tagName&&e.includes(o.tagName)&&t.push(o)}return t}const Qt=R=>{if(R.tagName==="GROUP"){const t=Object.getOwnPropertySymbols(R).find(e=>e.toString()==="Symbol(sealed)");if(t&&R[t])return!0}return!1},Zt=R=>R!==v.Text,ft="cursorhover";class Jt{constructor(t,e){m(this,"viewId"),m(this,"scene"),m(this,"fullLayer"),m(this,"curNodeMap",new Map),m(this,"targetNodeMap",[]),this.viewId=t,this.scene=e}init(t){this.fullLayer=t}get(t){return this.curNodeMap.get(t)}hasRenderNodes(){let t=!1;for(const e of this.curNodeMap.values())Zt(e.toolsType)&&(t=!0);return t}has(t){this.curNodeMap.has(t)}setInfo(t,e){const o=this.curNodeMap.get(t)||{name:t,rect:e.rect};e.rect&&(o.rect=Z(e.rect)),e.op&&(o.op=Z(e.op)),e.canRotate&&(o.canRotate=e.canRotate),e.scaleType&&(o.scaleType=e.scaleType),e.opt&&(o.opt=Z(e.opt)),e.toolsType&&(o.toolsType=e.toolsType),e.centerPos&&(o.centerPos=Z(e.centerPos)),_(e.isSelected)&&(o.isSelected=e.isSelected),o.rect?this.curNodeMap.set(t,o):this.curNodeMap.delete(t)}selected(t){this.setInfo(t,{isSelected:!0})}unSelected(t){this.setInfo(t,{isSelected:!1})}delete(t){this.curNodeMap.delete(t)}clear(){this.curNodeMap.clear(),this.targetNodeMap.length=0}hasRectIntersectRange(t,e=!0){for(const o of this.curNodeMap.values())if(lt(t,o.rect)){if(e&&o.toolsType===v.Image&&o.opt.locked||e&&o.toolsType===v.Text&&(o.opt.workState===D.Doing||o.opt.workState===D.Start))continue;return!0}return!1}getRectIntersectRange(t,e=!0){let o;const s=new Map;for(const[i,r]of this.curNodeMap.entries())if(lt(t,r.rect)){if(e&&r.toolsType===v.Image&&r.opt.locked||e&&r.toolsType===v.Text&&(r.opt.workState===D.Doing||r.opt.workState===D.Start))continue;o=B(o,r.rect),s.set(i,r)}return{rectRange:o,nodeRange:s}}getNodeRectFormShape(t,e){const o=zt(e.toolsType);return this.fullLayer&&(o==null?void 0:o.getRectFromLayer(this.fullLayer,t))}updateNodesRect(){this.curNodeMap.forEach((t,e)=>{const o=this.getNodeRectFormShape(e,t);o?(t.rect=o,this.curNodeMap.set(e,t)):this.curNodeMap.delete(e)})}combineIntersectRect(t){let e=t;return this.curNodeMap.forEach(o=>{lt(e,o.rect)&&(e=B(e,o.rect))}),e}setTarget(){return this.targetNodeMap.push(Z(this.curNodeMap)),this.targetNodeMap.length-1}getLastTarget(){return this.targetNodeMap[this.targetNodeMap.length-1]}deleteLastTarget(){this.targetNodeMap.length=this.targetNodeMap.length-1}getTarget(t){return this.targetNodeMap[t]}deleteTarget(t){this.targetNodeMap.length=t}}class _t{constructor(t){m(this,"vNodes"),m(this,"thread"),m(this,"serviceWorkShapes",new Map),m(this,"localWorkShapes",new Map),m(this,"tmpOpt"),m(this,"tmpWorkShapeNode"),m(this,"animationId"),this.vNodes=t.vNodes,this.thread=t.thread}destroy(){this.clearAll()}clearAll(){this.thread.topLayer.children.length&&(this.thread.topLayer.parent.children.forEach(t=>{t.name!=="viewport"&&t.remove()}),this.thread.serviceLayer.removeAllChildren()),this.serviceWorkShapes.clear(),this.localWorkShapes.clear()}consumeDraw(t){const{workId:e,dataType:o}=t;if(o===C.Service)this.activeServiceWorkShape(t);else{const s=this.localWorkShapes.get(e);if(!s)return;const i=s.node.consume({data:t,isFullWork:!1,isClearAll:!0,isSubWorker:!0});i.rect&&(s.result=i,s.workState=D.Doing,e&&this.localWorkShapes.set(e,s))}this.runAnimation()}setToolsOpt(t){this.tmpOpt=t,this.tmpWorkShapeNode=this.createWorkShapeNode(t)}createWorkShapeNode(t){const{toolsType:e}=t;if(e===v.LaserPen)return ut({...t,vNodes:this.vNodes,fullLayer:this.thread.topLayer,drawLayer:this.thread.topLayer})}getTmpWorkShapeNode(){return this.tmpWorkShapeNode}setTmpWorkId(t){if(t&&this.tmpWorkShapeNode){this.tmpWorkShapeNode.setWorkId(t),this.localWorkShapes.set(t,{node:this.tmpWorkShapeNode,toolsType:this.tmpWorkShapeNode.toolsType,workState:D.Start}),this.tmpOpt&&this.setToolsOpt(this.tmpOpt);return}}setNodeKey(t,e,o){return t.toolsType=e,t.node=this.createWorkShapeNode({toolsType:e,toolsOpt:o}),t}activeServiceWorkShape(t){var e,o;const{workId:s,opt:i,toolsType:r,type:n,updateNodeOpt:a,ops:l,op:c}=t;if(!s)return;const p=s.toString(),h=(e=this.vNodes.get(p))==null?void 0:e.rect;if(!((o=this.serviceWorkShapes)!=null&&o.has(p))){let u={toolsType:r,animationWorkData:c||[],animationIndex:0,type:n,updateNodeOpt:a,ops:l,oldRect:h};r&&i&&(u=this.setNodeKey(u,r,i)),this.serviceWorkShapes.set(p,u)}const d=this.serviceWorkShapes.get(p);n&&(d.type=n),l&&(d.animationWorkData=ct(l),d.ops=l),a&&(d.updateNodeOpt=a),c&&(d.animationWorkData=c),d.node&&d.node.getWorkId()!==p&&d.node.setWorkId(p),h&&(d.oldRect=h),r&&i&&(d.toolsType!==r&&r&&i&&this.setNodeKey(d,r,i),d.node&&d.node.setWorkOptions(i))}computNextAnimationIndex(t,e){var o;const s=Math.floor((t.animationWorkData||[]).slice(t.animationIndex).length*32/e/(((o=t.node)==null?void 0:o.syncUnitTime)||1e3))*e;return Math.min((t.animationIndex||0)+(s||e),(t.animationWorkData||[]).length)}animationDraw(){var t,e,o,s;this.animationId=void 0;let i=!1;const r=new Map,n=[];for(const[a,l]of this.serviceWorkShapes.entries())switch(l.toolsType){case v.LaserPen:{const c=this.computNextAnimationIndex(l,8),p=Math.max(0,l.animationIndex||0),h=(l.animationWorkData||[]).slice(p,c);if((l.animationIndex||0)<c&&((t=l.node)==null||t.consumeService({op:h,isFullWork:!1}),l.animationIndex=c,h.length&&r.set(a,{workState:p===0?D.Start:c===((e=l.animationWorkData)==null?void 0:e.length)?D.Done:D.Doing,op:h.slice(-2)})),l.isDel){(o=l.node)==null||o.clearTmpPoints(),this.serviceWorkShapes.delete(a);break}l.ops&&l.animationIndex===((s=l.animationWorkData)==null?void 0:s.length)&&!l.isDel&&(this.thread.topLayer.getElementsByName(a.toString())[0]||(l.isDel=!0,this.serviceWorkShapes.set(a,l))),i=!0;break}}for(const[a,l]of this.localWorkShapes.entries()){const{result:c,toolsType:p,isDel:h,workState:d}=l;switch(p){case v.LaserPen:{if(h){l.node.clearTmpPoints(),this.localWorkShapes.delete(a),n.push({removeIds:[a.toString()],type:f.RemoveNode});break}c&&((c.op||c.ops)&&n.push(c),l.result=void 0),!this.thread.topLayer.getElementsByName(a.toString())[0]&&d===D.Done&&(l.isDel=!0,this.localWorkShapes.set(a,l)),i=!0;break}}}i&&this.runAnimation(),r.size&&r.forEach((a,l)=>{n.push({type:f.Cursor,uid:l.split(wt)[0],op:a.op,workState:a.workState,viewId:this.thread.viewId})}),n.length&&this.thread.post({sp:n})}runAnimation(){this.animationId||(this.animationId=requestAnimationFrame(this.animationDraw.bind(this)))}setWorkOptions(t,e){var o,s,i;(o=this.localWorkShapes.get(t))!=null&&o.node||this.setTmpWorkId(t),(i=(s=this.localWorkShapes.get(t))==null?void 0:s.node)==null||i.setWorkOptions(e)}consumeDrawAll(t){const{workId:e,dataType:o}=t;if(o===C.Service)this.activeServiceWorkShape(t);else{const s=this.localWorkShapes.get(e);if(!s)return;const i=s.node.consumeAll({data:t});s.result=i,s.workState=D.Done,e&&this.localWorkShapes.set(e,s)}this.runAnimation()}}class te{constructor(t){m(this,"vNodes"),m(this,"thread"),m(this,"workShapes",new Map),m(this,"effectSelectNodeData",new Set),m(this,"batchEraserRemoveNodes",new Set),m(this,"batchEraserWorks",new Set),m(this,"tmpOpt"),m(this,"tmpWorkShapeNode"),m(this,"drawCount",0),m(this,"batchEraserCombine",qt(()=>{this.updateBatchEraserCombineNode(this.batchEraserWorks,this.batchEraserRemoveNodes),this.batchEraserWorks.clear(),this.batchEraserRemoveNodes.clear()},100,{leading:!1})),this.vNodes=t.vNodes,this.thread=t.thread}async updateSelector(t){var e;const o=this.workShapes.get(X);if(!((e=o==null?void 0:o.selectIds)!=null&&e.length))return;const{callback:s,...i}=t,{updateSelectorOpt:r,willSerializeData:n,scene:a}=i,l=await(o==null?void 0:o.updateSelector({updateSelectorOpt:r,selectIds:o.selectIds,vNodes:this.vNodes,willSerializeData:n,worker:this,scene:a,isMainThread:!0})),c=new Map;o.selectIds.forEach(d=>{const u=this.vNodes.get(d);if(u){const{toolsType:y,op:w,opt:T}=u;c.set(d,{opt:T,toolsType:y,ops:(w==null?void 0:w.length)&&V(w)||void 0})}});const p=[],h=s&&s({res:l,workShapeNode:o,param:i,postData:{sp:p},newServiceStore:c})||{sp:p};h.sp.length&&this.thread.post(h)}destroy(){this.clearAll()}clearAllWorkShapesCache(){this.workShapes.forEach(t=>t.clearTmpPoints()),this.workShapes.clear()}clearAll(){if(this.thread.localLayer.children.length&&(this.thread.topLayer.parent.children.forEach(t=>{t.name!=="viewport"&&t.remove()}),this.thread.localLayer.removeAllChildren()),this.workShapes.get(X)){const t=[];t.push({type:f.Select,dataType:C.Local,selectIds:[],willSyncService:!1}),this.thread.post({sp:t})}this.workShapes.clear(),this.effectSelectNodeData.clear(),this.batchEraserWorks.clear(),this.batchEraserRemoveNodes.clear()}async checkTextActive(t){const{op:e,viewId:o,dataType:s}=t;if(e!=null&&e.length){let i;for(const r of this.vNodes.curNodeMap.values()){const{rect:n,name:a,toolsType:l,opt:c}=r,p=e[0]*this.thread.fullLayer.worldScaling[0]+this.thread.fullLayer.worldPosition[0],h=e[1]*this.thread.fullLayer.worldScaling[1]+this.thread.fullLayer.worldPosition[1];if(l===v.Text&&jt([p,h],n)&&c.workState===D.Done){i=a;break}}i&&(await this.blurSelector({viewId:o,msgType:f.Select,dataType:s,isSync:!0}),this.thread.post({sp:[{type:f.GetTextActive,toolsType:v.Text,workId:i}]}))}}cursorHover(t){const{opt:e,toolsType:o,point:s}=t,i=this.setFullWork({workId:ft,toolsType:o,opt:e});i&&s&&i.cursorHover(s)}updateFullSelectWork(t){var e,o,s,i,r;const n=this.workShapes.get(X),{selectIds:a}=t;if(!(a!=null&&a.length)){this.blurSelector(t);return}if(!n){!this.setFullWork(t)&&t.workId&&((e=this.tmpWorkShapeNode)==null?void 0:e.toolsType)===v.Selector&&this.setTmpWorkId(t.workId),this.updateFullSelectWork(t);return}if(n&&a!=null&&a.length){const{selectRect:l}=n.updateSelectIds(a),c=[{...t,selectorColor:((o=t.opt)==null?void 0:o.strokeColor)||n.selectorColor,strokeColor:((s=t.opt)==null?void 0:s.strokeColor)||n.strokeColor,fillColor:((i=t.opt)==null?void 0:i.fillColor)||n.fillColor,textOpt:((r=t.opt)==null?void 0:r.textOpt)||n.textOpt,canTextEdit:n.canTextEdit,canRotate:n.canRotate,scaleType:n.scaleType,type:f.Select,selectRect:l,points:n.getChildrenPoints(),willSyncService:(t==null?void 0:t.willSyncService)||!1,opt:(t==null?void 0:t.willSyncService)&&n.getWorkOptions()||void 0,canLock:n.canLock,isLocked:n.isLocked,toolsTypes:n.toolsTypes,shapeOpt:n.shapeOpt}];this.thread.post({sp:c})}}removeWork(t){const{workId:e}=t,o=e==null?void 0:e.toString();o&&this.removeNode(o)}removeNode(t){var e;this.workShapes.has(t)&&this.clearWorkShapeNodeCache(t),this.vNodes.get(t)&&(this.thread.fullLayer.getElementsByName(t).concat(((e=this.thread.localLayer)==null?void 0:e.getElementsByName(t))||[]).forEach(o=>{o.remove()}),this.vNodes.delete(t))}setFullWork(t){const{workId:e,opt:o,toolsType:s}=t;if(e&&o&&s){const i=e&&this.workShapes.get(e)||this.createWorkShapeNode({toolsOpt:o,toolsType:s,workId:e});return i?(i.setWorkId(e),this.workShapes.set(e,i),i):void 0}}async consumeFull(t,e){var o;const s=this.setFullWork(t),i=t.ops&&ct(t.ops),r=(o=t.workId)==null?void 0:o.toString();if(r&&s){s.toolsType===v.Image&&e?await s.consumeServiceAsync({scene:e,isFullWork:!0,replaceId:r,isMainThread:!0}):s.consumeService({op:i,isFullWork:!0,replaceId:r}),t!=null&&t.updateNodeOpt&&s.updataOptService(t.updateNodeOpt);const n=[];t.workId&&this.workShapes.delete(t.workId),t.willSyncService&&n.push({opt:t.opt,toolsType:t.toolsType,type:f.FullWork,workId:t.workId,ops:t.ops,updateNodeOpt:t.updateNodeOpt,undoTickerId:t.undoTickerId,viewId:this.thread.viewId}),n.length&&this.thread.post({sp:n})}}async colloctEffectSelectWork(t){const e=this.workShapes.get(X),{workId:o,msgType:s}=t;if(e&&o&&e.selectIds&&e.selectIds.includes(o.toString())){s===f.RemoveNode?e.selectIds=e.selectIds.filter(i=>i!==o.toString()):this.effectSelectNodeData.add(t),await new Promise(i=>{setTimeout(()=>{i(!0)},0)}),await this.runEffectSelectWork(!0).then(()=>{var i;(i=this.effectSelectNodeData)==null||i.clear()});return}return t}async runEffectSelectWork(t){var e,o,s,i;for(const r of this.effectSelectNodeData.values()){const n=this.setFullWork(r);if(n){if(n.toolsType===v.Image)await n.consumeServiceAsync({scene:(o=(e=this.thread.localLayer)==null?void 0:e.parent)==null?void 0:o.parent,isFullWork:!0,replaceId:(s=n.getWorkId())==null?void 0:s.toString(),isMainThread:!0});else{const a=r.ops&&ct(r.ops);n.consumeService({op:a,isFullWork:!0,replaceId:(i=n.getWorkId())==null?void 0:i.toString()})}r!=null&&r.updateNodeOpt&&n.updataOptService(r.updateNodeOpt),r.workId&&this.workShapes.delete(r.workId)}}this.reRenderSelector(t)}reRenderSelector(t=!1){var e;const o=this.workShapes.get(X);if(!o)return;if(o&&!((e=o.selectIds)!=null&&e.length))return this.blurSelector();const s=o.reRenderSelector();s&&this.thread.post({sp:[{type:f.Select,selectIds:o.selectIds,selectRect:s,willSyncService:t,viewId:this.thread.viewId,points:o.getChildrenPoints(),textOpt:o.textOpt}]})}async blurSelector(t){var e;const o=this.workShapes.get(X),s=o==null?void 0:o.blurSelector();if(this.clearWorkShapeNodeCache(X),((e=this.thread.fullLayer)==null?void 0:e.parent).children.forEach(i=>{i.name===X&&i.remove()}),s){const i=[];i.push({...s,undoTickerId:t==null?void 0:t.undoTickerId,isSync:t==null?void 0:t.isSync}),this.thread.post({sp:i})}}clearWorkShapeNodeCache(t){var e;(e=this.getWorkShape(t))==null||e.clearTmpPoints(),this.workShapes.delete(t)}drawEraser(t){var e,o;const s=[];if((e=t.newWorkDatas)!=null&&e.size){for(const i of t.newWorkDatas.values()){const r=i.workId.toString();this.batchEraserWorks.add(r),s.push({type:f.FullWork,workId:r,ops:V(i.op),opt:i.opt,toolsType:i.toolsType,updateNodeOpt:{useAnimation:!1}})}delete t.newWorkDatas}(o=t.removeIds)==null||o.forEach(i=>{this.batchEraserRemoveNodes.add(i)}),console.log("first",t),s.push(t),this.thread.post({sp:s}),this.batchEraserCombine()}updateBatchEraserCombineNode(t,e){for(const o of e.keys())this.thread.fullLayer.getElementsByName(o).forEach(s=>{s.remove()});t.forEach(o=>{const s=this.vNodes.get(o);if(s&&s.toolsType===v.Pencil&&!this.thread.fullLayer.getElementsByName(o)[0]){const i=this.setFullWork({...s,workId:o});i&&i.consumeService({op:s.op,isFullWork:!0})}})}getWorkShape(t){return this.workShapes.get(t)}consumeDraw(t,e){const{op:o,workId:s,scenePath:i}=t;if(o!=null&&o.length&&s){const r=this.workShapes.get(s);if(!r)return;const n=r.toolsType;if(n===v.LaserPen)return;switch(n){case v.Selector:{const a=r.consume({data:t,isFullWork:!0});a.type===f.Select&&(a.selectIds&&e.runReverseSelectWork(a.selectIds),this.thread.post({sp:[a]}))}break;case v.Eraser:{const a=r.consume({data:t,isFullWork:!0});a!=null&&a.rect&&this.drawEraser(a)}break;case v.Arrow:case v.Straight:case v.Ellipse:case v.Rectangle:case v.Star:case v.Polygon:case v.SpeechBalloon:case v.Pencil:{const a=r.consume({data:t,isFullWork:!1,isMainThread:!0});a&&(this.drawCount++,this.thread.post({drawCount:this.drawCount,sp:a.op&&[{...a,scenePath:i}]||void 0}))}break}}}consumeDrawAll(t,e){var o,s,i;const{workId:r,scenePath:n}=t;if(r){const a=this.workShapes.get(r);if(!a)return;const l=a.toolsType;if(l===v.LaserPen)return;const c=this.workShapes.get(ft),p=(o=c==null?void 0:c.selectIds)==null?void 0:o[0],h=a.consumeAll({data:t});switch(l){case v.Selector:h.selectIds&&p&&(s=h.selectIds)!=null&&s.includes(p)&&c.cursorBlur(),h.type===f.Select&&(h.selectIds&&e.runReverseSelectWork(h.selectIds),this.thread.post({sp:[{...h,scenePath:n}]})),(i=a.selectIds)!=null&&i.length?a.clearTmpPoints():this.clearWorkShapeNodeCache(r);break;case v.Eraser:h!=null&&h.rect&&this.drawEraser({...h,scenePath:n}),a.clearTmpPoints();break;case v.Arrow:case v.Straight:case v.Ellipse:case v.Rectangle:case v.Star:case v.Polygon:case v.SpeechBalloon:case v.Pencil:h&&(this.drawCount=0,this.thread.post({drawCount:this.drawCount,sp:[h]})),this.clearWorkShapeNodeCache(r);break}}}getTmpWorkShapeNode(){return this.tmpWorkShapeNode}setToolsOpt(t){var e;const{toolsType:o}=t;(e=this.tmpOpt)!=null&&e.toolsType&&this.tmpOpt.toolsType!==o&&this.clearAllWorkShapesCache(),this.tmpOpt=t,this.tmpWorkShapeNode=this.createWorkShapeNode(t)}setTmpWorkId(t){if(t&&this.tmpWorkShapeNode){this.tmpWorkShapeNode.setWorkId(t),this.workShapes.set(t,this.tmpWorkShapeNode),this.tmpOpt&&this.setToolsOpt(this.tmpOpt);return}}setWorkOptions(t,e){var o;this.workShapes.get(t)||this.setTmpWorkId(t),(o=this.workShapes.get(t))==null||o.setWorkOptions(e)}createWorkShapeNode(t){return ut({...t,vNodes:this.vNodes,fullLayer:this.thread.fullLayer,drawLayer:this.thread.localLayer},this.thread.serviceWork)}}class ee{constructor(t){m(this,"vNodes"),m(this,"thread"),m(this,"workShapes",new Map),m(this,"selectorWorkShapes",new Map),m(this,"willRunEffectSelectorIds",new Set),m(this,"runEffectId"),m(this,"animationId"),this.vNodes=t.vNodes,this.thread=t.thread}destroy(){this.clearAll()}clearAll(){this.thread.serviceLayer.children.length&&(this.thread.serviceLayer.parent.children.forEach(t=>{t.name!=="viewport"&&t.remove()}),this.thread.serviceLayer.removeAllChildren()),this.workShapes.clear(),this.selectorWorkShapes.clear(),this.willRunEffectSelectorIds.clear()}runEffect(){this.runEffectId||(this.runEffectId=setTimeout(this.effectRunSelector.bind(this),0))}effectRunSelector(){this.runEffectId=void 0,this.willRunEffectSelectorIds.forEach(t=>{var e,o;const s=this.selectorWorkShapes.get(t);s&&s.selectIds&&((e=s.node)==null||e.selectServiceNode(t,s,!0)),(o=s==null?void 0:s.selectIds)!=null&&o.length||this.selectorWorkShapes.delete(t)}),this.willRunEffectSelectorIds.clear()}runSelectWork(t){this.activeSelectorShape(t);const{workId:e}=t,o=e==null?void 0:e.toString();o&&this.willRunEffectSelectorIds.add(o),this.runEffect()}removeWork(t){const{workId:e}=t,o=e==null?void 0:e.toString();if(o){if(this.workShapes.get(o)){this.workShapes.delete(o),this.removeNode(o,t);return}this.removeNode(o,t)}}consumeFull(t){this.activeWorkShape(t),this.runAnimation()}runReverseSelectWork(t){t.forEach(e=>{this.selectorWorkShapes.forEach((o,s)=>{var i;if((i=o.selectIds)!=null&&i.length){const r=o.selectIds.indexOf(e);r>-1&&(o.selectIds.splice(r,1),this.willRunEffectSelectorIds.add(s))}})}),this.willRunEffectSelectorIds.size&&this.runEffect()}consumeDraw(t){this.activeWorkShape(t),this.runAnimation()}computNextAnimationIndex(t,e){var o;const s=Math.floor((t.animationWorkData||[]).slice(t.animationIndex).length*32/e/(((o=t.node)==null?void 0:o.syncUnitTime)||1e3))*e;return Math.min((t.animationIndex||0)+(s||e),(t.animationWorkData||[]).length)}async animationDraw(){var t,e,o,s,i,r,n,a,l,c,p,h,d,u,y,w;this.animationId=void 0;let T=!1;const N=new Map;for(const[I,S]of this.workShapes.entries())switch(S.toolsType){case v.Image:{await((e=S.node)==null?void 0:e.consumeServiceAsync({isFullWork:!0,scene:(t=this.thread.fullLayer.parent)==null?void 0:t.parent,isMainThread:!0})),this.selectorWorkShapes.forEach((g,x)=>{var M;(M=g.selectIds)!=null&&M.includes(I)&&(this.willRunEffectSelectorIds.add(x),this.runEffect())}),this.workShapes.delete(I);break}case v.Text:{S.node&&((o=S.node)==null||o.consumeService({op:S.animationWorkData||[],isFullWork:!0}),this.selectorWorkShapes.forEach((g,x)=>{var M;(M=g.selectIds)!=null&&M.includes(I)&&(this.willRunEffectSelectorIds.add(x),this.runEffect())}),(s=S.node)==null||s.clearTmpPoints(),this.workShapes.delete(I));break}case v.Arrow:case v.Straight:case v.Rectangle:case v.Ellipse:case v.Star:case v.Polygon:case v.SpeechBalloon:{const g=!!S.ops;if((i=S.animationWorkData)!=null&&i.length){const x=S.oldRect;(r=S.node)==null||r.consumeService({op:S.animationWorkData,isFullWork:g}),g&&(this.selectorWorkShapes.forEach((M,W)=>{var L;(L=M.selectIds)!=null&&L.includes(I)&&(this.willRunEffectSelectorIds.add(W),this.runEffect())}),(n=S.node)==null||n.clearTmpPoints(),this.workShapes.delete(I)),N.set(I,{workState:x?S.ops?D.Done:D.Doing:D.Start,op:S.animationWorkData.filter((M,W)=>{if(W%3!==2)return!0}).slice(-2)}),S.animationWorkData.length=0}break}case v.Pencil:{if(!S.useAnimation&&S.ops)(a=S.node)==null||a.consumeService({op:S.animationWorkData||[],isFullWork:!0,replaceId:I}),(l=S.node)==null||l.updataOptService(S.updateNodeOpt),this.selectorWorkShapes.forEach((g,x)=>{var M;(M=g.selectIds)!=null&&M.includes(I)&&(this.willRunEffectSelectorIds.add(x),this.runEffect())}),(c=S.node)==null||c.clearTmpPoints(),this.workShapes.delete(I);else if(S.useAnimation){if(S.isDel){(p=S.node)==null||p.clearTmpPoints(),this.workShapes.delete(I);break}const g=3,x=this.computNextAnimationIndex(S,g),M=S.isDiff?0:Math.max(0,(S.animationIndex||0)-g),W=(S.animationWorkData||[]).slice(M,x),L=(d=(h=S.node)==null?void 0:h.getWorkId())==null?void 0:d.toString();if((S.animationIndex||0)<x||S.isDiff){if((u=S.node)==null||u.consumeService({op:W,isFullWork:!1}),S.animationIndex=x,S.isDiff&&(S.isDiff=!1),W.length){const O=W.filter((z,A)=>{if(A%g!==g-1)return!0}).slice(-2);N.set(I,{workState:M===0?D.Start:x===((y=S.animationWorkData)==null?void 0:y.length)?D.Done:D.Doing,op:O})}}else S.ops&&((w=S.node)==null||w.consumeService({op:S.animationWorkData||[],isFullWork:!0,replaceId:L}),S.isDel=!0,N.set(I,{workState:D.Done,op:W.filter((O,z)=>{if(z%g!==g-1)return!0}).slice(-2)}));T=!0;break}break}}if(T&&this.runAnimation(),N.size){const I=[];N.forEach((S,g)=>{I.push({type:f.Cursor,uid:g.split(wt)[0],op:S.op,workState:S.workState,viewId:this.thread.viewId})}),this.thread.post({sp:I})}}runAnimation(){this.animationId||(this.animationId=requestAnimationFrame(this.animationDraw.bind(this)))}hasDiffData(t,e,o){const s=t.length;if(e.length<s)return!0;switch(o){case v.Pencil:{for(let i=0;i<s;i+=3)if(e[i]!==t[i]||e[i+1]!==t[i+1])return!0;break}case v.LaserPen:{for(let i=0;i<s;i+=2)if(e[i]!==t[i]||e[i+1]!==t[i+1])return!0;break}}return!1}activeWorkShape(t){var e,o,s,i;const{workId:r,opt:n,toolsType:a,type:l,updateNodeOpt:c,ops:p,op:h,useAnimation:d}=t;if(!r)return;const u=r.toString(),y=(e=this.vNodes.get(u))==null?void 0:e.rect;if(!((o=this.workShapes)!=null&&o.has(u))){let T={toolsType:a,animationWorkData:h||[],animationIndex:0,type:l,updateNodeOpt:c,ops:p,useAnimation:typeof d<"u"?d:typeof(c==null?void 0:c.useAnimation)<"u"?c==null?void 0:c.useAnimation:!0,oldRect:y,isDiff:!1};a&&n&&(T=this.setNodeKey(T,a,n)),(s=this.workShapes)==null||s.set(u,T)}const w=(i=this.workShapes)==null?void 0:i.get(u);l&&(w.type=l),p&&(w.animationWorkData=ct(p),w.ops=p),c&&(w.updateNodeOpt=c),h&&(w.isDiff=this.hasDiffData(w.animationWorkData||[],h,w.toolsType),w.animationWorkData=h),w.node&&w.node.getWorkId()!==u&&w.node.setWorkId(u),y&&(w.oldRect=y),a&&n&&(w.toolsType!==a&&a&&n&&this.setNodeKey(w,a,n),w.node&&w.node.setWorkOptions(n))}removeNode(t,e){t.indexOf(X)>-1&&this.removeSelectWork(e),this.thread.fullLayer.getElementsByName(t).forEach(o=>{o.remove()}),this.thread.serviceLayer.getElementsByName(t).forEach(o=>{o.remove()}),this.vNodes.delete(t)}removeSelectWork(t){const{workId:e}=t,o=e==null?void 0:e.toString();o&&(this.activeSelectorShape(t),this.willRunEffectSelectorIds.add(o)),this.runEffect()}activeSelectorShape(t){var e,o,s;const{workId:i,opt:r,toolsType:n,type:a,selectIds:l}=t;if(!i)return;const c=i.toString();if(!((e=this.selectorWorkShapes)!=null&&e.has(c))){let h={toolsType:n,selectIds:l,type:a,opt:r};n&&r&&(h=this.setNodeKey(h,n,r)),(o=this.selectorWorkShapes)==null||o.set(c,h)}const p=(s=this.selectorWorkShapes)==null?void 0:s.get(c);a&&(p.type=a),p.node&&p.node.getWorkId()!==c&&p.node.setWorkId(c),p.selectIds=l||[]}setNodeKey(t,e,o){return t.toolsType=e,t.node=ut({toolsType:e,toolsOpt:o,vNodes:this.vNodes,fullLayer:this.thread.fullLayer,drawLayer:this.thread.serviceLayer},this),t}}class K{constructor(){m(this,"localWork"),m(this,"serviceWork"),m(this,"scene")}registerMainThread(t,e,o){return this.localWork=t,this.serviceWork=e,this.scene=o,this}}class oe extends K{constructor(){super(...arguments),m(this,"emitEventType",E.CopyNode)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.FullWork&&o===C.Local&&s===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o}=t;o&&await((e=this.localWork)==null?void 0:e.consumeFull(t,this.scene))}}class se extends K{constructor(){super(...arguments),m(this,"emitEventType",E.SetColorNode)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===C.Local&&s===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willRefreshSelector:i,willSyncService:r,willSerializeData:n,textUpdateForWoker:a}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willRefreshSelector:i,willSyncService:r,willSerializeData:n,textUpdateForWoker:a,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:o,newServiceStore:s}=t,{willSyncService:i,isSync:r,textUpdateForWoker:n}=e,a=o.sp||[];if(i)for(const[l,c]of s.entries())n&&c.toolsType===v.Text?a.push({...c,workId:l,type:f.TextUpdate,dataType:C.Local,willSyncService:!0}):a.push({...c,workId:l,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:r});return{sp:a}}}class ie extends K{constructor(){super(...arguments),m(this,"emitEventType",E.ZIndexNode)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===C.Local&&s===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willRefreshSelector:i,willSyncService:r,willSerializeData:n}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willRefreshSelector:i,willSyncService:r,willSerializeData:n,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:o,newServiceStore:s}=t,{willSyncService:i,isSync:r}=e,n=o.sp||[];if(i&&n)for(const[a,l]of s.entries())n.push({...l,workId:a,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:r});return{sp:n}}}class re extends K{constructor(){super(...arguments),m(this,"emitEventType",E.TranslateNode)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===C.Local&&s===this.emitEventType)return await this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e,o;const{workId:s,updateNodeOpt:i,willRefreshSelector:r,willSyncService:n,willSerializeData:a,textUpdateForWoker:l,emitEventType:c}=t;s===H.selectorId&&i&&(i.workState===D.Done&&i!=null&&i.translate&&(i.translate[0]||i.translate[1])||i.workState!==D.Done?await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:i,willRefreshSelector:r,willSyncService:n,willSerializeData:a,isSync:!0,textUpdateForWoker:l,emitEventType:c,scene:this.scene,callback:this.updateSelectorCallback})):i.workState===D.Done&&((o=this.localWork)==null||o.vNodes.deleteLastTarget()))}updateSelectorCallback(t){const{param:e,postData:o,newServiceStore:s,workShapeNode:i,res:r}=t,{willSyncService:n,isSync:a,updateSelectorOpt:l,textUpdateForWoker:c}=e,p=l.workState,h=o.sp||[];if(p===D.Start)return{sp:[],render:[]};const d=r==null?void 0:r.selectRect;if(n){p===D.Doing&&h.push({type:f.Select,selectIds:i.selectIds,selectRect:d,willSyncService:!0,isSync:!0,points:i.getChildrenPoints(),textOpt:i.textOpt});for(const[u,y]of s.entries())c&&y.toolsType===v.Text?h.push({...y,workId:u,type:f.TextUpdate,dataType:C.Local,willSyncService:!0}):h.push({...y,workId:u,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:a})}return{sp:h}}}class ne extends K{constructor(){super(...arguments),m(this,"emitEventType",E.DeleteNode)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.RemoveNode){if(o===C.Local&&s===this.emitEventType)return this.consumeForLocalWorker(t),!0;if(o===C.Service&&s===this.emitEventType)return this.consumeForServiceWorker(t),!0}}consumeForLocalWorker(t){if(!this.localWork)return;const{removeIds:e,willSyncService:o}=t;if(!(e!=null&&e.length))return;const s=[],i=[];for(const r of e){if(r===X){const a=this.localWork.workShapes.get(X);if(!a)return;const l=a.selectIds&&[...a.selectIds]||[];for(const c of l){if(this.localWork.vNodes.get(c)){const p=this.commandDeleteText(c);p&&s.push(p)}this.localWork.removeNode(c),i.push(c)}this.localWork.blurSelector();continue}const n=this.commandDeleteText(r);n&&s.push(n),this.localWork.removeNode(r),i.push(r)}o&&s.push({type:f.RemoveNode,removeIds:i,undoTickerId:t.undoTickerId}),s.length&&this.localWork.thread.post({sp:s})}consumeForServiceWorker(t){this.serviceWork&&this.serviceWork.removeWork(t)}commandDeleteText(t){var e;const o=(e=this.localWork)==null?void 0:e.vNodes.get(t);if(o&&o.toolsType===v.Text)return{type:f.TextUpdate,toolsType:v.Text,workId:t,dataType:C.Local}}}class ae extends K{constructor(){super(...arguments),m(this,"emitEventType",E.ScaleNode)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===C.Local&&s===this.emitEventType)return await this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willSyncService:i,willSerializeData:r}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willSyncService:i,willSerializeData:r,isSync:!0,scene:this.scene,callback:this.updateSelectorCallback.bind(this)}))}updateSelectorCallback(t){const{param:e,postData:o,workShapeNode:s,res:i,newServiceStore:r}=t,{updateSelectorOpt:n,willSyncService:a,willSerializeData:l}=e,c=n.workState,p=o.sp||[],h=i==null?void 0:i.selectRect;if(c===D.Start)return{sp:[],render:[]};if(a){c===D.Doing&&p.push({type:f.Select,selectIds:s.selectIds,selectRect:h,willSyncService:!0,isSync:!0,points:s.getChildrenPoints(),textOpt:s.textOpt}),l&&c===D.Done&&p.push({type:f.Select,selectIds:s.selectIds,selectRect:h,willSyncService:!1,isSync:!0,points:s.getChildrenPoints(),textOpt:s.textOpt});for(const[d,u]of r.entries())u.toolsType===v.Text?p.push({...u,workId:d,type:f.TextUpdate,dataType:C.Local,willSyncService:!0}):p.push({...u,workId:d,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:!0})}return{sp:p}}}class le extends K{constructor(){super(...arguments),m(this,"emitEventType",E.RotateNode)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===C.Local&&s===this.emitEventType)return await this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willRefreshSelector:i,willSyncService:r,willSerializeData:n,emitEventType:a}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willRefreshSelector:i,willSyncService:r,willSerializeData:n,emitEventType:a,isSync:!0,scene:this.scene,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:o,workShapeNode:s,res:i,newServiceStore:r}=t,{updateSelectorOpt:n,willSyncService:a,willSerializeData:l,isSync:c}=e,p=n.workState,h=o.sp||[],d=i==null?void 0:i.selectRect;if(a){l&&p===D.Done&&h.push({type:f.Select,selectIds:s.selectIds,selectRect:d,willSyncService:!0,isSync:c,points:s.getChildrenPoints()});for(const[u,y]of r.entries())h.push({...y,workId:u,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:c})}return{sp:h}}}class ce extends K{constructor(){super(...arguments),m(this,"emitEventType",E.SetFontStyle)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===C.Local&&s===this.emitEventType)return await this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willRefreshSelector:i,willSyncService:r,willSerializeData:n,textUpdateForWoker:a}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willRefreshSelector:i,willSyncService:r,willSerializeData:n,textUpdateForWoker:a,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:o,newServiceStore:s,workShapeNode:i,res:r}=t,{willSyncService:n,isSync:a,updateSelectorOpt:l,textUpdateForWoker:c}=e,p=o.sp||[],h=r==null?void 0:r.selectRect;if(n&&p){l.fontSize&&p.push({type:f.Select,selectIds:i.selectIds,selectRect:h,willSyncService:n,isSync:a,points:i.getChildrenPoints()});for(const[d,u]of s.entries())c&&u.toolsType===v.Text?p.push({...u,workId:d,type:f.TextUpdate,dataType:C.Local,willSyncService:!0}):p.push({...u,workId:d,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:a})}return{sp:p}}}class he extends K{constructor(){super(...arguments),m(this,"emitEventType",E.SetPoint)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===C.Local&&s===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willRefreshSelector:i,willSyncService:r,willSerializeData:n,textUpdateForWoker:a}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willRefreshSelector:i,willSyncService:r,emitEventType:this.emitEventType,willSerializeData:n,isSync:!0,textUpdateForWoker:a,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:o,newServiceStore:s,workShapeNode:i,res:r}=t,{willSyncService:n,isSync:a}=e,l=o.sp||[],c=r==null?void 0:r.selectRect;if(n&&l){for(const[p,h]of s.entries())l.push({...h,workId:p,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:a});l.push({type:f.Select,selectIds:i.selectIds,selectRect:c,willSyncService:n,isSync:a,points:i.getChildrenPoints()})}return{sp:l}}}class pe extends K{constructor(){super(...arguments),m(this,"emitEventType",E.SetLock)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===C.Local&&s===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willRefreshSelector:i,willSyncService:r,willSerializeData:n}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willRefreshSelector:i,willSyncService:r,willSerializeData:n,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:o,newServiceStore:s,workShapeNode:i,res:r}=t,{willSyncService:n,isSync:a,updateSelectorOpt:l}=e,c=o.sp||[],p=r==null?void 0:r.selectRect;if(n&&c){for(const[h,d]of s.entries())c.push({...d,workId:h,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:a});c.push({isLocked:l.isLocked,selectorColor:i.selectorColor,scaleType:i.scaleType,canRotate:i.canRotate,type:f.Select,selectIds:i.selectIds,selectRect:p,willSyncService:n,isSync:a})}return{sp:c}}}class de extends K{constructor(){super(...arguments),m(this,"emitEventType",E.SetShapeOpt)}async consume(t){const{msgType:e,dataType:o,emitEventType:s}=t;if(e===f.UpdateNode&&o===C.Local&&s===this.emitEventType)return this.consumeForLocalWorker(t),!0}async consumeForLocalWorker(t){var e;const{workId:o,updateNodeOpt:s,willRefreshSelector:i,willSyncService:r,willSerializeData:n}=t;o===H.selectorId&&s&&await((e=this.localWork)==null?void 0:e.updateSelector({updateSelectorOpt:s,willRefreshSelector:i,willSyncService:r,willSerializeData:n,callback:this.updateSelectorCallback}))}updateSelectorCallback(t){const{param:e,postData:o,newServiceStore:s}=t,{willSyncService:i,isSync:r}=e,n=o.sp||[];if(i&&n)for(const[a,l]of s.entries())n.push({...l,workId:a,type:f.UpdateNode,updateNodeOpt:{useAnimation:!1},isSync:r});return{sp:n}}}class ue{constructor(t){m(this,"builders",new Map),this.builders=new Map(t.map(e=>[e,this.build(e)]))}build(t){switch(t){case E.TranslateNode:return new re;case E.ZIndexNode:return new ie;case E.CopyNode:return new oe;case E.SetColorNode:return new se;case E.DeleteNode:return new ne;case E.ScaleNode:return new ae;case E.RotateNode:return new le;case E.SetFontStyle:return new ce;case E.SetPoint:return new he;case E.SetLock:return new pe;case E.SetShapeOpt:return new de}}registerForMainThread(t,e,o){return this.builders.forEach(s=>{s&&s.registerMainThread(t,e,o)}),this}async consumeForMainThread(t){for(const e of this.builders.values())if(await(e==null?void 0:e.consume(t)))return!0;return!1}}class ye{constructor(t,e){m(this,"viewId"),m(this,"fullLayer"),m(this,"topLayer"),m(this,"localLayer"),m(this,"serviceLayer"),m(this,"snapshotFullLayer"),m(this,"vNodes"),m(this,"master"),m(this,"opt"),m(this,"cameraOpt"),m(this,"scene"),m(this,"localWork"),m(this,"serviceWork"),m(this,"topWork"),m(this,"mainThreadPostId"),m(this,"combinePostMsg",new Set),m(this,"methodBuilder"),this.viewId=t,this.opt=e,this.scene=this.createScene({...e.canvasOpt,container:e.container}),this.master=e.master,this.fullLayer=this.createLayer("fullLayer",this.scene,{...e.layerOpt,bufferSize:this.viewId==="mainView"?4e3:2e3}),this.topLayer=this.createLayer("topLayer",this.scene,{...e.layerOpt,bufferSize:this.viewId==="mainView"?1500:1e3}),this.localLayer=this.createLayer("localLayer",this.scene,{...e.layerOpt,bufferSize:this.viewId==="mainView"?1500:1e3}),this.serviceLayer=this.createLayer("serviceLayer",this.scene,{...e.layerOpt,bufferSize:this.viewId==="mainView"?1500:1e3}),this.vNodes=new Jt(t,this.scene);const o={thread:this,vNodes:this.vNodes};this.localWork=new te(o),this.serviceWork=new ee(o),this.topWork=new _t(o),this.vNodes.init(this.fullLayer),this.methodBuilder=new ue([E.CopyNode,E.SetColorNode,E.DeleteNode,E.RotateNode,E.ScaleNode,E.TranslateNode,E.ZIndexNode,E.SetFontStyle,E.SetPoint,E.SetLock,E.SetShapeOpt]).registerForMainThread(this.localWork,this.serviceWork,this.scene)}post(t){this.combinePostMsg.add(t),this.runBatchPostData()}async on(t,e){const{undoTickerId:o}=t;if(!await this.methodBuilder.consumeForMainThread(t)){const{msgType:s,toolsType:i,opt:r,dataType:n,workId:a,workState:l}=t;switch(s){case f.Destroy:this.destroy();break;case f.Clear:this.clearAll();break;case f.UpdateCamera:this.updateCamera(t),e&&this.post({workerTasksqueueCount:e});break;case f.UpdateTools:if(n===C.Local&&i&&r){const c={toolsType:i,toolsOpt:r};this.localWork.setToolsOpt(c)}break;case f.CreateWork:if(a&&r&&i){if(i===v.LaserPen){this.topWork.getTmpWorkShapeNode()||this.topWork.setToolsOpt({toolsType:i,toolsOpt:r}),this.topWork.setWorkOptions(a,r);break}this.localWork.getTmpWorkShapeNode()||this.localWork.setToolsOpt({toolsType:i,toolsOpt:r}),this.localWork.setWorkOptions(a,r)}break;case f.DrawWork:l===D.Done&&n===C.Local?this.consumeDrawAll(n,t):this.consumeDraw(n,t);break;case f.UpdateNode:case f.FullWork:if(i===v.LaserPen){this.consumeDrawAll(n,t);break}this.consumeFull(n,t);break;case f.RemoveNode:this.removeNode(t);return;case f.Select:n===C.Service&&(a===X?this.localWork.updateFullSelectWork(t):this.serviceWork.runSelectWork(t));break;case f.CursorHover:this.localWork.cursorHover(t);break;case f.GetTextActive:n===C.Local&&this.localWork.checkTextActive(t);break}}o&&this.post({sp:[{type:f.None,undoTickerId:o}]})}async removeNode(t){const{dataType:e,workId:o}=t;if(o===X){this.localWork.blurSelector(t);return}e===C.Local&&(this.localWork.removeWork(t),await this.localWork.colloctEffectSelectWork(t)),e===C.Service&&(this.serviceWork.removeWork(t),await this.localWork.colloctEffectSelectWork(t))}async consumeFull(t,e){const o=await this.localWork.colloctEffectSelectWork(e);o&&t===C.Local&&await this.localWork.consumeFull(o,this.scene),o&&t===C.Service&&this.serviceWork.consumeFull(o)}setCameraOpt(t){this.cameraOpt=t;const{scale:e,centerX:o,centerY:s,width:i,height:r}=t;(i!==this.scene.width||r!==this.scene.height)&&this.updateScene({width:i,height:r}),this.fullLayer.setAttribute("scale",[e,e]),this.fullLayer.setAttribute("translate",[-o,-s]),this.topLayer.setAttribute("scale",[e,e]),this.topLayer.setAttribute("translate",[-o,-s]),this.localLayer.setAttribute("scale",[e,e]),this.localLayer.setAttribute("translate",[-o,-s]),this.serviceLayer.setAttribute("scale",[e,e]),this.serviceLayer.setAttribute("translate",[-o,-s])}runBatchPostData(){this.mainThreadPostId||(this.mainThreadPostId=requestAnimationFrame(this.combinePost.bind(this)))}combinePostData(){var t;this.mainThreadPostId=void 0;const e=[];let o,s;for(const i of this.combinePostMsg.values()){if((t=i.sp)!=null&&t.length)for(const r of i.sp){let n=!1;for(const a of e)if(nt(r,a)){n=!0;break}n||e.push(r)}q(i.drawCount)&&(o=i.drawCount),q(i.workerTasksqueueCount)&&(s=i.workerTasksqueueCount)}return this.combinePostMsg.clear(),{sp:e,drawCount:o,workerTasksqueueCount:s}}combinePost(){var t,e,o;const s=this.combinePostData(),i=(t=s.sp)==null?void 0:t.filter(r=>r.type!==f.None||Object.keys(r).filter(n=>n==="type").length);i!=null&&i.length&&(s.sp=i.map(r=>r.viewId?r:{...r,viewId:this.viewId})),((e=s.sp)==null?void 0:e.length)===0&&delete s.sp,s.drawCount===void 0&&delete s.drawCount,s.workerTasksqueueCount===void 0&&delete s.workerTasksqueueCount,(s!=null&&s.drawCount||s!=null&&s.workerTasksqueueCount||(o=s.sp)!=null&&o.length)&&(console.log("mainThread-post-end--001",this.fullLayer.children.length,this.localLayer.children.length,this.topLayer.children.length,this.serviceLayer.children.length),this.opt.post(s))}clearAll(){this.fullLayer.children.length&&(this.fullLayer.parent.children.forEach(t=>{t.name!=="viewport"&&t.remove()}),this.fullLayer.removeAllChildren()),this.localWork.clearAll(),this.topWork.clearAll(),this.serviceWork.clearAll(),this.vNodes.clear()}consumeDrawAll(t,e){const{ops:o,op:s,workId:i}=e;if((o||s!=null&&s.length)&&i){if(this.topWork.localWorkShapes.get(i)){this.topWork.consumeDrawAll(e);return}if(this.localWork.workShapes.get(i)){this.localWork.consumeDrawAll(e,this.serviceWork);return}}}consumeDraw(t,e){const{op:o,workId:s}=e;if(o!=null&&o.length&&s){if(this.topWork.localWorkShapes.get(s)){this.topWork.consumeDraw(e);return}if(this.localWork.workShapes.get(s)){this.localWork.consumeDraw(e,this.serviceWork);return}t===C.Service&&this.serviceWork.consumeDraw(e)}}updateCamera(t){var e;const{cameraOpt:o}=t;if(o&&!nt(this.cameraOpt,o)){const s=this.localWork.getWorkShape(ft);if(s&&(e=s.selectIds)!=null&&e.length&&s.cursorBlur(),this.setCameraOpt(o),this.vNodes.curNodeMap.size&&(this.vNodes.updateNodesRect(),this.localWork.reRenderSelector(),this.serviceWork.selectorWorkShapes.size))for(const[i,r]of this.serviceWork.selectorWorkShapes.entries())this.serviceWork.runSelectWork({workId:i,selectIds:r.selectIds,msgType:f.Select,dataType:C.Service,viewId:this.viewId})}}createScene(t){return t.contextType&&delete t.contextType,new vt({displayRatio:this.opt.displayer.dpr,depth:!1,desynchronized:!0,...t,autoRender:!0})}createLayer(t,e,o){const{width:s,height:i}=o,r=`canvas-${t}`,n=e.layer(r,{...o,offscreen:!1}),a=new G({anchor:[.5,.5],pos:[s*.5,i*.5],size:[s,i],name:"viewport",id:t});return n.append(a),a}updateScene(t){this.scene.attr({...t});const{width:e,height:o}=t;this.scene.width=e,this.scene.height=o,this.updateLayer({width:e,height:o})}updateLayer(t){const{width:e,height:o}=t;this.fullLayer.parent.setAttribute("width",e),this.fullLayer.parent.setAttribute("height",o),this.fullLayer.setAttribute("size",[e,o]),this.fullLayer.setAttribute("pos",[e*.5,o*.5]),this.topLayer.parent.setAttribute("width",e),this.topLayer.parent.setAttribute("height",o),this.topLayer.setAttribute("size",[e,o]),this.topLayer.setAttribute("pos",[e*.5,o*.5]),this.localLayer.parent.setAttribute("width",e),this.localLayer.parent.setAttribute("height",o),this.localLayer.setAttribute("size",[e,o]),this.localLayer.setAttribute("pos",[e*.5,o*.5]),this.serviceLayer.parent.setAttribute("width",e),this.serviceLayer.parent.setAttribute("height",o),this.serviceLayer.setAttribute("size",[e,o]),this.serviceLayer.setAttribute("pos",[e*.5,o*.5])}destroy(){this.vNodes.clear(),this.fullLayer.remove(),this.topLayer.remove(),this.localLayer.remove(),this.serviceLayer.remove(),this.scene.remove(),this.localWork.destroy(),this.serviceWork.destroy(),this.topWork.destroy()}}class me{constructor(t,e){m(this,"viewId"),m(this,"fullLayer"),m(this,"master"),m(this,"opt"),m(this,"scene"),m(this,"mainThreadPostId"),m(this,"combinePostMsg",new Set),m(this,"workShapes",new Map),this.viewId=t,this.opt=e,this.scene=this.createScene({...e.canvasOpt,container:e.container}),this.master=e.master,this.fullLayer=this.createLayer("fullLayer",this.scene,{...e.layerOpt,bufferSize:this.viewId==="mainView"?6e3:3e3})}post(t){this.combinePostMsg.add(t),this.runBatchPostData()}async on(t){const{msgType:e}=t;switch(e){case f.Snapshot:await this.getSnapshot(t),this.destroy();return;case f.BoundingBox:await this.getBoundingRect(t),this.destroy();return}}createWorkShapeNode(t){return ut({...t,fullLayer:this.fullLayer,drawLayer:this.fullLayer})}setFullWork(t){const{workId:e,opt:o,toolsType:s}=t;if(e&&o&&s){const i=e&&this.workShapes.get(e)||this.createWorkShapeNode({toolsOpt:o,toolsType:s,workId:e});return i?(i.setWorkId(e),this.workShapes.set(e,i),i):void 0}}async runFullWork(t,e){var o,s;const i=this.setFullWork(t),r=t.ops&&ct(t.ops);if(i){let n;i.toolsType===v.Image?n=await i.consumeServiceAsync({isFullWork:!0,scene:(o=this.fullLayer.parent)==null?void 0:o.parent,isMainThread:!0}):n=i.consumeService({op:r,isFullWork:!0,replaceId:(s=i.getWorkId())==null?void 0:s.toString(),isDrawLabel:e});const a=(t==null?void 0:t.updateNodeOpt)&&i.updataOptService(t.updateNodeOpt);return t.workId&&this.workShapes.delete(t.workId),a||n}}async getSnapshot(t){const{scenePath:e,scenes:o,cameraOpt:s,w:i,h:r,maxZIndex:n}=t;if(e&&o&&s){this.setCameraOpt(s);let a;const l=new Map;for(const[p,h]of Object.entries(o))if(h!=null&&h.type)switch(h==null?void 0:h.type){case f.UpdateNode:case f.FullWork:{const{toolsType:d,opt:u}=h;d===v.Text&&u&&(u.zIndex=u.zIndex+(n||0),(u.lineThrough||u.underline)&&l.set(p,h));const y=await this.runFullWork({...h,opt:u,workId:p,msgType:f.FullWork,dataType:C.Service,viewId:this.viewId},d===v.Text);a=B(a,y);break}}let c;i&&r&&(c={resizeWidth:i,resizeHeight:r}),l.size&&(await new Promise(p=>{setTimeout(p,500)}),this.willRenderSpecialLabel(l)),await this.getSnapshotRender({scenePath:e,options:c})}}updateLabels(t,e){t.children.forEach(o=>{if(o.tagName==="LABEL"){const s=o.name,{width:i}=o.getBoundingClientRect(),[r]=t.worldScaling,{underline:n,lineThrough:a}=e.opt;n&&t.getElementsByName(`${s}_underline`)[0].attr({points:[0,0,i/r,0]}),a&&t.getElementsByName(`${s}_lineThrough`)[0].attr({points:[0,0,i/r,0]})}})}willRenderSpecialLabel(t){var e;for(const[o,s]of t.entries()){const i=(e=this.fullLayer)==null?void 0:e.getElementsByName(o)[0];i&&s.opt&&this.updateLabels(i,s)}}getSceneRect(){const{width:t,height:e}=this.scene;return{x:0,y:0,w:Math.floor(t),h:Math.floor(e)}}getRectImageBitmap(t,e){const o=t.x*this.opt.displayer.dpr,s=t.y*this.opt.displayer.dpr,i=t.w*this.opt.displayer.dpr,r=t.h*this.opt.displayer.dpr;return createImageBitmap(this.fullLayer.parent.canvas,o,s,i,r,e)}async getSnapshotRender(t){var e,o;const{scenePath:s,options:i}=t;((e=this.fullLayer)==null?void 0:e.parent).render();const r=await this.getRectImageBitmap(this.getSceneRect(),i);r&&(this.post({sp:[{type:f.Snapshot,scenePath:s,imageBitmap:r,viewId:this.viewId}]}),(o=this.fullLayer)==null||o.removeAllChildren())}async getBoundingRect(t){const{scenePath:e,scenes:o,cameraOpt:s}=t;if(e&&o&&s){this.setCameraOpt(s);let i;for(const[r,n]of Object.entries(o))if(n!=null&&n.type)switch(n==null?void 0:n.type){case f.UpdateNode:case f.FullWork:{const a=await this.runFullWork({...n,workId:r,msgType:f.FullWork,dataType:C.Service,viewId:this.viewId});i=B(i,a);break}}i&&this.post({sp:[{type:f.BoundingBox,scenePath:e,rect:i}]})}}setCameraOpt(t){const{scale:e,centerX:o,centerY:s,width:i,height:r}=t;this.updateScene({width:i,height:r}),this.fullLayer.setAttribute("scale",[e,e]),this.fullLayer.setAttribute("translate",[-o,-s])}runBatchPostData(){this.mainThreadPostId||(this.mainThreadPostId=requestAnimationFrame(this.combinePost.bind(this)))}combinePostData(){var t;this.mainThreadPostId=void 0;const e=[];for(const o of this.combinePostMsg.values())if((t=o.sp)!=null&&t.length)for(const s of o.sp){let i=!1;for(const r of e)if(nt(s,r)){i=!0;break}i||e.push(s)}return this.combinePostMsg.clear(),{sp:e}}combinePost(){var t,e,o;const s=this.combinePostData(),i=(t=s.sp)==null?void 0:t.filter(r=>r.type!==f.None||Object.keys(r).filter(n=>n==="type").length);i!=null&&i.length&&(s.sp=i.map(r=>r.viewId?r:{...r,viewId:this.viewId})),((e=s.sp)==null?void 0:e.length)===0&&delete s.sp,(s!=null&&s.drawCount||s!=null&&s.workerTasksqueueCount||(o=s.sp)!=null&&o.length)&&(console.log("mainThread-post-end--001",this.fullLayer.children.length),this.opt.post(s))}createScene(t){return new vt({displayRatio:this.opt.displayer.dpr,depth:!1,desynchronized:!0,...t,autoRender:!1})}createLayer(t,e,o){const{width:s,height:i}=o,r=`canvas-${t}`,n=e.layer(r,o),a=new G({anchor:[.5,.5],pos:[s*.5,i*.5],size:[s,i],name:"viewport",id:t});return n.append(a),a}updateScene(t){this.scene.attr({...t});const{width:e,height:o}=t;this.scene.width=e,this.scene.height=o,this.updateLayer({width:e,height:o})}updateLayer(t){const{width:e,height:o}=t;this.fullLayer.parent.setAttribute("width",e),this.fullLayer.parent.setAttribute("height",o),this.fullLayer.setAttribute("size",[e,o]),this.fullLayer.setAttribute("pos",[e*.5,o*.5])}destroy(){this.fullLayer.remove(),this.scene.remove()}}class we{constructor(t){m(this,"mainThreadMap",new Map),m(this,"snapshotThread"),m(this,"master"),this.master=t}post(t){const{drawCount:e,sp:o,workerTasksqueueCount:s}=t;console.log("mainThread-post-end",t),q(s)&&this.master.setWorkerTasksqueueCount(s),q(e)&&this.master.setMaxDrawCount(e),o&&this.master.collectorSyncData(o)}destroy(){this.mainThreadMap.clear()}createMainThread(t,e){return new ye(t,e)}createSnapshotThread(t,e){return new me(t,e)}consume(t){var e,o,s,i;for(const r of t.values()){const{msgType:n,viewId:a,tasksqueue:l,mainTasksqueueCount:c,layerOpt:p,offscreenCanvasOpt:h,cameraOpt:d}=r;if(n===f.Init){const y=(e=this.master.control.viewContainerManager.getView(a))==null?void 0:e.displayer,w=y==null?void 0:y.canvasContainerRef.current;if(y&&w&&p&&h){const T=this.createMainThread(a,{displayer:y,container:w,layerOpt:p,master:this.master,canvasOpt:h,post:this.post.bind(this)});this.mainThreadMap.set(a,T),T&&d&&T.setCameraOpt(d)}continue}if((n===f.Snapshot||n===f.BoundingBox)&&a===((o=this.master.control.viewContainerManager.mainView)==null?void 0:o.id)){const y=(s=this.master.control.viewContainerManager.getView(a))==null?void 0:s.displayer,w=(i=y.snapshotContainerRef)==null?void 0:i.current;if(y&&w&&d){w.style.width=`${d.width}px`,w.style.height=`${d.height}px`;const T={...St.defaultLayerOpt,offscreen:!1,width:d.width,height:d.height},N={...St.defaultScreenCanvasOpt,width:d.width,height:d.height};this.snapshotThread=this.createSnapshotThread(a,{displayer:y,container:w,layerOpt:T,master:this.master,canvasOpt:N,post:this.post.bind(this)}),this.snapshotThread.on(r).then(()=>{this.snapshotThread=void 0,w.innerHTML="",w.style.width="",w.style.height=""});continue}}if(n===f.TasksQueue&&l!=null&&l.size&&c){for(const[y,w]of this.mainThreadMap.entries()){const T=l.get(y);T&&w.on(T,c)}continue}if(a===Ut){for(const y of this.mainThreadMap.values())y.on(r),n===f.Destroy&&this.mainThreadMap.delete(a);continue}const u=this.mainThreadMap.get(a);u&&(u.on(r),n===f.Destroy&&this.mainThreadMap.delete(a))}}}export{we as MainThreadManagerImpl};
